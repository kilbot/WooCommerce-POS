/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*******************************!*\
  !*** ./assets/js/src/core.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	eval("//\n// Marionette with Radio shim\n//\nvar bb = __webpack_require__(/*! backbone */ 1);\nvar _ = __webpack_require__(/*! underscore */ 2);\nbb.Marionette = __webpack_require__(/*! backbone.marionette */ 23);\nbb.Marionette.Application.prototype._initChannel = function () {\n  this.channelName = _.result(this, 'channelName') || 'global';\n  this.channel = _.result(this, 'channel') ||\n    bb.Radio.channel(this.channelName);\n};\n\n//\n// Backbone plugins\n//\n__webpack_require__(/*! backbone.stickit */ 16);\n__webpack_require__(/*! backbone.syphon/lib/backbone.syphon */ 21);\n__webpack_require__(/*! backbone-validation */ 22);\n__webpack_require__(/*! idb-wrapper */ 17);\n__webpack_require__(/*! backbone-idb/backbone-idb */ 4);\n__webpack_require__(/*! backbone-dualStorage/backbone.dualstorage */ 5);\nbb.FilteredCollection =\n    __webpack_require__(/*! backbone-filtered-collection/backbone-filtered-collection */ 18);\n\n//\n// Bootstrap components\n//\n__webpack_require__(/*! bootstrap-sass/assets/javascripts/bootstrap/modal */ 30);\n__webpack_require__(/*! bootstrap-sass/assets/javascripts/bootstrap/tooltip */ 31);\n__webpack_require__(/*! bootstrap-sass/assets/javascripts/bootstrap/popover */ 32);\n__webpack_require__(/*! bootstrap-sass/assets/javascripts/bootstrap/transition */ 33);\n__webpack_require__(/*! bootstrap-sass/assets/javascripts/bootstrap/dropdown */ 34);\n\n//\n// jQuery plugins\n//\n__webpack_require__(/*! jquery.hotkeys/jquery.hotkeys */ 6);//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvc3JjL2NvcmUuanM/ZjY2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBNYXJpb25ldHRlIHdpdGggUmFkaW8gc2hpbVxuLy9cbnZhciBiYiA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbmJiLk1hcmlvbmV0dGUgPSByZXF1aXJlKCdiYWNrYm9uZS5tYXJpb25ldHRlJyk7XG5iYi5NYXJpb25ldHRlLkFwcGxpY2F0aW9uLnByb3RvdHlwZS5faW5pdENoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hhbm5lbE5hbWUgPSBfLnJlc3VsdCh0aGlzLCAnY2hhbm5lbE5hbWUnKSB8fCAnZ2xvYmFsJztcbiAgdGhpcy5jaGFubmVsID0gXy5yZXN1bHQodGhpcywgJ2NoYW5uZWwnKSB8fFxuICAgIGJiLlJhZGlvLmNoYW5uZWwodGhpcy5jaGFubmVsTmFtZSk7XG59O1xuXG4vL1xuLy8gQmFja2JvbmUgcGx1Z2luc1xuLy9cbnJlcXVpcmUoJ2JhY2tib25lLnN0aWNraXQnKTtcbnJlcXVpcmUoJ2JhY2tib25lLnN5cGhvbi9saWIvYmFja2JvbmUuc3lwaG9uJyk7XG5yZXF1aXJlKCdiYWNrYm9uZS12YWxpZGF0aW9uJyk7XG5yZXF1aXJlKCdpZGItd3JhcHBlcicpO1xucmVxdWlyZSgnYmFja2JvbmUtaWRiL2JhY2tib25lLWlkYicpO1xucmVxdWlyZSgnYmFja2JvbmUtZHVhbFN0b3JhZ2UvYmFja2JvbmUuZHVhbHN0b3JhZ2UnKTtcbmJiLkZpbHRlcmVkQ29sbGVjdGlvbiA9XG4gICAgcmVxdWlyZSgnYmFja2JvbmUtZmlsdGVyZWQtY29sbGVjdGlvbi9iYWNrYm9uZS1maWx0ZXJlZC1jb2xsZWN0aW9uJyk7XG5cbi8vXG4vLyBCb290c3RyYXAgY29tcG9uZW50c1xuLy9cbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvbW9kYWwnKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvdG9vbHRpcCcpO1xucmVxdWlyZSgnYm9vdHN0cmFwLXNhc3MvYXNzZXRzL2phdmFzY3JpcHRzL2Jvb3RzdHJhcC9wb3BvdmVyJyk7XG5yZXF1aXJlKCdib290c3RyYXAtc2Fzcy9hc3NldHMvamF2YXNjcmlwdHMvYm9vdHN0cmFwL3RyYW5zaXRpb24nKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvZHJvcGRvd24nKTtcblxuLy9cbi8vIGpRdWVyeSBwbHVnaW5zXG4vL1xucmVxdWlyZSgnanF1ZXJ5LmhvdGtleXMvanF1ZXJ5LmhvdGtleXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXNzZXRzL2pzL3NyYy9jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIiLCJmaWxlIjoiMC5qcyJ9");

/***/ },
/* 1 */
/*!***************************!*\
  !*** external "Backbone" ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = Backbone;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJCYWNrYm9uZVwiPzcwOWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIkJhY2tib25lXCJcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = _;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJfXCI/YjNiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJfXCJcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */,
/* 4 */
/*!****************************************!*\
  !*** ./~/backbone-idb/backbone-idb.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * @license\n * Backbone IndexedDB Adapter\n * Version 0.2.6\n * Copyright (c) 2013-2014 Vincent Mac\n *\n * Available under MIT license <https://raw.github.com/vincentmac/backbone-idb/master/LICENSE>\n *\n * http://github.com/vincentmac/backbone-idb\n */\n;(function (global, factory) {\n  'use strict';\n  if (true) {\n    // CommonJS Module - Register as a CommonJS Module \n    module.exports = factory(__webpack_require__(/*! underscore */ 2), __webpack_require__(/*! backbone */ 1), __webpack_require__(/*! idb-wrapper */ 17), __webpack_require__(/*! jquery */ 24), 'CommonJS');\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD - Register as an anonymous module\n    define(['underscore', 'backbone', 'jquery'], function(_, Backbone, $) {\n      return factory(_ || global._, Backbone || global.Backbone, IDBStore || global.IDBStore, $ || global.$, 'AMD');\n    });\n  } else {\n    factory(_, Backbone, IDBStore, $ || jQuery, global);\n  }\n}(this, function(_, Backbone, IDBStore, $, global) {\n  'use strict';\n\n  // // Generate four random hex digits.\n  // function S4() {\n  //   return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n  // }\n\n  // // Generate a pseudo-GUID by concatenating random hexadecimal.\n  // function guid() {\n  //   return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n  // }\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var noop = function () {\n  };\n\n\n  Backbone.IndexedDB = function IndexedDB(options, parent) {\n    var that = this;\n    this.parent = parent;  // reference to the model or collection\n\n    var defaultReadyHandler = function () {\n      // console.log('idb:ready this:', this);  // <IDBStore>\n      // console.log('idb:ready that:', that);  // <IndexedDB>\n      \n      // By default, make the Backbone.IndexedDB available through `parent.indexedDB`\n      // that.parent.indexedDB = that;\n      // Fire ready event on parent model or collection\n      that.parent.trigger('idb:ready', that);\n    };\n\n    var defaults = {\n      storeName: 'Store',\n      storePrefix: '',\n      dbVersion: 1,\n      keyPath: 'id',\n      autoIncrement: true,\n      onStoreReady: defaultReadyHandler,\n      onError: defaultErrorHandler,\n      indexes: []\n    };\n\n    options = _.defaults(options || {}, defaults);\n    this.dbName = options.storePrefix + options.storeName;\n    this.store = new IDBStore(options);\n    this.keyPath = options.keyPath;\n  };\n\n  // _.extend(Backbone.IndexedDB.prototype, {\n  Backbone.IndexedDB.prototype = {\n\n    /**\n     * The version of Backbone.IndexedDB\n     *\n     * @type String\n     */\n    version: '0.2.10',\n\n    /**\n     * Add a new model to the store\n     *\n     * @param {Backbone.Model} model - Backbone model to add to store\n     * @param {Object} options - sync options created by Backbone\n     * @param {Function} [options.success] - overridable success callback \n     * @param {Function} [options.error] - overridable error callback\n     */\n    create: function(model, options) {\n      var data = model.attributes;\n      var that = this;\n      this.store.put(data, function(insertedId) {\n        data[that.keyPath] = insertedId;\n        options.success(data)\n      }, options.error);\n\n    },\n\n    /**\n     * Update a model in the store\n     *\n     * @param {Backbone.Model} model - Backbone model to update and save to store\n     * @param {Object} options - sync options created by Backbone\n     * @param {Function} [options.success] - overridable success callback \n     * @param {Function} [options.error] - overridable error callback\n     */\n    update: function(model, options) {\n      this.store.put(model.attributes, options.success, options.error);\n    },\n\n    /**\n     * Retrieve a model from the store\n     *\n     * @param {Backbone.Model} model - Backbone model to get from store\n     * @param {Object} options - sync options created by Backbone\n     * @param {Function} [options.success] - overridable success callback \n     * @param {Function} [options.error] - overridable error callback\n     */\n    read: function(model, options) {\n      this.store.get(model.id, options.success, options.error);\n    },\n\n    /**\n     * Retrieve a collection from the store\n     *\n     * @param {Object} options - sync options created by Backbone\n     * @param {Function} [options.success] - overridable success callback \n     * @param {Function} [options.error] - overridable error callback\n     */\n    getAll: function(options) {\n      this.store.getAll(options.success, options.error);\n    },\n\n    /**\n     * Delete a model from the store\n     *\n     * @param {Backbone.Model} model - Backbone model to delete from store\n     * @param {Object} options - sync options created by Backbone\n     * @param {Function} [options.success] - overridable success callback \n     * @param {Function} [options.error] - overridable error callback\n     */\n    destroy: function(model, options) {\n      if (model.isNew()) {\n        return false;\n      }\n\n      this.store.remove(model.id, options.success, options.error);\n    },\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem - A callback to be called for each match\n     * @param {Object} [options] - An object defining specific options\n     * @param {Object} [options.index=null] - An IDBIndex to operate on\n     * @param {String} [options.order=ASC] - The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] - Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] - Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] - An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] - Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] - A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] - A callback to be called\n     *  if an error occurred during the operation.\n     */\n    iterate: function(onItem, options) {\n      if (options.keyRange && !(options.keyRange instanceof global.IDBKeyRange)) {\n        options.keyRange = this.makeKeyRange(options.keyRange);\n      }\n\n      this.store.iterate(onItem, options);\n    },\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options) {\n      return this.store.makeKeyRange(options);\n    },\n\n    /**\n     * Perform a batch operation to save all models in the current collection to indexedDB.\n     *\n     * @param {Function} [onSuccess] - success callback \n     * @param {Function} [onError] - error callback\n     */\n    saveAll: function(onSuccess, onError) {\n      onSuccess || (onSuccess = noop);\n      onError || (onError = defaultErrorHandler);\n\n      this.store.putBatch(this.parent.toJSON(), onSuccess, onError);\n    },\n\n    /**\n     * Perform a batch operation to save and/or remove models in the current collection to\n     * indexedDB. This is a proxy to the idbstore `batch` method\n     *\n     * @param {Array} dataArray - Array of objects containing the operation to run and\n     *  the model (for put operations).\n     * @param {Function} [onSuccess] - success callback \n     * @param {Function} [onError] - error callback\n     */\n    batch: function(dataArray, onSuccess, onError) {\n      onSuccess || (onSuccess = noop);\n      onError || (onError = defaultErrorHandler);\n\n      this.store.batch(dataArray, onSuccess, onError);\n    },\n\n    /**\n     * Perform a batch put operation to save models to indexedDB. This is a \n     * proxy to the idbstore `putBatch` method\n     *\n     * @param {Array} dataArray - Array of models (in JSON) to store\n     * @param {Function} [onSuccess] - success callback \n     * @param {Function} [onError] - error callback\n     */\n    putBatch: function(dataArray, onSuccess, onError) {\n      onSuccess || (onSuccess = noop);\n      onError || (onError = defaultErrorHandler);\n\n      this.store.putBatch(dataArray, onSuccess, onError);\n    },\n\n    /**\n     * Perform a batch operation to remove models from indexedDB. This is a \n     * proxy to the idbstore `removeBtch` method\n     *\n     * @param {Array} keyArray - keyArray An array of keys to remove\n     * @param {Function} [onSuccess] - success callback \n     * @param {Function} [onError] - error callback\n     */\n    removeBatch: function(keyArray, onSuccess, onError) {\n      onSuccess || (onSuccess = noop);\n      onError || (onError = defaultErrorHandler);\n\n      this.store.removeBatch(keyArray, onSuccess, onError);\n    },\n\n    /**\n     * Clears all content from the current indexedDB for this collection/model\n     *\n     * @param {Function} [onSuccess] - success callback \n     * @param {Function} [onError] - error callback\n     */\n    clear: function(onSuccess, onError) {\n      onSuccess || (onSuccess = noop);\n      onError || (onError = defaultErrorHandler);\n\n      this.store.clear(onSuccess, onError);\n    },\n\n    /**\n     * Deletes the current indexedDB for this collection/model\n     */\n    deleteDatabase: function() {\n      this.store.deleteDatabase();\n    }\n\n  // });\n  };\n\n\n  /**\n   * Backbone.sync drop-in replacement\n   *\n   * This function replaces the model or collection's sync method and remains\n   * compliant with Backbone's api.\n   */\n  Backbone.IndexedDB.sync = Backbone.idbSync = function(method, model, options) {\n    var deferred = new $.Deferred();\n    var db = model.indexedDB || model.collection.indexedDB;\n    // console.log('Backbone.IndexedDB.sync', method, model, options);\n    var success = options.success || noop;\n    var error = options.success || noop;\n    options.success = function (result) {\n      success.apply(this, arguments);\n      deferred.resolve(result);\n    };\n    options.error = function (result) {\n      error.apply(this, arguments);\n      deferred.reject(result);\n    };\n    switch (method) {\n\n      // Retrieve an individual model or entire collection from indexedDB\n      case 'read':\n        model.id !== undefined ? db.read(model, options) : db.getAll(options);\n        break;\n\n      case 'create':\n        if (model.id) {\n          db.update(model, options);\n        } else {\n          db.create(model, options);\n        }\n        break;\n\n      case 'update':\n        if (model.id) {\n          db.update(model, options);\n        } else {\n          db.create(model, options);\n        }\n        break;\n\n      case 'delete':\n        if (model.id) {\n          db.destroy(model, options);\n        }\n        break;\n    }\n    return deferred.promise();\n\n  };\n\n  // Reference original `Backbone.sync`\n  Backbone.ajaxSync = Backbone.sync;\n\n  Backbone.getIDBSyncMethod = function(model) {\n    if(model.indexedDB || (model.collection && model.collection.indexedDB)) {\n      return Backbone.idbSync;\n    }\n\n    return Backbone.ajaxSync;\n  };\n\n  // Override 'Backbone.sync' to default to idbSync,\n  // the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'\n  Backbone.sync = function(method, model, options) {\n    return Backbone.getIDBSyncMethod(model).apply(this, [method, model, options]);\n  };\n\n  Backbone.IndexedDB.version = Backbone.IndexedDB.prototype.version;\n\n  return Backbone.IndexedDB;\n}));//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLWlkYi9iYWNrYm9uZS1pZGIuanM/OWU0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBCYWNrYm9uZSBJbmRleGVkREIgQWRhcHRlclxuICogVmVyc2lvbiAwLjIuNlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgVmluY2VudCBNYWNcbiAqXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vdmluY2VudG1hYy9iYWNrYm9uZS1pZGIvbWFzdGVyL0xJQ0VOU0U+XG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vdmluY2VudG1hYy9iYWNrYm9uZS1pZGJcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENvbW1vbkpTIE1vZHVsZSAtIFJlZ2lzdGVyIGFzIGEgQ29tbW9uSlMgTW9kdWxlIFxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd1bmRlcnNjb3JlJyksIHJlcXVpcmUoJ2JhY2tib25lJyksIHJlcXVpcmUoJ2lkYi13cmFwcGVyJyksIHJlcXVpcmUoJ2pxdWVyeScpLCAnQ29tbW9uSlMnKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQgLSBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlXG4gICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdiYWNrYm9uZScsICdqcXVlcnknXSwgZnVuY3Rpb24oXywgQmFja2JvbmUsICQpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KF8gfHwgZ2xvYmFsLl8sIEJhY2tib25lIHx8IGdsb2JhbC5CYWNrYm9uZSwgSURCU3RvcmUgfHwgZ2xvYmFsLklEQlN0b3JlLCAkIHx8IGdsb2JhbC4kLCAnQU1EJyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeShfLCBCYWNrYm9uZSwgSURCU3RvcmUsICQgfHwgalF1ZXJ5LCBnbG9iYWwpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKF8sIEJhY2tib25lLCBJREJTdG9yZSwgJCwgZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAvLyBHZW5lcmF0ZSBmb3VyIHJhbmRvbSBoZXggZGlnaXRzLlxuICAvLyBmdW5jdGlvbiBTNCgpIHtcbiAgLy8gICByZXR1cm4gKCgoMStNYXRoLnJhbmRvbSgpKSoweDEwMDAwKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAvLyB9XG5cbiAgLy8gLy8gR2VuZXJhdGUgYSBwc2V1ZG8tR1VJRCBieSBjb25jYXRlbmF0aW5nIHJhbmRvbSBoZXhhZGVjaW1hbC5cbiAgLy8gZnVuY3Rpb24gZ3VpZCgpIHtcbiAgLy8gICByZXR1cm4gKFM0KCkrUzQoKStcIi1cIitTNCgpK1wiLVwiK1M0KCkrXCItXCIrUzQoKStcIi1cIitTNCgpK1M0KCkrUzQoKSk7XG4gIC8vIH1cbiAgdmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfTtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgfTtcblxuXG4gIEJhY2tib25lLkluZGV4ZWREQiA9IGZ1bmN0aW9uIEluZGV4ZWREQihvcHRpb25zLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7ICAvLyByZWZlcmVuY2UgdG8gdGhlIG1vZGVsIG9yIGNvbGxlY3Rpb25cblxuICAgIHZhciBkZWZhdWx0UmVhZHlIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2lkYjpyZWFkeSB0aGlzOicsIHRoaXMpOyAgLy8gPElEQlN0b3JlPlxuICAgICAgLy8gY29uc29sZS5sb2coJ2lkYjpyZWFkeSB0aGF0OicsIHRoYXQpOyAgLy8gPEluZGV4ZWREQj5cbiAgICAgIFxuICAgICAgLy8gQnkgZGVmYXVsdCwgbWFrZSB0aGUgQmFja2JvbmUuSW5kZXhlZERCIGF2YWlsYWJsZSB0aHJvdWdoIGBwYXJlbnQuaW5kZXhlZERCYFxuICAgICAgLy8gdGhhdC5wYXJlbnQuaW5kZXhlZERCID0gdGhhdDtcbiAgICAgIC8vIEZpcmUgcmVhZHkgZXZlbnQgb24gcGFyZW50IG1vZGVsIG9yIGNvbGxlY3Rpb25cbiAgICAgIHRoYXQucGFyZW50LnRyaWdnZXIoJ2lkYjpyZWFkeScsIHRoYXQpO1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBzdG9yZU5hbWU6ICdTdG9yZScsXG4gICAgICBzdG9yZVByZWZpeDogJycsXG4gICAgICBkYlZlcnNpb246IDEsXG4gICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICAgIG9uU3RvcmVSZWFkeTogZGVmYXVsdFJlYWR5SGFuZGxlcixcbiAgICAgIG9uRXJyb3I6IGRlZmF1bHRFcnJvckhhbmRsZXIsXG4gICAgICBpbmRleGVzOiBbXVxuICAgIH07XG5cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCBkZWZhdWx0cyk7XG4gICAgdGhpcy5kYk5hbWUgPSBvcHRpb25zLnN0b3JlUHJlZml4ICsgb3B0aW9ucy5zdG9yZU5hbWU7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBJREJTdG9yZShvcHRpb25zKTtcbiAgICB0aGlzLmtleVBhdGggPSBvcHRpb25zLmtleVBhdGg7XG4gIH07XG5cbiAgLy8gXy5leHRlbmQoQmFja2JvbmUuSW5kZXhlZERCLnByb3RvdHlwZSwge1xuICBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgQmFja2JvbmUuSW5kZXhlZERCXG4gICAgICpcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uOiAnMC4yLjEwJyxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBtb2RlbCB0byB0aGUgc3RvcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIC0gQmFja2JvbmUgbW9kZWwgdG8gYWRkIHRvIHN0b3JlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBzeW5jIG9wdGlvbnMgY3JlYXRlZCBieSBCYWNrYm9uZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIC0gb3ZlcnJpZGFibGUgc3VjY2VzcyBjYWxsYmFjayBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvcl0gLSBvdmVycmlkYWJsZSBlcnJvciBjYWxsYmFja1xuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkYXRhID0gbW9kZWwuYXR0cmlidXRlcztcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuc3RvcmUucHV0KGRhdGEsIGZ1bmN0aW9uKGluc2VydGVkSWQpIHtcbiAgICAgICAgZGF0YVt0aGF0LmtleVBhdGhdID0gaW5zZXJ0ZWRJZDtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGRhdGEpXG4gICAgICB9LCBvcHRpb25zLmVycm9yKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBtb2RlbCBpbiB0aGUgc3RvcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIC0gQmFja2JvbmUgbW9kZWwgdG8gdXBkYXRlIGFuZCBzYXZlIHRvIHN0b3JlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBzeW5jIG9wdGlvbnMgY3JlYXRlZCBieSBCYWNrYm9uZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIC0gb3ZlcnJpZGFibGUgc3VjY2VzcyBjYWxsYmFjayBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvcl0gLSBvdmVycmlkYWJsZSBlcnJvciBjYWxsYmFja1xuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3RvcmUucHV0KG1vZGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbW9kZWwgZnJvbSB0aGUgc3RvcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIC0gQmFja2JvbmUgbW9kZWwgdG8gZ2V0IGZyb20gc3RvcmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHN5bmMgb3B0aW9ucyBjcmVhdGVkIGJ5IEJhY2tib25lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gLSBvdmVycmlkYWJsZSBzdWNjZXNzIGNhbGxiYWNrIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSAtIG92ZXJyaWRhYmxlIGVycm9yIGNhbGxiYWNrXG4gICAgICovXG4gICAgcmVhZDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3RvcmUuZ2V0KG1vZGVsLmlkLCBvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIGNvbGxlY3Rpb24gZnJvbSB0aGUgc3RvcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gc3luYyBvcHRpb25zIGNyZWF0ZWQgYnkgQmFja2JvbmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5zdWNjZXNzXSAtIG92ZXJyaWRhYmxlIHN1Y2Nlc3MgY2FsbGJhY2sgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIC0gb3ZlcnJpZGFibGUgZXJyb3IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRBbGw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3RvcmUuZ2V0QWxsKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIG1vZGVsIGZyb20gdGhlIHN0b3JlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbCAtIEJhY2tib25lIG1vZGVsIHRvIGRlbGV0ZSBmcm9tIHN0b3JlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBzeW5jIG9wdGlvbnMgY3JlYXRlZCBieSBCYWNrYm9uZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIC0gb3ZlcnJpZGFibGUgc3VjY2VzcyBjYWxsYmFjayBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvcl0gLSBvdmVycmlkYWJsZSBlcnJvciBjYWxsYmFja1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBpZiAobW9kZWwuaXNOZXcoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RvcmUucmVtb3ZlKG1vZGVsLmlkLCBvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBzdG9yZSB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgY2FsbGluZyBvbkl0ZW1cbiAgICAgKiBmb3IgZWFjaCBlbnRyeSBtYXRjaGluZyB0aGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uSXRlbSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIG1hdGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFuIG9iamVjdCBkZWZpbmluZyBzcGVjaWZpYyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmluZGV4PW51bGxdIC0gQW4gSURCSW5kZXggdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmRlcj1BU0NdIC0gVGhlIG9yZGVyIGluIHdoaWNoIHRvIHByb3ZpZGUgdGhlXG4gICAgICogIHJlc3VsdHMsIGNhbiBiZSAnREVTQycgb3IgJ0FTQydcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Db250aW51ZT10cnVlXSAtIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseVxuICAgICAqICBpdGVyYXRlIHRoZSBjdXJzb3IgdG8gdGhlIG5leHQgcmVzdWx0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maWx0ZXJEdXBsaWNhdGVzPWZhbHNlXSAtIFdoZXRoZXIgdG8gZXhjbHVkZVxuICAgICAqICBkdXBsaWNhdGUgbWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5rZXlSYW5nZT1udWxsXSAtIEFuIElEQktleVJhbmdlIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JpdGVBY2Nlc3M9ZmFsc2VdIC0gV2hldGhlciBncmFudCB3cml0ZSBhY2Nlc3NcbiAgICAgKiAgdG8gdGhlIHN0b3JlIGluIHRoZSBvbkl0ZW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkVuZD1udWxsXSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICogIGl0ZXJhdGlvbiBoYXMgZW5kZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkVycm9yPXRocm93XSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gICAgICogIGlmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGl0ZXJhdGU6IGZ1bmN0aW9uKG9uSXRlbSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMua2V5UmFuZ2UgJiYgIShvcHRpb25zLmtleVJhbmdlIGluc3RhbmNlb2YgZ2xvYmFsLklEQktleVJhbmdlKSkge1xuICAgICAgICBvcHRpb25zLmtleVJhbmdlID0gdGhpcy5tYWtlS2V5UmFuZ2Uob3B0aW9ucy5rZXlSYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RvcmUuaXRlcmF0ZShvbkl0ZW0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEga2V5IHJhbmdlIHVzaW5nIHNwZWNpZmllZCBvcHRpb25zLiBUaGlzIGtleSByYW5nZSBjYW4gYmVcbiAgICAgKiBoYW5kZWQgb3ZlciB0byB0aGUgY291bnQoKSBhbmQgaXRlcmF0ZSgpIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBZb3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBvciBib3RoIG9mIFwibG93ZXJcIiBvciBcInVwcGVyXCIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGtleSByYW5nZSB0byBjcmVhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmxvd2VyXSBUaGUgbG93ZXIgYm91bmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmV4Y2x1ZGVMb3dlcl0gV2hldGhlciB0byBleGNsdWRlIHRoZSBsb3dlclxuICAgICAqICBib3VuZCBwYXNzZWQgaW4gb3B0aW9ucy5sb3dlciBmcm9tIHRoZSBrZXkgcmFuZ2VcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnVwcGVyXSBUaGUgdXBwZXIgYm91bmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmV4Y2x1ZGVVcHBlcl0gV2hldGhlciB0byBleGNsdWRlIHRoZSB1cHBlclxuICAgICAqICBib3VuZCBwYXNzZWQgaW4gb3B0aW9ucy51cHBlciBmcm9tIHRoZSBrZXkgcmFuZ2VcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLm9ubHldIEEgc2luZ2xlIGtleSB2YWx1ZS4gVXNlIHRoaXMgaWYgeW91IG5lZWQgYSBrZXlcbiAgICAgKiAgcmFuZ2UgdGhhdCBvbmx5IGluY2x1ZGVzIG9uZSB2YWx1ZSBmb3IgYSBrZXkuIFByb3ZpZGluZyB0aGlzXG4gICAgICogIHByb3BlcnR5IGludmFsaWRhdGVzIGFsbCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIElEQktleVJhbmdlIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG9wdGlvbnNcbiAgICAgKi9cbiAgICBtYWtlS2V5UmFuZ2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLm1ha2VLZXlSYW5nZShvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGJhdGNoIG9wZXJhdGlvbiB0byBzYXZlIGFsbCBtb2RlbHMgaW4gdGhlIGN1cnJlbnQgY29sbGVjdGlvbiB0byBpbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSAtIHN1Y2Nlc3MgY2FsbGJhY2sgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gZXJyb3IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzYXZlQWxsOiBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIG9uU3VjY2VzcyB8fCAob25TdWNjZXNzID0gbm9vcCk7XG4gICAgICBvbkVycm9yIHx8IChvbkVycm9yID0gZGVmYXVsdEVycm9ySGFuZGxlcik7XG5cbiAgICAgIHRoaXMuc3RvcmUucHV0QmF0Y2godGhpcy5wYXJlbnQudG9KU09OKCksIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBiYXRjaCBvcGVyYXRpb24gdG8gc2F2ZSBhbmQvb3IgcmVtb3ZlIG1vZGVscyBpbiB0aGUgY3VycmVudCBjb2xsZWN0aW9uIHRvXG4gICAgICogaW5kZXhlZERCLiBUaGlzIGlzIGEgcHJveHkgdG8gdGhlIGlkYnN0b3JlIGBiYXRjaGAgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgLSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIG9wZXJhdGlvbiB0byBydW4gYW5kXG4gICAgICogIHRoZSBtb2RlbCAoZm9yIHB1dCBvcGVyYXRpb25zKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSAtIHN1Y2Nlc3MgY2FsbGJhY2sgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gZXJyb3IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBiYXRjaDogZnVuY3Rpb24oZGF0YUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIG9uU3VjY2VzcyB8fCAob25TdWNjZXNzID0gbm9vcCk7XG4gICAgICBvbkVycm9yIHx8IChvbkVycm9yID0gZGVmYXVsdEVycm9ySGFuZGxlcik7XG5cbiAgICAgIHRoaXMuc3RvcmUuYmF0Y2goZGF0YUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgYmF0Y2ggcHV0IG9wZXJhdGlvbiB0byBzYXZlIG1vZGVscyB0byBpbmRleGVkREIuIFRoaXMgaXMgYSBcbiAgICAgKiBwcm94eSB0byB0aGUgaWRic3RvcmUgYHB1dEJhdGNoYCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFBcnJheSAtIEFycmF5IG9mIG1vZGVscyAoaW4gSlNPTikgdG8gc3RvcmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSAtIHN1Y2Nlc3MgY2FsbGJhY2sgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gZXJyb3IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwdXRCYXRjaDogZnVuY3Rpb24oZGF0YUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIG9uU3VjY2VzcyB8fCAob25TdWNjZXNzID0gbm9vcCk7XG4gICAgICBvbkVycm9yIHx8IChvbkVycm9yID0gZGVmYXVsdEVycm9ySGFuZGxlcik7XG5cbiAgICAgIHRoaXMuc3RvcmUucHV0QmF0Y2goZGF0YUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgYmF0Y2ggb3BlcmF0aW9uIHRvIHJlbW92ZSBtb2RlbHMgZnJvbSBpbmRleGVkREIuIFRoaXMgaXMgYSBcbiAgICAgKiBwcm94eSB0byB0aGUgaWRic3RvcmUgYHJlbW92ZUJ0Y2hgIG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5QXJyYXkgLSBrZXlBcnJheSBBbiBhcnJheSBvZiBrZXlzIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIC0gc3VjY2VzcyBjYWxsYmFjayBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBlcnJvciBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlbW92ZUJhdGNoOiBmdW5jdGlvbihrZXlBcnJheSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICBvblN1Y2Nlc3MgfHwgKG9uU3VjY2VzcyA9IG5vb3ApO1xuICAgICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXIpO1xuXG4gICAgICB0aGlzLnN0b3JlLnJlbW92ZUJhdGNoKGtleUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRlbnQgZnJvbSB0aGUgY3VycmVudCBpbmRleGVkREIgZm9yIHRoaXMgY29sbGVjdGlvbi9tb2RlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gLSBzdWNjZXNzIGNhbGxiYWNrIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSAtIGVycm9yIGNhbGxiYWNrXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgb25TdWNjZXNzIHx8IChvblN1Y2Nlc3MgPSBub29wKTtcbiAgICAgIG9uRXJyb3IgfHwgKG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyKTtcblxuICAgICAgdGhpcy5zdG9yZS5jbGVhcihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBjdXJyZW50IGluZGV4ZWREQiBmb3IgdGhpcyBjb2xsZWN0aW9uL21vZGVsXG4gICAgICovXG4gICAgZGVsZXRlRGF0YWJhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdG9yZS5kZWxldGVEYXRhYmFzZSgpO1xuICAgIH1cblxuICAvLyB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBCYWNrYm9uZS5zeW5jIGRyb3AtaW4gcmVwbGFjZW1lbnRcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiByZXBsYWNlcyB0aGUgbW9kZWwgb3IgY29sbGVjdGlvbidzIHN5bmMgbWV0aG9kIGFuZCByZW1haW5zXG4gICAqIGNvbXBsaWFudCB3aXRoIEJhY2tib25lJ3MgYXBpLlxuICAgKi9cbiAgQmFja2JvbmUuSW5kZXhlZERCLnN5bmMgPSBCYWNrYm9uZS5pZGJTeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBkZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gICAgdmFyIGRiID0gbW9kZWwuaW5kZXhlZERCIHx8IG1vZGVsLmNvbGxlY3Rpb24uaW5kZXhlZERCO1xuICAgIC8vIGNvbnNvbGUubG9nKCdCYWNrYm9uZS5JbmRleGVkREIuc3luYycsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IG5vb3A7XG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5zdWNjZXNzIHx8IG5vb3A7XG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgc3VjY2Vzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgIH07XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIGVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBkZWZlcnJlZC5yZWplY3QocmVzdWx0KTtcbiAgICB9O1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG5cbiAgICAgIC8vIFJldHJpZXZlIGFuIGluZGl2aWR1YWwgbW9kZWwgb3IgZW50aXJlIGNvbGxlY3Rpb24gZnJvbSBpbmRleGVkREJcbiAgICAgIGNhc2UgJ3JlYWQnOlxuICAgICAgICBtb2RlbC5pZCAhPT0gdW5kZWZpbmVkID8gZGIucmVhZChtb2RlbCwgb3B0aW9ucykgOiBkYi5nZXRBbGwob3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjcmVhdGUnOlxuICAgICAgICBpZiAobW9kZWwuaWQpIHtcbiAgICAgICAgICBkYi51cGRhdGUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRiLmNyZWF0ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgIGlmIChtb2RlbC5pZCkge1xuICAgICAgICAgIGRiLnVwZGF0ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGIuY3JlYXRlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgaWYgKG1vZGVsLmlkKSB7XG4gICAgICAgICAgZGIuZGVzdHJveShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cbiAgfTtcblxuICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgYEJhY2tib25lLnN5bmNgXG4gIEJhY2tib25lLmFqYXhTeW5jID0gQmFja2JvbmUuc3luYztcblxuICBCYWNrYm9uZS5nZXRJREJTeW5jTWV0aG9kID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICBpZihtb2RlbC5pbmRleGVkREIgfHwgKG1vZGVsLmNvbGxlY3Rpb24gJiYgbW9kZWwuY29sbGVjdGlvbi5pbmRleGVkREIpKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuaWRiU3luYztcbiAgICB9XG5cbiAgICByZXR1cm4gQmFja2JvbmUuYWpheFN5bmM7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgJ0JhY2tib25lLnN5bmMnIHRvIGRlZmF1bHQgdG8gaWRiU3luYyxcbiAgLy8gdGhlIG9yaWdpbmFsICdCYWNrYm9uZS5zeW5jJyBpcyBzdGlsbCBhdmFpbGFibGUgaW4gJ0JhY2tib25lLmFqYXhTeW5jJ1xuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBCYWNrYm9uZS5nZXRJREJTeW5jTWV0aG9kKG1vZGVsKS5hcHBseSh0aGlzLCBbbWV0aG9kLCBtb2RlbCwgb3B0aW9uc10pO1xuICB9O1xuXG4gIEJhY2tib25lLkluZGV4ZWREQi52ZXJzaW9uID0gQmFja2JvbmUuSW5kZXhlZERCLnByb3RvdHlwZS52ZXJzaW9uO1xuXG4gIHJldHVybiBCYWNrYm9uZS5JbmRleGVkREI7XG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja2JvbmUtaWRiL2JhY2tib25lLWlkYi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjQuanMifQ==");

/***/ },
/* 5 */
/*!********************************************************!*\
  !*** ./~/backbone-dualStorage/backbone.dualstorage.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  (function(root, factory) {\n    if (true) {\n      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ 1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== \"undefined\" && typeof require === \"function\") {\n      return module.exports = factory(require(\"backbone\"));\n    } else {\n      return factory(Backbone);\n    }\n  })(this, function(Backbone) {\n    var CONSOLE_TAG, eventNames, idb_create, idb_destroy, idb_getAll, idb_update, states, wrapError;\n    CONSOLE_TAG = \"backbone-dualStorage\";\n    states = {\n      SYNCHRONIZED: 'SYNCHRONIZED',\n      SYNCHRONIZING: 'SYNCHRONIZING',\n      UPDATE_FAILED: 'UPDATE_FAILED',\n      CREATE_FAILED: 'CREATE_FAILED',\n      DELETE_FAILED: 'DELETE_FAILED'\n    };\n    eventNames = {\n      LOCAL_SYNC_FAIL: 'LOCAL_SYNC_FAIL',\n      LOCAL_SYNC_SUCCESS: 'LOCAL_SYNC_SUCCESS',\n      REMOTE_SYNC_FAIL: 'REMOTE_SYNC_FAIL',\n      REMOTE_SYNC_SUCCESS: 'REMOTE_SYNC_SUCCESS',\n      SYNCHRONIZED: 'SYNCHRONIZED'\n    };\n    wrapError = function(model, options) {\n      var error;\n      error = options.error;\n      return options.error = function(resp) {\n        if (error) {\n          error(model, resp, options);\n        }\n        return model.trigger('error', model, resp, options);\n      };\n    };\n    Backbone.DualModel = Backbone.Model.extend({\n      states: states,\n      remoteIdAttribute: 'id',\n      hasRemoteId: function() {\n        return !!this.get(this.remoteIdAttribute);\n      },\n      getUrlForSync: function(urlRoot, method) {\n        var remoteId;\n        remoteId = this.get(this.remoteIdAttribute);\n        if (remoteId && (method === 'update' || method === 'delete')) {\n          return \"\" + urlRoot + \"/\" + remoteId + \"/\";\n        }\n        return urlRoot;\n      },\n      isInSynchronizing: function() {\n        return this.get('status') === this.states.SYNCHRONIZING;\n      },\n      isDelayed: function() {\n        var _ref;\n        return (_ref = this.get('status')) === this.states.DELETE_FAILED || _ref === this.states.UPDATE_FAILED || _ref === this.states.CREATE_FAILED;\n      }\n    });\n    idb_create = Backbone.IndexedDB.prototype.create;\n    Backbone.IndexedDB.prototype.create = function(model, options) {\n      var data;\n      if (!this.dualStorage) {\n        return idb_create.call(this, model, options);\n      }\n      model.set('status', states.CREATE_FAILED);\n      data = model.attributes;\n      return this.store.put(data, (function(_this) {\n        return function(insertedId) {\n          data[_this.keyPath] = insertedId;\n          return options.success(data);\n        };\n      })(this), options.error);\n    };\n    idb_update = Backbone.IndexedDB.prototype.update;\n    Backbone.IndexedDB.prototype.update = function(model, options) {\n      var data;\n      if (!this.dualStorage) {\n        return idb_update.call(this, model, options);\n      }\n      if (model.hasRemoteId()) {\n        model.set('status', states.UPDATE_FAILED);\n      }\n      data = model.attributes;\n      return this.store.put(data, options.success, options.error);\n    };\n    idb_getAll = Backbone.IndexedDB.prototype.getAll;\n    Backbone.IndexedDB.prototype.getAll = function(options) {\n      var data;\n      if (!this.dualStorage) {\n        return idb_getAll.call(this, options);\n      }\n      data = [];\n      return this.iterate(function(item) {\n        if (item.status !== states.DELETE_FAILED) {\n          return data.push(item);\n        }\n      }, {\n        onEnd: function() {\n          return options.success(data);\n        }\n      });\n    };\n    idb_destroy = Backbone.IndexedDB.prototype.destroy;\n    Backbone.IndexedDB.prototype.destroy = function(model, options) {\n      var data;\n      if (!this.dualStorage) {\n        return idb_destroy.call(this, model, options);\n      }\n      if (model.isNew()) {\n        return false;\n      }\n      model.set('status', states.DELETE_FAILED);\n      data = model.attributes;\n      return this.store.put(data, options.success, options.error);\n    };\n    Backbone.DualCollection = Backbone.Collection.extend({\n      states: states,\n      eventNames: eventNames,\n      getSyncMethodsByState: function(state) {\n        var method;\n        return method = (function() {\n          switch (false) {\n            case this.states.CREATE_FAILED !== state:\n              return 'create';\n            case this.states.UPDATE_FAILED !== state:\n              return 'update';\n            case this.states.DELETE_FAILED !== state:\n              return 'delete';\n          }\n        }).call(this);\n      },\n      mergeFirstSync: function(newData) {\n        return newData;\n      },\n      mergeFullSync: function(newData) {\n        return newData;\n      },\n      firstSync: function(options) {\n        var event, fetchSuccess, originalSuccess, syncError, syncSuccess;\n        if (options == null) {\n          options = {};\n        }\n        originalSuccess = options.success || $.noop;\n        event = _.extend({}, Backbone.Events);\n        syncSuccess = (function(_this) {\n          return function(response) {\n            var data, method;\n            data = _this.mergeFirstSync(_this.parse(response));\n            event.trigger(_this.eventNames.REMOTE_SYNC_SUCCESS);\n            method = options.reset ? 'reset' : 'set';\n            _this[method](data, options);\n            originalSuccess(_this, data, options);\n            _this.trigger('sync', _this, data, options);\n            wrapError(_this, options);\n            return _this.save().done(function() {\n              return _this.fetch().done(function() {\n                return event.trigger(_this.eventNames.SYNCHRONIZED);\n              });\n            });\n          };\n        })(this);\n        syncError = (function(_this) {\n          return function(error) {\n            return event.trigger(_this.eventNames.REMOTE_SYNC_FAIL, error, options);\n          };\n        })(this);\n        fetchSuccess = (function(_this) {\n          return function(data) {\n            options.success = syncSuccess;\n            options.error = syncError;\n            event.trigger(_this.eventNames.LOCAL_SYNC_SUCCESS, data);\n            return Backbone.ajaxSync('read', _this, options);\n          };\n        })(this);\n        this.fetch({\n          success: fetchSuccess,\n          error: function(error) {\n            return event.trigger(this.eventNames.LOCAL_SYNC_FAIL, error);\n          }\n        });\n        return event;\n      },\n      removeGarbage: function(delayedData) {\n        var deferred, idsForRemove, key;\n        deferred = new $.Deferred();\n        key = this.indexedDB.keyPath;\n        idsForRemove = _.map(delayedData, function(item) {\n          return item[key];\n        });\n        this.indexedDB.removeBatch(idsForRemove, (function() {\n          return deferred.resolve();\n        }), (function() {\n          return deferred.reject();\n        }));\n        return deferred.promise();\n      },\n      _getDelayedData: function(status) {\n        var data, deferred, keyRange, options;\n        deferred = new $.Deferred();\n        data = [];\n        keyRange = this.indexedDB.makeKeyRange({\n          lower: status,\n          upper: status\n        });\n        options = {\n          index: 'status',\n          keyRange: keyRange,\n          onEnd: function() {\n            return deferred.resolve(data);\n          }\n        };\n        this.indexedDB.iterate(function(item) {\n          return data.push(item);\n        }, options);\n        return deferred.promise();\n      },\n      getDelayedData: function() {\n        var created, deferred, deleted, updated;\n        deferred = new $.Deferred();\n        deleted = this._getDelayedData(this.states.DELETE_FAILED);\n        created = this._getDelayedData(this.states.CREATE_FAILED);\n        updated = this._getDelayedData(this.states.UPDATE_FAILED);\n        $.when(deleted, created, updated).done(function(a, b, c) {\n          return deferred.resolve(_.union(a, b, c));\n        });\n        return deferred.promise();\n      },\n      fullSync: function() {\n        var deferred;\n        deferred = new $.Deferred();\n        this.getDelayedData().done((function(_this) {\n          return function(delayedData) {\n            var count, done;\n            console.log(CONSOLE_TAG, 'start full sync', delayedData);\n            count = 0;\n            done = function() {\n              count++;\n              if (count === delayedData.length) {\n                return _this.fetch().done(function() {\n                  return deferred.resolve();\n                });\n              }\n            };\n            return _.each(delayedData, function(item) {\n              var method, model, status;\n              status = item.status;\n              method = _this.getSyncMethodsByState(status);\n              delete item.status;\n              model = new _this.model(item);\n              console.log(CONSOLE_TAG, 'full sync model', item, method);\n              model.url = model.getUrlForSync(_.result(_this, 'url'), method);\n              return Backbone.ajaxSync(method, model, {\n                success: (function(response) {\n                  var data;\n                  if (status === _this.states.DELETE_FAILED) {\n                    return _this.removeGarbage([item]).done(done());\n                  } else {\n                    data = _this.mergeFullSync(model.parse(response));\n                    if (!data.status) {\n                      data.status = '';\n                    }\n                    model = _this.get(item[_this.indexedDB.keyPath]).set(data);\n                    return _this.indexedDB.store.put(model.attributes, done, done);\n                  }\n                }),\n                error: function(jqXHR, textStatus, errorThrown) {\n                  var collection;\n                  if (method === 'update') {\n                    collection = _this;\n                    model.fetch({\n                      success: function(model) {\n                        return collection.indexedDB.store.put(model.attributes);\n                      }\n                    });\n                  }\n                  return deferred.reject(item, jqXHR, textStatus, errorThrown);\n                }\n              });\n            });\n          };\n        })(this));\n        return deferred.promise();\n      },\n      save: function() {\n        var deferred;\n        deferred = new $.Deferred();\n        this.indexedDB.saveAll((function() {\n          return deferred.resolve();\n        }), (function() {\n          return deferred.reject();\n        }));\n        return deferred.promise();\n      }\n    });\n    return Backbone;\n  });\n\n}).call(this);\n\n//# sourceMappingURL=backbone.dualstorage.js.map\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLWR1YWxTdG9yYWdlL2JhY2tib25lLmR1YWxzdG9yYWdlLmpzPzA2NzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVILENBQUM7O0FBRUQiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtcImJhY2tib25lXCJdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImJhY2tib25lXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoQmFja2JvbmUpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oQmFja2JvbmUpIHtcbiAgICB2YXIgQ09OU09MRV9UQUcsIGV2ZW50TmFtZXMsIGlkYl9jcmVhdGUsIGlkYl9kZXN0cm95LCBpZGJfZ2V0QWxsLCBpZGJfdXBkYXRlLCBzdGF0ZXMsIHdyYXBFcnJvcjtcbiAgICBDT05TT0xFX1RBRyA9IFwiYmFja2JvbmUtZHVhbFN0b3JhZ2VcIjtcbiAgICBzdGF0ZXMgPSB7XG4gICAgICBTWU5DSFJPTklaRUQ6ICdTWU5DSFJPTklaRUQnLFxuICAgICAgU1lOQ0hST05JWklORzogJ1NZTkNIUk9OSVpJTkcnLFxuICAgICAgVVBEQVRFX0ZBSUxFRDogJ1VQREFURV9GQUlMRUQnLFxuICAgICAgQ1JFQVRFX0ZBSUxFRDogJ0NSRUFURV9GQUlMRUQnLFxuICAgICAgREVMRVRFX0ZBSUxFRDogJ0RFTEVURV9GQUlMRUQnXG4gICAgfTtcbiAgICBldmVudE5hbWVzID0ge1xuICAgICAgTE9DQUxfU1lOQ19GQUlMOiAnTE9DQUxfU1lOQ19GQUlMJyxcbiAgICAgIExPQ0FMX1NZTkNfU1VDQ0VTUzogJ0xPQ0FMX1NZTkNfU1VDQ0VTUycsXG4gICAgICBSRU1PVEVfU1lOQ19GQUlMOiAnUkVNT1RFX1NZTkNfRkFJTCcsXG4gICAgICBSRU1PVEVfU1lOQ19TVUNDRVNTOiAnUkVNT1RFX1NZTkNfU1VDQ0VTUycsXG4gICAgICBTWU5DSFJPTklaRUQ6ICdTWU5DSFJPTklaRUQnXG4gICAgfTtcbiAgICB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGVycm9yKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgQmFja2JvbmUuRHVhbE1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICAgIHN0YXRlczogc3RhdGVzLFxuICAgICAgcmVtb3RlSWRBdHRyaWJ1dGU6ICdpZCcsXG4gICAgICBoYXNSZW1vdGVJZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KHRoaXMucmVtb3RlSWRBdHRyaWJ1dGUpO1xuICAgICAgfSxcbiAgICAgIGdldFVybEZvclN5bmM6IGZ1bmN0aW9uKHVybFJvb3QsIG1ldGhvZCkge1xuICAgICAgICB2YXIgcmVtb3RlSWQ7XG4gICAgICAgIHJlbW90ZUlkID0gdGhpcy5nZXQodGhpcy5yZW1vdGVJZEF0dHJpYnV0ZSk7XG4gICAgICAgIGlmIChyZW1vdGVJZCAmJiAobWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdkZWxldGUnKSkge1xuICAgICAgICAgIHJldHVybiBcIlwiICsgdXJsUm9vdCArIFwiL1wiICsgcmVtb3RlSWQgKyBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsUm9vdDtcbiAgICAgIH0sXG4gICAgICBpc0luU3luY2hyb25pemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnc3RhdHVzJykgPT09IHRoaXMuc3RhdGVzLlNZTkNIUk9OSVpJTkc7XG4gICAgICB9LFxuICAgICAgaXNEZWxheWVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IHRoaXMuZ2V0KCdzdGF0dXMnKSkgPT09IHRoaXMuc3RhdGVzLkRFTEVURV9GQUlMRUQgfHwgX3JlZiA9PT0gdGhpcy5zdGF0ZXMuVVBEQVRFX0ZBSUxFRCB8fCBfcmVmID09PSB0aGlzLnN0YXRlcy5DUkVBVEVfRkFJTEVEO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlkYl9jcmVhdGUgPSBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLmNyZWF0ZTtcbiAgICBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghdGhpcy5kdWFsU3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gaWRiX2NyZWF0ZS5jYWxsKHRoaXMsIG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLnNldCgnc3RhdHVzJywgc3RhdGVzLkNSRUFURV9GQUlMRUQpO1xuICAgICAgZGF0YSA9IG1vZGVsLmF0dHJpYnV0ZXM7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5wdXQoZGF0YSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpbnNlcnRlZElkKSB7XG4gICAgICAgICAgZGF0YVtfdGhpcy5rZXlQYXRoXSA9IGluc2VydGVkSWQ7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc3VjY2VzcyhkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpLCBvcHRpb25zLmVycm9yKTtcbiAgICB9O1xuICAgIGlkYl91cGRhdGUgPSBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLnVwZGF0ZTtcbiAgICBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghdGhpcy5kdWFsU3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gaWRiX3VwZGF0ZS5jYWxsKHRoaXMsIG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5oYXNSZW1vdGVJZCgpKSB7XG4gICAgICAgIG1vZGVsLnNldCgnc3RhdHVzJywgc3RhdGVzLlVQREFURV9GQUlMRUQpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IG1vZGVsLmF0dHJpYnV0ZXM7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5wdXQoZGF0YSwgb3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcbiAgICB9O1xuICAgIGlkYl9nZXRBbGwgPSBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLmdldEFsbDtcbiAgICBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKCF0aGlzLmR1YWxTdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBpZGJfZ2V0QWxsLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBkYXRhID0gW107XG4gICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uc3RhdHVzICE9PSBzdGF0ZXMuREVMRVRFX0ZBSUxFRCkge1xuICAgICAgICAgIHJldHVybiBkYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLnN1Y2Nlc3MoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWRiX2Rlc3Ryb3kgPSBCYWNrYm9uZS5JbmRleGVkREIucHJvdG90eXBlLmRlc3Ryb3k7XG4gICAgQmFja2JvbmUuSW5kZXhlZERCLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKCF0aGlzLmR1YWxTdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBpZGJfZGVzdHJveS5jYWxsKHRoaXMsIG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5pc05ldygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLnNldCgnc3RhdHVzJywgc3RhdGVzLkRFTEVURV9GQUlMRUQpO1xuICAgICAgZGF0YSA9IG1vZGVsLmF0dHJpYnV0ZXM7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5wdXQoZGF0YSwgb3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcbiAgICB9O1xuICAgIEJhY2tib25lLkR1YWxDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgICAgc3RhdGVzOiBzdGF0ZXMsXG4gICAgICBldmVudE5hbWVzOiBldmVudE5hbWVzLFxuICAgICAgZ2V0U3luY01ldGhvZHNCeVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgbWV0aG9kO1xuICAgICAgICByZXR1cm4gbWV0aG9kID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zdGF0ZXMuQ1JFQVRFX0ZBSUxFRCAhPT0gc3RhdGU6XG4gICAgICAgICAgICAgIHJldHVybiAnY3JlYXRlJztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zdGF0ZXMuVVBEQVRFX0ZBSUxFRCAhPT0gc3RhdGU6XG4gICAgICAgICAgICAgIHJldHVybiAndXBkYXRlJztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zdGF0ZXMuREVMRVRFX0ZBSUxFRCAhPT0gc3RhdGU6XG4gICAgICAgICAgICAgIHJldHVybiAnZGVsZXRlJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9LFxuICAgICAgbWVyZ2VGaXJzdFN5bmM6IGZ1bmN0aW9uKG5ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICB9LFxuICAgICAgbWVyZ2VGdWxsU3luYzogZnVuY3Rpb24obmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgIH0sXG4gICAgICBmaXJzdFN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGV2ZW50LCBmZXRjaFN1Y2Nlc3MsIG9yaWdpbmFsU3VjY2Vzcywgc3luY0Vycm9yLCBzeW5jU3VjY2VzcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW5hbFN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgfHwgJC5ub29wO1xuICAgICAgICBldmVudCA9IF8uZXh0ZW5kKHt9LCBCYWNrYm9uZS5FdmVudHMpO1xuICAgICAgICBzeW5jU3VjY2VzcyA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIG1ldGhvZDtcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5tZXJnZUZpcnN0U3luYyhfdGhpcy5wYXJzZShyZXNwb25zZSkpO1xuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcihfdGhpcy5ldmVudE5hbWVzLlJFTU9URV9TWU5DX1NVQ0NFU1MpO1xuICAgICAgICAgICAgbWV0aG9kID0gb3B0aW9ucy5yZXNldCA/ICdyZXNldCcgOiAnc2V0JztcbiAgICAgICAgICAgIF90aGlzW21ldGhvZF0oZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBvcmlnaW5hbFN1Y2Nlc3MoX3RoaXMsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMudHJpZ2dlcignc3luYycsIF90aGlzLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdyYXBFcnJvcihfdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2F2ZSgpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRyaWdnZXIoX3RoaXMuZXZlbnROYW1lcy5TWU5DSFJPTklaRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBzeW5jRXJyb3IgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC50cmlnZ2VyKF90aGlzLmV2ZW50TmFtZXMuUkVNT1RFX1NZTkNfRkFJTCwgZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBmZXRjaFN1Y2Nlc3MgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gc3luY1N1Y2Nlc3M7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yID0gc3luY0Vycm9yO1xuICAgICAgICAgICAgZXZlbnQudHJpZ2dlcihfdGhpcy5ldmVudE5hbWVzLkxPQ0FMX1NZTkNfU1VDQ0VTUywgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gQmFja2JvbmUuYWpheFN5bmMoJ3JlYWQnLCBfdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIHRoaXMuZmV0Y2goe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZldGNoU3VjY2VzcyxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC50cmlnZ2VyKHRoaXMuZXZlbnROYW1lcy5MT0NBTF9TWU5DX0ZBSUwsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlR2FyYmFnZTogZnVuY3Rpb24oZGVsYXllZERhdGEpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkLCBpZHNGb3JSZW1vdmUsIGtleTtcbiAgICAgICAgZGVmZXJyZWQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuICAgICAgICBrZXkgPSB0aGlzLmluZGV4ZWREQi5rZXlQYXRoO1xuICAgICAgICBpZHNGb3JSZW1vdmUgPSBfLm1hcChkZWxheWVkRGF0YSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluZGV4ZWREQi5yZW1vdmVCYXRjaChpZHNGb3JSZW1vdmUsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9KSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgfSxcbiAgICAgIF9nZXREZWxheWVkRGF0YTogZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgIHZhciBkYXRhLCBkZWZlcnJlZCwga2V5UmFuZ2UsIG9wdGlvbnM7XG4gICAgICAgIGRlZmVycmVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBrZXlSYW5nZSA9IHRoaXMuaW5kZXhlZERCLm1ha2VLZXlSYW5nZSh7XG4gICAgICAgICAgbG93ZXI6IHN0YXR1cyxcbiAgICAgICAgICB1cHBlcjogc3RhdHVzXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGluZGV4OiAnc3RhdHVzJyxcbiAgICAgICAgICBrZXlSYW5nZToga2V5UmFuZ2UsXG4gICAgICAgICAgb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluZGV4ZWREQi5pdGVyYXRlKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgIH0sXG4gICAgICBnZXREZWxheWVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcmVhdGVkLCBkZWZlcnJlZCwgZGVsZXRlZCwgdXBkYXRlZDtcbiAgICAgICAgZGVmZXJyZWQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuICAgICAgICBkZWxldGVkID0gdGhpcy5fZ2V0RGVsYXllZERhdGEodGhpcy5zdGF0ZXMuREVMRVRFX0ZBSUxFRCk7XG4gICAgICAgIGNyZWF0ZWQgPSB0aGlzLl9nZXREZWxheWVkRGF0YSh0aGlzLnN0YXRlcy5DUkVBVEVfRkFJTEVEKTtcbiAgICAgICAgdXBkYXRlZCA9IHRoaXMuX2dldERlbGF5ZWREYXRhKHRoaXMuc3RhdGVzLlVQREFURV9GQUlMRUQpO1xuICAgICAgICAkLndoZW4oZGVsZXRlZCwgY3JlYXRlZCwgdXBkYXRlZCkuZG9uZShmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoXy51bmlvbihhLCBiLCBjKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgfSxcbiAgICAgIGZ1bGxTeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkO1xuICAgICAgICBkZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuZ2V0RGVsYXllZERhdGEoKS5kb25lKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkZWxheWVkRGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvdW50LCBkb25lO1xuICAgICAgICAgICAgY29uc29sZS5sb2coQ09OU09MRV9UQUcsICdzdGFydCBmdWxsIHN5bmMnLCBkZWxheWVkRGF0YSk7XG4gICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gZGVsYXllZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoKCkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gXy5lYWNoKGRlbGF5ZWREYXRhLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBtZXRob2QsIG1vZGVsLCBzdGF0dXM7XG4gICAgICAgICAgICAgIHN0YXR1cyA9IGl0ZW0uc3RhdHVzO1xuICAgICAgICAgICAgICBtZXRob2QgPSBfdGhpcy5nZXRTeW5jTWV0aG9kc0J5U3RhdGUoc3RhdHVzKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0uc3RhdHVzO1xuICAgICAgICAgICAgICBtb2RlbCA9IG5ldyBfdGhpcy5tb2RlbChpdGVtKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coQ09OU09MRV9UQUcsICdmdWxsIHN5bmMgbW9kZWwnLCBpdGVtLCBtZXRob2QpO1xuICAgICAgICAgICAgICBtb2RlbC51cmwgPSBtb2RlbC5nZXRVcmxGb3JTeW5jKF8ucmVzdWx0KF90aGlzLCAndXJsJyksIG1ldGhvZCk7XG4gICAgICAgICAgICAgIHJldHVybiBCYWNrYm9uZS5hamF4U3luYyhtZXRob2QsIG1vZGVsLCB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IF90aGlzLnN0YXRlcy5ERUxFVEVfRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVHYXJiYWdlKFtpdGVtXSkuZG9uZShkb25lKCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF90aGlzLm1lcmdlRnVsbFN5bmMobW9kZWwucGFyc2UocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBfdGhpcy5nZXQoaXRlbVtfdGhpcy5pbmRleGVkREIua2V5UGF0aF0pLnNldChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmluZGV4ZWREQi5zdG9yZS5wdXQobW9kZWwuYXR0cmlidXRlcywgZG9uZSwgZG9uZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAndXBkYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZldGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaW5kZXhlZERCLnN0b3JlLnB1dChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChpdGVtLCBqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICB9LFxuICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZDtcbiAgICAgICAgZGVmZXJyZWQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLmluZGV4ZWREQi5zYXZlQWxsKChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9KSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBCYWNrYm9uZTtcbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tib25lLmR1YWxzdG9yYWdlLmpzLm1hcFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja2JvbmUtZHVhbFN0b3JhZ2UvYmFja2JvbmUuZHVhbHN0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiI1LmpzIn0=");

/***/ },
/* 6 */
/*!********************************************!*\
  !*** ./~/jquery.hotkeys/jquery.hotkeys.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/*jslint browser: true*/\n/*jslint jquery: true*/\n\n/*\n * jQuery Hotkeys Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n * Based upon the plugin by Tzury Bar Yochay:\n * http://github.com/tzuryby/hotkeys\n *\n * Original idea by:\n * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/\n */\n\n/*\n * One small change is: now keys are passed by object { keys: '...' }\n * Might be useful, when you want to pass some other data to your handler\n */\n\n(function(jQuery) {\n\n  jQuery.hotkeys = {\n    version: \"0.8\",\n\n    specialKeys: {\n      8: \"backspace\",\n      9: \"tab\",\n      10: \"return\",\n      13: \"return\",\n      16: \"shift\",\n      17: \"ctrl\",\n      18: \"alt\",\n      19: \"pause\",\n      20: \"capslock\",\n      27: \"esc\",\n      32: \"space\",\n      33: \"pageup\",\n      34: \"pagedown\",\n      35: \"end\",\n      36: \"home\",\n      37: \"left\",\n      38: \"up\",\n      39: \"right\",\n      40: \"down\",\n      45: \"insert\",\n      46: \"del\",\n      59: \";\",\n      61: \"=\",\n      96: \"0\",\n      97: \"1\",\n      98: \"2\",\n      99: \"3\",\n      100: \"4\",\n      101: \"5\",\n      102: \"6\",\n      103: \"7\",\n      104: \"8\",\n      105: \"9\",\n      106: \"*\",\n      107: \"+\",\n      109: \"-\",\n      110: \".\",\n      111: \"/\",\n      112: \"f1\",\n      113: \"f2\",\n      114: \"f3\",\n      115: \"f4\",\n      116: \"f5\",\n      117: \"f6\",\n      118: \"f7\",\n      119: \"f8\",\n      120: \"f9\",\n      121: \"f10\",\n      122: \"f11\",\n      123: \"f12\",\n      144: \"numlock\",\n      145: \"scroll\",\n      173: \"-\",\n      186: \";\",\n      187: \"=\",\n      188: \",\",\n      189: \"-\",\n      190: \".\",\n      191: \"/\",\n      192: \"`\",\n      219: \"[\",\n      220: \"\\\\\",\n      221: \"]\",\n      222: \"'\"\n    },\n\n    shiftNums: {\n      \"`\": \"~\",\n      \"1\": \"!\",\n      \"2\": \"@\",\n      \"3\": \"#\",\n      \"4\": \"$\",\n      \"5\": \"%\",\n      \"6\": \"^\",\n      \"7\": \"&\",\n      \"8\": \"*\",\n      \"9\": \"(\",\n      \"0\": \")\",\n      \"-\": \"_\",\n      \"=\": \"+\",\n      \";\": \": \",\n      \"'\": \"\\\"\",\n      \",\": \"<\",\n      \".\": \">\",\n      \"/\": \"?\",\n      \"\\\\\": \"|\"\n    },\n\n    // excludes: button, checkbox, file, hidden, image, password, radio, reset, search, submit, url\n    textAcceptingInputTypes: [\n      \"text\", \"password\", \"number\", \"email\", \"url\", \"range\", \"date\", \"month\", \"week\", \"time\", \"datetime\",\n      \"datetime-local\", \"search\", \"color\", \"tel\"],\n\n    options: {\n      filterTextInputs: true\n    }\n  };\n\n  function keyHandler(handleObj) {\n    if (typeof handleObj.data === \"string\") {\n      handleObj.data = {\n        keys: handleObj.data\n      };\n    }\n\n    // Only care when a possible input has been specified\n    if (!handleObj.data || !handleObj.data.keys || typeof handleObj.data.keys !== \"string\") {\n      return;\n    }\n\n    var origHandler = handleObj.handler,\n      keys = handleObj.data.keys.toLowerCase().split(\" \");\n\n    handleObj.handler = function(event) {\n      //      Don't fire in text-accepting inputs that we didn't directly bind to\n      if (this !== event.target && (/textarea|select/i.test(event.target.nodeName) ||\n          (jQuery.hotkeys.options.filterTextInputs &&\n            jQuery.inArray(event.target.type, jQuery.hotkeys.textAcceptingInputTypes) > -1))) {\n        return;\n      }\n\n      var special = event.type !== \"keypress\" && jQuery.hotkeys.specialKeys[event.which],\n        character = String.fromCharCode(event.which).toLowerCase(),\n        modif = \"\",\n        possible = {};\n\n      jQuery.each([\"alt\", \"ctrl\", \"shift\"], function(index, specialKey) {\n\n        if (event[specialKey + 'Key'] && special !== specialKey) {\n          modif += specialKey + '+';\n        }\n      });\n\n      // metaKey is triggered off ctrlKey erronously\n      if (event.metaKey && !event.ctrlKey && special !== \"meta\") {\n        modif += \"meta+\";\n      }\n\n      if (event.metaKey && special !== \"meta\" && modif.indexOf(\"alt+ctrl+shift+\") > -1) {\n        modif = modif.replace(\"alt+ctrl+shift+\", \"hyper+\");\n      }\n\n      if (special) {\n        possible[modif + special] = true;\n      }\n      else {\n        possible[modif + character] = true;\n        possible[modif + jQuery.hotkeys.shiftNums[character]] = true;\n\n        // \"$\" can be triggered as \"Shift+4\" or \"Shift+$\" or just \"$\"\n        if (modif === \"shift+\") {\n          possible[jQuery.hotkeys.shiftNums[character]] = true;\n        }\n      }\n\n      for (var i = 0, l = keys.length; i < l; i++) {\n        if (possible[keys[i]]) {\n          return origHandler.apply(this, arguments);\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"keydown\", \"keyup\", \"keypress\"], function() {\n    jQuery.event.special[this] = {\n      add: keyHandler\n    };\n  });\n\n})(jQuery || this.jQuery || window.jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS5ob3RrZXlzL2pxdWVyeS5ob3RrZXlzLmpzPzhlZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlKi9cbi8qanNsaW50IGpxdWVyeTogdHJ1ZSovXG5cbi8qXG4gKiBqUXVlcnkgSG90a2V5cyBQbHVnaW5cbiAqIENvcHlyaWdodCAyMDEwLCBKb2huIFJlc2lnXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqXG4gKiBCYXNlZCB1cG9uIHRoZSBwbHVnaW4gYnkgVHp1cnkgQmFyIFlvY2hheTpcbiAqIGh0dHA6Ly9naXRodWIuY29tL3R6dXJ5YnkvaG90a2V5c1xuICpcbiAqIE9yaWdpbmFsIGlkZWEgYnk6XG4gKiBCaW5ueSBWIEEsIGh0dHA6Ly93d3cub3BlbmpzLmNvbS9zY3JpcHRzL2V2ZW50cy9rZXlib2FyZF9zaG9ydGN1dHMvXG4gKi9cblxuLypcbiAqIE9uZSBzbWFsbCBjaGFuZ2UgaXM6IG5vdyBrZXlzIGFyZSBwYXNzZWQgYnkgb2JqZWN0IHsga2V5czogJy4uLicgfVxuICogTWlnaHQgYmUgdXNlZnVsLCB3aGVuIHlvdSB3YW50IHRvIHBhc3Mgc29tZSBvdGhlciBkYXRhIHRvIHlvdXIgaGFuZGxlclxuICovXG5cbihmdW5jdGlvbihqUXVlcnkpIHtcblxuICBqUXVlcnkuaG90a2V5cyA9IHtcbiAgICB2ZXJzaW9uOiBcIjAuOFwiLFxuXG4gICAgc3BlY2lhbEtleXM6IHtcbiAgICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgICA5OiBcInRhYlwiLFxuICAgICAgMTA6IFwicmV0dXJuXCIsXG4gICAgICAxMzogXCJyZXR1cm5cIixcbiAgICAgIDE2OiBcInNoaWZ0XCIsXG4gICAgICAxNzogXCJjdHJsXCIsXG4gICAgICAxODogXCJhbHRcIixcbiAgICAgIDE5OiBcInBhdXNlXCIsXG4gICAgICAyMDogXCJjYXBzbG9ja1wiLFxuICAgICAgMjc6IFwiZXNjXCIsXG4gICAgICAzMjogXCJzcGFjZVwiLFxuICAgICAgMzM6IFwicGFnZXVwXCIsXG4gICAgICAzNDogXCJwYWdlZG93blwiLFxuICAgICAgMzU6IFwiZW5kXCIsXG4gICAgICAzNjogXCJob21lXCIsXG4gICAgICAzNzogXCJsZWZ0XCIsXG4gICAgICAzODogXCJ1cFwiLFxuICAgICAgMzk6IFwicmlnaHRcIixcbiAgICAgIDQwOiBcImRvd25cIixcbiAgICAgIDQ1OiBcImluc2VydFwiLFxuICAgICAgNDY6IFwiZGVsXCIsXG4gICAgICA1OTogXCI7XCIsXG4gICAgICA2MTogXCI9XCIsXG4gICAgICA5NjogXCIwXCIsXG4gICAgICA5NzogXCIxXCIsXG4gICAgICA5ODogXCIyXCIsXG4gICAgICA5OTogXCIzXCIsXG4gICAgICAxMDA6IFwiNFwiLFxuICAgICAgMTAxOiBcIjVcIixcbiAgICAgIDEwMjogXCI2XCIsXG4gICAgICAxMDM6IFwiN1wiLFxuICAgICAgMTA0OiBcIjhcIixcbiAgICAgIDEwNTogXCI5XCIsXG4gICAgICAxMDY6IFwiKlwiLFxuICAgICAgMTA3OiBcIitcIixcbiAgICAgIDEwOTogXCItXCIsXG4gICAgICAxMTA6IFwiLlwiLFxuICAgICAgMTExOiBcIi9cIixcbiAgICAgIDExMjogXCJmMVwiLFxuICAgICAgMTEzOiBcImYyXCIsXG4gICAgICAxMTQ6IFwiZjNcIixcbiAgICAgIDExNTogXCJmNFwiLFxuICAgICAgMTE2OiBcImY1XCIsXG4gICAgICAxMTc6IFwiZjZcIixcbiAgICAgIDExODogXCJmN1wiLFxuICAgICAgMTE5OiBcImY4XCIsXG4gICAgICAxMjA6IFwiZjlcIixcbiAgICAgIDEyMTogXCJmMTBcIixcbiAgICAgIDEyMjogXCJmMTFcIixcbiAgICAgIDEyMzogXCJmMTJcIixcbiAgICAgIDE0NDogXCJudW1sb2NrXCIsXG4gICAgICAxNDU6IFwic2Nyb2xsXCIsXG4gICAgICAxNzM6IFwiLVwiLFxuICAgICAgMTg2OiBcIjtcIixcbiAgICAgIDE4NzogXCI9XCIsXG4gICAgICAxODg6IFwiLFwiLFxuICAgICAgMTg5OiBcIi1cIixcbiAgICAgIDE5MDogXCIuXCIsXG4gICAgICAxOTE6IFwiL1wiLFxuICAgICAgMTkyOiBcImBcIixcbiAgICAgIDIxOTogXCJbXCIsXG4gICAgICAyMjA6IFwiXFxcXFwiLFxuICAgICAgMjIxOiBcIl1cIixcbiAgICAgIDIyMjogXCInXCJcbiAgICB9LFxuXG4gICAgc2hpZnROdW1zOiB7XG4gICAgICBcImBcIjogXCJ+XCIsXG4gICAgICBcIjFcIjogXCIhXCIsXG4gICAgICBcIjJcIjogXCJAXCIsXG4gICAgICBcIjNcIjogXCIjXCIsXG4gICAgICBcIjRcIjogXCIkXCIsXG4gICAgICBcIjVcIjogXCIlXCIsXG4gICAgICBcIjZcIjogXCJeXCIsXG4gICAgICBcIjdcIjogXCImXCIsXG4gICAgICBcIjhcIjogXCIqXCIsXG4gICAgICBcIjlcIjogXCIoXCIsXG4gICAgICBcIjBcIjogXCIpXCIsXG4gICAgICBcIi1cIjogXCJfXCIsXG4gICAgICBcIj1cIjogXCIrXCIsXG4gICAgICBcIjtcIjogXCI6IFwiLFxuICAgICAgXCInXCI6IFwiXFxcIlwiLFxuICAgICAgXCIsXCI6IFwiPFwiLFxuICAgICAgXCIuXCI6IFwiPlwiLFxuICAgICAgXCIvXCI6IFwiP1wiLFxuICAgICAgXCJcXFxcXCI6IFwifFwiXG4gICAgfSxcblxuICAgIC8vIGV4Y2x1ZGVzOiBidXR0b24sIGNoZWNrYm94LCBmaWxlLCBoaWRkZW4sIGltYWdlLCBwYXNzd29yZCwgcmFkaW8sIHJlc2V0LCBzZWFyY2gsIHN1Ym1pdCwgdXJsXG4gICAgdGV4dEFjY2VwdGluZ0lucHV0VHlwZXM6IFtcbiAgICAgIFwidGV4dFwiLCBcInBhc3N3b3JkXCIsIFwibnVtYmVyXCIsIFwiZW1haWxcIiwgXCJ1cmxcIiwgXCJyYW5nZVwiLCBcImRhdGVcIiwgXCJtb250aFwiLCBcIndlZWtcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWVcIixcbiAgICAgIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJzZWFyY2hcIiwgXCJjb2xvclwiLCBcInRlbFwiXSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGZpbHRlclRleHRJbnB1dHM6IHRydWVcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24ga2V5SGFuZGxlcihoYW5kbGVPYmopIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZU9iai5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoYW5kbGVPYmouZGF0YSA9IHtcbiAgICAgICAga2V5czogaGFuZGxlT2JqLmRhdGFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gT25seSBjYXJlIHdoZW4gYSBwb3NzaWJsZSBpbnB1dCBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICBpZiAoIWhhbmRsZU9iai5kYXRhIHx8ICFoYW5kbGVPYmouZGF0YS5rZXlzIHx8IHR5cGVvZiBoYW5kbGVPYmouZGF0YS5rZXlzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdIYW5kbGVyID0gaGFuZGxlT2JqLmhhbmRsZXIsXG4gICAgICBrZXlzID0gaGFuZGxlT2JqLmRhdGEua2V5cy50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiKTtcblxuICAgIGhhbmRsZU9iai5oYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vICAgICAgRG9uJ3QgZmlyZSBpbiB0ZXh0LWFjY2VwdGluZyBpbnB1dHMgdGhhdCB3ZSBkaWRuJ3QgZGlyZWN0bHkgYmluZCB0b1xuICAgICAgaWYgKHRoaXMgIT09IGV2ZW50LnRhcmdldCAmJiAoL3RleHRhcmVhfHNlbGVjdC9pLnRlc3QoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKSB8fFxuICAgICAgICAgIChqUXVlcnkuaG90a2V5cy5vcHRpb25zLmZpbHRlclRleHRJbnB1dHMgJiZcbiAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KGV2ZW50LnRhcmdldC50eXBlLCBqUXVlcnkuaG90a2V5cy50ZXh0QWNjZXB0aW5nSW5wdXRUeXBlcykgPiAtMSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWNpYWwgPSBldmVudC50eXBlICE9PSBcImtleXByZXNzXCIgJiYgalF1ZXJ5LmhvdGtleXMuc3BlY2lhbEtleXNbZXZlbnQud2hpY2hdLFxuICAgICAgICBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBtb2RpZiA9IFwiXCIsXG4gICAgICAgIHBvc3NpYmxlID0ge307XG5cbiAgICAgIGpRdWVyeS5lYWNoKFtcImFsdFwiLCBcImN0cmxcIiwgXCJzaGlmdFwiXSwgZnVuY3Rpb24oaW5kZXgsIHNwZWNpYWxLZXkpIHtcblxuICAgICAgICBpZiAoZXZlbnRbc3BlY2lhbEtleSArICdLZXknXSAmJiBzcGVjaWFsICE9PSBzcGVjaWFsS2V5KSB7XG4gICAgICAgICAgbW9kaWYgKz0gc3BlY2lhbEtleSArICcrJztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG1ldGFLZXkgaXMgdHJpZ2dlcmVkIG9mZiBjdHJsS2V5IGVycm9ub3VzbHlcbiAgICAgIGlmIChldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5ICYmIHNwZWNpYWwgIT09IFwibWV0YVwiKSB7XG4gICAgICAgIG1vZGlmICs9IFwibWV0YStcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgJiYgc3BlY2lhbCAhPT0gXCJtZXRhXCIgJiYgbW9kaWYuaW5kZXhPZihcImFsdCtjdHJsK3NoaWZ0K1wiKSA+IC0xKSB7XG4gICAgICAgIG1vZGlmID0gbW9kaWYucmVwbGFjZShcImFsdCtjdHJsK3NoaWZ0K1wiLCBcImh5cGVyK1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpYWwpIHtcbiAgICAgICAgcG9zc2libGVbbW9kaWYgKyBzcGVjaWFsXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcG9zc2libGVbbW9kaWYgKyBjaGFyYWN0ZXJdID0gdHJ1ZTtcbiAgICAgICAgcG9zc2libGVbbW9kaWYgKyBqUXVlcnkuaG90a2V5cy5zaGlmdE51bXNbY2hhcmFjdGVyXV0gPSB0cnVlO1xuXG4gICAgICAgIC8vIFwiJFwiIGNhbiBiZSB0cmlnZ2VyZWQgYXMgXCJTaGlmdCs0XCIgb3IgXCJTaGlmdCskXCIgb3IganVzdCBcIiRcIlxuICAgICAgICBpZiAobW9kaWYgPT09IFwic2hpZnQrXCIpIHtcbiAgICAgICAgICBwb3NzaWJsZVtqUXVlcnkuaG90a2V5cy5zaGlmdE51bXNbY2hhcmFjdGVyXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlW2tleXNbaV1dKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgalF1ZXJ5LmVhY2goW1wia2V5ZG93blwiLCBcImtleXVwXCIsIFwia2V5cHJlc3NcIl0sIGZ1bmN0aW9uKCkge1xuICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW3RoaXNdID0ge1xuICAgICAgYWRkOiBrZXlIYW5kbGVyXG4gICAgfTtcbiAgfSk7XG5cbn0pKGpRdWVyeSB8fCB0aGlzLmpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2pxdWVyeS5ob3RrZXlzL2pxdWVyeS5ob3RrZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIiLCJmaWxlIjoiNi5qcyJ9");

/***/ },
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */
/*!************************************************!*\
  !*** ./~/backbone.stickit/backbone.stickit.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Backbone.Stickit v0.8.0, MIT Licensed\n// Copyright (c) 2012 The New York Times, CMS Group, Matthew DeLambo <delambo@gmail.com>\n\n(function (factory) {\n\n  // Set up Stickit appropriately for the environment. Start with AMD.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ 2), __webpack_require__(/*! backbone */ 1), exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Next for Node.js or CommonJS.\n  else if (typeof exports === 'object') {\n    factory(require('underscore'), require('backbone'), exports);\n  }\n\n  // Finally, as a browser global.\n  else {\n    factory(_, Backbone, {});\n  }\n\n}(function (_, Backbone, Stickit) {\n\n  // Stickit Namespace\n  // --------------------------\n\n  Stickit._handlers = [];\n\n  Stickit.addHandler = function(handlers) {\n    // Fill-in default values.\n    handlers = _.map(_.flatten([handlers]), function(handler) {\n      return _.extend({\n        updateModel: true,\n        updateView: true,\n        updateMethod: 'text'\n      }, handler);\n    });\n    this._handlers = this._handlers.concat(handlers);\n  };\n\n  // Backbone.View Mixins\n  // --------------------\n\n  Stickit.ViewMixin = {\n\n    // Collection of model event bindings.\n    //   [{model,event,fn,config}, ...]\n    _modelBindings: null,\n\n    // Unbind the model and event bindings from `this._modelBindings` and\n    // `this.$el`. If the optional `model` parameter is defined, then only\n    // delete bindings for the given `model` and its corresponding view events.\n    unstickit: function(model, bindingSelector) {\n      // Support bindings hash in place of selector.\n      if (_.isObject(bindingSelector)) {\n        _.each(_.keys(bindingSelector), function(selector) {\n          this.unstickit(model, selector);\n        }, this);\n        return;\n      }\n\n      var models = [], destroyFns = [];\n      _.each(this._modelBindings, function(binding, i) {\n        if (model && binding.model !== model) { return; }\n        if (bindingSelector && binding.config.selector != bindingSelector) return;\n        destroyFns.push(binding.config._destroy);\n        binding.model.off(binding.event, binding.fn);\n        models.push(binding.model);\n        delete this._modelBindings[i];\n      }, this);\n\n      // Trigger an event for each model that was unbound.\n      _.invoke(_.uniq(models), 'trigger', 'stickit:unstuck', this.cid);\n      // Call `_destroy` on a unique list of the binding callbacks.\n      _.each(_.uniq(destroyFns), function(fn) { fn.call(this); }, this);\n      // Cleanup the null values.\n      this._modelBindings = _.compact(this._modelBindings);\n\n      this.$el.off('.stickit' + (model ? '.' + model.cid : ''), bindingSelector);\n    },\n\n    // Using `this.bindings` configuration or the `optionalBindingsConfig`, binds `this.model`\n    // or the `optionalModel` to elements in the view.\n    stickit: function(optionalModel, optionalBindingsConfig) {\n      var model = optionalModel || this.model,\n          bindings = optionalBindingsConfig || _.result(this, \"bindings\") || {};\n\n      this._modelBindings || (this._modelBindings = []);\n\n      // Iterate through the selectors in the bindings configuration and configure\n      // the various options for each field.\n      this.addBinding(model, bindings);\n\n      // Wrap `view.remove` to unbind stickit model and dom events.\n      var remove = this.remove;\n      if (!remove.stickitWrapped) {\n        this.remove = function() {\n          var ret = this;\n          this.unstickit();\n          if (remove) ret = remove.apply(this, arguments);\n          return ret;\n        };\n      }\n      this.remove.stickitWrapped = true;\n    },\n\n    // Add a single model binding to the view\n    addBinding: function(optionalModel, second, _binding) {\n      var $el, options, modelAttr, config, selector,\n        model = optionalModel || this.model,\n        namespace = '.stickit.' + model.cid,\n        binding = _binding || {},\n        bindId = _.uniqueId();\n\n      // Allow jQuery-style {key: val} event maps\n      if (_.isString(second)) {\n        selector = second;\n      } else {\n        var bindings = second;\n        _.each(bindings, function(v, selector) {\n          this.addBinding(model, selector, bindings[selector]);\n        }, this);\n        return;\n      }\n\n      // Support ':el' selector - special case selector for the view managed delegate.\n      $el = selector === ':el' ? this.$el : this.$(selector);\n\n      this.unstickit(model, selector);\n\n      // Fail fast if the selector didn't match an element.\n      if (!$el.length) return;\n\n      // Allow shorthand setting of model attributes - `'selector':'observe'`.\n      if (_.isString(binding)) binding = {observe:binding};\n\n      // Handle case where `observe` is in the form of a function.\n      if (_.isFunction(binding.observe)) binding.observe = binding.observe.call(this);\n\n      config = getConfiguration($el, binding);\n      config.selector = selector;\n      modelAttr = config.observe;\n\n      // Create the model set options with a unique `bindId` so that we\n      // can avoid double-binding in the `change:attribute` event handler.\n      config.bindId = bindId;\n\n      // Add a reference to the view for handlers of stickitChange events\n      config.view = this;\n      options = _.extend({stickitChange:config}, config.setOptions);\n\n      // Add a `_destroy` callback to the configuration, in case `destroy`\n      // is a named function and we need a unique function when unsticking.\n      config._destroy = function() {\n        applyViewFn(this, config.destroy, $el, model, config);\n      };\n\n      initializeAttributes(this, $el, config, model, modelAttr);\n\n      initializeVisible(this, $el, config, model, modelAttr);\n\n      if (modelAttr) {\n        // Setup one-way, form element to model, bindings.\n        _.each(config.events, function(type) {\n          var event = type + namespace;\n          var method = function(event) {\n            var val = config.getVal.call(this, $el, event, config, _.rest(arguments));\n            // Don't update the model if false is returned from the `updateModel` configuration.\n            if (evaluateBoolean(this, config.updateModel, val, event, config))\n              setAttr(model, modelAttr, val, options, this, config);\n          };\n          method = _.bind(method, this);\n          if (selector === ':el') this.$el.on(event, method);\n          else this.$el.on(event, selector, method);\n        }, this);\n\n        // Setup a `change:modelAttr` observer to keep the view element in sync.\n        // `modelAttr` may be an array of attributes or a single string value.\n        _.each(_.flatten([modelAttr]), function(attr) {\n          observeModelEvent(model, this, 'change:'+attr, config, function(model, val, options) {\n            var changeId = options && options.stickitChange && options.stickitChange.bindId || null;\n            if (changeId !== bindId)\n              updateViewBindEl(this, $el, config, getAttr(model, modelAttr, config, this), model);\n          });\n        }, this);\n\n        updateViewBindEl(this, $el, config, getAttr(model, modelAttr, config, this), model, true);\n      }\n\n      // After each binding is setup, call the `initialize` callback.\n      applyViewFn(this, config.initialize, $el, model, config);\n    }\n  };\n\n  _.extend(Backbone.View.prototype, Stickit.ViewMixin);\n\n  // Helpers\n  // -------\n\n  // Evaluates the given `path` (in object/dot-notation) relative to the given\n  // `obj`. If the path is null/undefined, then the given `obj` is returned.\n  var evaluatePath = function(obj, path) {\n    var parts = (path || '').split('.');\n    var result = _.reduce(parts, function(memo, i) { return memo[i]; }, obj);\n    return result == null ? obj : result;\n  };\n\n  // If the given `fn` is a string, then view[fn] is called, otherwise it is\n  // a function that should be executed.\n  var applyViewFn = function(view, fn) {\n    if (fn) return (_.isString(fn) ? evaluatePath(view,fn) : fn).apply(view, _.rest(arguments, 2));\n  };\n\n  var getSelectedOption = function($select) { return $select.find('option').not(function(){ return !this.selected; }); };\n\n  // Given a function, string (view function reference), or a boolean\n  // value, returns the truthy result. Any other types evaluate as false.\n  var evaluateBoolean = function(view, reference) {\n    if (_.isBoolean(reference)) return reference;\n    else if (_.isFunction(reference) || _.isString(reference))\n      return applyViewFn.apply(this, arguments);\n    return false;\n  };\n\n  // Setup a model event binding with the given function, and track the event\n  // in the view's _modelBindings.\n  var observeModelEvent = function(model, view, event, config, fn) {\n    model.on(event, fn, view);\n    view._modelBindings.push({model:model, event:event, fn:fn, config:config});\n  };\n\n  // Prepares the given `val`ue and sets it into the `model`.\n  var setAttr = function(model, attr, val, options, context, config) {\n    var value = {};\n    if (config.onSet)\n      val = applyViewFn(context, config.onSet, val, config);\n\n    if (config.set)\n      applyViewFn(context, config.set, attr, val, options, config);\n    else {\n      value[attr] = val;\n      // If `observe` is defined as an array and `onSet` returned\n      // an array, then map attributes to their values.\n      if (_.isArray(attr) && _.isArray(val)) {\n        value = _.reduce(attr, function(memo, attribute, index) {\n          memo[attribute] = _.has(val, index) ? val[index] : null;\n          return memo;\n        }, {});\n      }\n      model.set(value, options);\n    }\n  };\n\n  // Returns the given `attr`'s value from the `model`, escaping and\n  // formatting if necessary. If `attr` is an array, then an array of\n  // respective values will be returned.\n  var getAttr = function(model, attr, config, context) {\n    var val,\n      retrieveVal = function(field) {\n        return model[config.escape ? 'escape' : 'get'](field);\n      },\n      sanitizeVal = function(val) {\n        return val == null ? '' : val;\n      };\n    val = _.isArray(attr) ? _.map(attr, retrieveVal) : retrieveVal(attr);\n    if (config.onGet) val = applyViewFn(context, config.onGet, val, config);\n    return _.isArray(val) ? _.map(val, sanitizeVal) : sanitizeVal(val);\n  };\n\n  // Find handlers in `Backbone.Stickit._handlers` with selectors that match\n  // `$el` and generate a configuration by mixing them in the order that they\n  // were found with the given `binding`.\n  var getConfiguration = Stickit.getConfiguration = function($el, binding) {\n    var handlers = [{\n      updateModel: false,\n      updateMethod: 'text',\n      update: function($el, val, m, opts) { if ($el[opts.updateMethod]) $el[opts.updateMethod](val); },\n      getVal: function($el, e, opts) { return $el[opts.updateMethod](); }\n    }];\n    handlers = handlers.concat(_.filter(Stickit._handlers, function(handler) {\n      return $el.is(handler.selector);\n    }));\n    handlers.push(binding);\n    var config = _.extend.apply(_, handlers);\n    // `updateView` is defaulted to false for configutrations with\n    // `visible`; otherwise, `updateView` is defaulted to true.\n    if (config.visible && !_.has(config, 'updateView')) config.updateView = false;\n    else if (!_.has(config, 'updateView')) config.updateView = true;\n    return config;\n  };\n\n  // Setup the attributes configuration - a list that maps an attribute or\n  // property `name`, to an `observe`d model attribute, using an optional\n  // `onGet` formatter.\n  //\n  //     attributes: [{\n  //       name: 'attributeOrPropertyName',\n  //       observe: 'modelAttrName'\n  //       onGet: function(modelAttrVal, modelAttrName) { ... }\n  //     }, ...]\n  //\n  var initializeAttributes = function(view, $el, config, model, modelAttr) {\n    var props = ['autofocus', 'autoplay', 'async', 'checked', 'controls', 'defer', 'disabled', 'hidden', 'indeterminate', 'loop', 'multiple', 'open', 'readonly', 'required', 'scoped', 'selected'];\n\n    _.each(config.attributes || [], function(attrConfig) {\n      var lastClass = '', observed, updateAttr;\n      attrConfig = _.clone(attrConfig);\n      observed = attrConfig.observe || (attrConfig.observe = modelAttr),\n      updateAttr = function() {\n        var updateType = _.indexOf(props, attrConfig.name, true) > -1 ? 'prop' : 'attr',\n          val = getAttr(model, observed, attrConfig, view);\n        // If it is a class then we need to remove the last value and add the new.\n        if (attrConfig.name === 'class') {\n          $el.removeClass(lastClass).addClass(val);\n          lastClass = val;\n        }\n        else $el[updateType](attrConfig.name, val);\n      };\n      _.each(_.flatten([observed]), function(attr) {\n        observeModelEvent(model, view, 'change:' + attr, config, updateAttr);\n      });\n      updateAttr();\n    });\n  };\n\n  // If `visible` is configured, then the view element will be shown/hidden\n  // based on the truthiness of the modelattr's value or the result of the\n  // given callback. If a `visibleFn` is also supplied, then that callback\n  // will be executed to manually handle showing/hiding the view element.\n  //\n  //     observe: 'isRight',\n  //     visible: true, // or function(val, options) {}\n  //     visibleFn: function($el, isVisible, options) {} // optional handler\n  //\n  var initializeVisible = function(view, $el, config, model, modelAttr) {\n    if (config.visible == null) return;\n    var visibleCb = function() {\n      var visible = config.visible,\n          visibleFn = config.visibleFn,\n          val = getAttr(model, modelAttr, config, view),\n          isVisible = !!val;\n      // If `visible` is a function then it should return a boolean result to show/hide.\n      if (_.isFunction(visible) || _.isString(visible)) isVisible = !!applyViewFn(view, visible, val, config);\n      // Either use the custom `visibleFn`, if provided, or execute the standard show/hide.\n      if (visibleFn) applyViewFn(view, visibleFn, $el, isVisible, config);\n      else {\n        $el.toggle(isVisible);\n      }\n    };\n    _.each(_.flatten([modelAttr]), function(attr) {\n      observeModelEvent(model, view, 'change:' + attr, config, visibleCb);\n    });\n    visibleCb();\n  };\n\n  // Update the value of `$el` using the given configuration and trigger the\n  // `afterUpdate` callback. This action may be blocked by `config.updateView`.\n  //\n  //     update: function($el, val, model, options) {},  // handler for updating\n  //     updateView: true, // defaults to true\n  //     afterUpdate: function($el, val, options) {} // optional callback\n  //\n  var updateViewBindEl = function(view, $el, config, val, model, isInitializing) {\n    if (!evaluateBoolean(view, config.updateView, val, config)) return;\n    applyViewFn(view, config.update, $el, val, model, config);\n    if (!isInitializing) applyViewFn(view, config.afterUpdate, $el, val, config);\n  };\n\n  // Default Handlers\n  // ----------------\n\n  Stickit.addHandler([{\n    selector: '[contenteditable=\"true\"]',\n    updateMethod: 'html',\n    events: ['input', 'change']\n  }, {\n    selector: 'input',\n    events: ['propertychange', 'input', 'change'],\n    update: function($el, val) { $el.val(val); },\n    getVal: function($el) {\n      return $el.val();\n    }\n  }, {\n    selector: 'textarea',\n    events: ['propertychange', 'input', 'change'],\n    update: function($el, val) { $el.val(val); },\n    getVal: function($el) { return $el.val(); }\n  }, {\n    selector: 'input[type=\"radio\"]',\n    events: ['change'],\n    update: function($el, val) {\n      $el.filter('[value=\"'+val+'\"]').prop('checked', true);\n    },\n    getVal: function($el) {\n      return $el.filter(':checked').val();\n    }\n  }, {\n    selector: 'input[type=\"checkbox\"]',\n    events: ['change'],\n    update: function($el, val, model, options) {\n      if ($el.length > 1) {\n        // There are multiple checkboxes so we need to go through them and check\n        // any that have value attributes that match what's in the array of `val`s.\n        val || (val = []);\n        $el.each(function(i, el) {\n          var checkbox = Backbone.$(el);\n          var checked = _.contains(val, checkbox.val());\n          checkbox.prop('checked', checked);\n        });\n      } else {\n        var checked = _.isBoolean(val) ? val : val === $el.val();\n        $el.prop('checked', checked);\n      }\n    },\n    getVal: function($el) {\n      var val;\n      if ($el.length > 1) {\n        val = _.reduce($el, function(memo, el) {\n          var checkbox = Backbone.$(el);\n          if (checkbox.prop('checked')) memo.push(checkbox.val());\n          return memo;\n        }, []);\n      } else {\n        val = $el.prop('checked');\n        // If the checkbox has a value attribute defined, then\n        // use that value. Most browsers use \"on\" as a default.\n        var boxval = $el.val();\n        if (boxval !== 'on' && boxval != null) {\n          val = val ? $el.val() : null;\n        }\n      }\n      return val;\n    }\n  }, {\n    selector: 'select',\n    events: ['change'],\n    update: function($el, val, model, options) {\n      var optList,\n        selectConfig = options.selectOptions,\n        list = selectConfig && selectConfig.collection || undefined,\n        isMultiple = $el.prop('multiple');\n\n      // If there are no `selectOptions` then we assume that the `<select>`\n      // is pre-rendered and that we need to generate the collection.\n      if (!selectConfig) {\n        selectConfig = {};\n        var getList = function($el) {\n          return $el.map(function() {\n            return {value:this.value, label:this.text};\n          }).get();\n        };\n        if ($el.find('optgroup').length) {\n          list = {opt_labels:[]};\n          // Search for options without optgroup\n          if ($el.find('> option').length) {\n            list.opt_labels.push(undefined);\n            _.each($el.find('> option'), function(el) {\n              list[undefined] = getList(Backbone.$(el));\n            });\n          }\n          _.each($el.find('optgroup'), function(el) {\n            var label = Backbone.$(el).attr('label');\n            list.opt_labels.push(label);\n            list[label] = getList(Backbone.$(el).find('option'));\n          });\n        } else {\n          list = getList($el.find('option'));\n        }\n      }\n\n      // Fill in default label and path values.\n      selectConfig.valuePath = selectConfig.valuePath || 'value';\n      selectConfig.labelPath = selectConfig.labelPath || 'label';\n\n      var addSelectOptions = function(optList, $el, fieldVal) {\n        _.each(optList, function(obj) {\n          var option = Backbone.$('<option/>'), optionVal = obj;\n\n          var fillOption = function(text, val) {\n            option.text(text);\n            optionVal = val;\n            // Save the option value as data so that we can reference it later.\n            option.data('stickit_bind_val', optionVal);\n            if (!_.isArray(optionVal) && !_.isObject(optionVal)) option.val(optionVal);\n          };\n\n          if (obj === '__default__')\n            fillOption(selectConfig.defaultOption.label, selectConfig.defaultOption.value);\n          else\n            fillOption(evaluatePath(obj, selectConfig.labelPath), evaluatePath(obj, selectConfig.valuePath));\n\n          // Determine if this option is selected.\n          if (!isMultiple && optionVal != null && fieldVal != null && optionVal === fieldVal || (_.isObject(fieldVal) && _.isEqual(optionVal, fieldVal)))\n            option.prop('selected', true);\n          else if (isMultiple && _.isArray(fieldVal)) {\n            _.each(fieldVal, function(val) {\n              if (_.isObject(val)) val = evaluatePath(val, selectConfig.valuePath);\n              if (val === optionVal || (_.isObject(val) && _.isEqual(optionVal, val)))\n                option.prop('selected', true);\n            });\n          }\n\n          $el.append(option);\n        });\n      };\n\n      $el.find('*').remove();\n\n      // The `list` configuration is a function that returns the options list or a string\n      // which represents the path to the list relative to `window` or the view/`this`.\n      var evaluate = function(view, list) {\n        var context = window;\n        if (list.indexOf('this.') === 0) context = view;\n        list = list.replace(/^[a-z]*\\.(.+)$/, '$1');\n        return evaluatePath(context, list);\n      };\n      if (_.isString(list)) optList = evaluate(this, list);\n      else if (_.isFunction(list)) optList = applyViewFn(this, list, $el, options);\n      else optList = list;\n\n      // Support Backbone.Collection and deserialize.\n      if (optList instanceof Backbone.Collection) optList = optList.toJSON();\n\n      if (selectConfig.defaultOption) {\n        addSelectOptions([\"__default__\"], $el);\n      }\n\n      if (_.isArray(optList)) {\n        addSelectOptions(optList, $el, val);\n      } else if (optList.opt_labels) {\n        // To define a select with optgroups, format selectOptions.collection as an object\n        // with an 'opt_labels' property, as in the following:\n        //\n        //     {\n        //       'opt_labels': ['Looney Tunes', 'Three Stooges'],\n        //       'Looney Tunes': [{id: 1, name: 'Bugs Bunny'}, {id: 2, name: 'Donald Duck'}],\n        //       'Three Stooges': [{id: 3, name : 'moe'}, {id: 4, name : 'larry'}, {id: 5, name : 'curly'}]\n        //     }\n        //\n        _.each(optList.opt_labels, function(label) {\n          var $group = Backbone.$('<optgroup/>').attr('label', label);\n          addSelectOptions(optList[label], $group, val);\n          $el.append($group);\n        });\n        // With no 'opt_labels' parameter, the object is assumed to be a simple value-label map.\n        // Pass a selectOptions.comparator to override the default order of alphabetical by label.\n      } else {\n        var opts = [], opt;\n        for (var i in optList) {\n          opt = {};\n          opt[selectConfig.valuePath] = i;\n          opt[selectConfig.labelPath] = optList[i];\n          opts.push(opt);\n        }\n        addSelectOptions(_.sortBy(opts, selectConfig.comparator || selectConfig.labelPath), $el, val);\n      }\n    },\n    getVal: function($el) {\n      var val;\n      if ($el.prop('multiple')) {\n        val = Backbone.$(getSelectedOption($el).map(function() {\n          return Backbone.$(this).data('stickit_bind_val');\n        })).get();\n      } else {\n        val = getSelectedOption($el).data('stickit_bind_val');\n      }\n      return val;\n    }\n  }]);\n\n\n  // Export onto Backbone object\n  Backbone.Stickit = Stickit;\n\n  return Backbone.Stickit;\n\n}));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLnN0aWNraXQvYmFja2JvbmUuc3RpY2tpdC5qcz80ZGM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsRUFBRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQixFQUFFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsOENBQThDLHVCQUF1QixFQUFFLEVBQUU7O0FBRXRIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5REFBeUQsRUFBRTtBQUN0RyxzQ0FBc0MsaUNBQWlDO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxjQUFjLEVBQUU7QUFDaEQsMkJBQTJCLGtCQUFrQjtBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsR0FBRywyQkFBMkI7QUFDM0Ysb0NBQW9DLG9CQUFvQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCYWNrYm9uZS5TdGlja2l0IHYwLjguMCwgTUlUIExpY2Vuc2VkXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTIgVGhlIE5ldyBZb3JrIFRpbWVzLCBDTVMgR3JvdXAsIE1hdHRoZXcgRGVMYW1ibyA8ZGVsYW1ib0BnbWFpbC5jb20+XG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXG4gIC8vIFNldCB1cCBTdGlja2l0IGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2JhY2tib25lJywgJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gIH1cblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLlxuICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSwgcmVxdWlyZSgnYmFja2JvbmUnKSwgZXhwb3J0cyk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICBlbHNlIHtcbiAgICBmYWN0b3J5KF8sIEJhY2tib25lLCB7fSk7XG4gIH1cblxufShmdW5jdGlvbiAoXywgQmFja2JvbmUsIFN0aWNraXQpIHtcblxuICAvLyBTdGlja2l0IE5hbWVzcGFjZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIFN0aWNraXQuX2hhbmRsZXJzID0gW107XG5cbiAgU3RpY2tpdC5hZGRIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcnMpIHtcbiAgICAvLyBGaWxsLWluIGRlZmF1bHQgdmFsdWVzLlxuICAgIGhhbmRsZXJzID0gXy5tYXAoXy5mbGF0dGVuKFtoYW5kbGVyc10pLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe1xuICAgICAgICB1cGRhdGVNb2RlbDogdHJ1ZSxcbiAgICAgICAgdXBkYXRlVmlldzogdHJ1ZSxcbiAgICAgICAgdXBkYXRlTWV0aG9kOiAndGV4dCdcbiAgICAgIH0sIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2hhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMuY29uY2F0KGhhbmRsZXJzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5WaWV3IE1peGluc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIFN0aWNraXQuVmlld01peGluID0ge1xuXG4gICAgLy8gQ29sbGVjdGlvbiBvZiBtb2RlbCBldmVudCBiaW5kaW5ncy5cbiAgICAvLyAgIFt7bW9kZWwsZXZlbnQsZm4sY29uZmlnfSwgLi4uXVxuICAgIF9tb2RlbEJpbmRpbmdzOiBudWxsLFxuXG4gICAgLy8gVW5iaW5kIHRoZSBtb2RlbCBhbmQgZXZlbnQgYmluZGluZ3MgZnJvbSBgdGhpcy5fbW9kZWxCaW5kaW5nc2AgYW5kXG4gICAgLy8gYHRoaXMuJGVsYC4gSWYgdGhlIG9wdGlvbmFsIGBtb2RlbGAgcGFyYW1ldGVyIGlzIGRlZmluZWQsIHRoZW4gb25seVxuICAgIC8vIGRlbGV0ZSBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIGBtb2RlbGAgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHZpZXcgZXZlbnRzLlxuICAgIHVuc3RpY2tpdDogZnVuY3Rpb24obW9kZWwsIGJpbmRpbmdTZWxlY3Rvcikge1xuICAgICAgLy8gU3VwcG9ydCBiaW5kaW5ncyBoYXNoIGluIHBsYWNlIG9mIHNlbGVjdG9yLlxuICAgICAgaWYgKF8uaXNPYmplY3QoYmluZGluZ1NlbGVjdG9yKSkge1xuICAgICAgICBfLmVhY2goXy5rZXlzKGJpbmRpbmdTZWxlY3RvciksIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdGhpcy51bnN0aWNraXQobW9kZWwsIHNlbGVjdG9yKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGVscyA9IFtdLCBkZXN0cm95Rm5zID0gW107XG4gICAgICBfLmVhY2godGhpcy5fbW9kZWxCaW5kaW5ncywgZnVuY3Rpb24oYmluZGluZywgaSkge1xuICAgICAgICBpZiAobW9kZWwgJiYgYmluZGluZy5tb2RlbCAhPT0gbW9kZWwpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChiaW5kaW5nU2VsZWN0b3IgJiYgYmluZGluZy5jb25maWcuc2VsZWN0b3IgIT0gYmluZGluZ1NlbGVjdG9yKSByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lGbnMucHVzaChiaW5kaW5nLmNvbmZpZy5fZGVzdHJveSk7XG4gICAgICAgIGJpbmRpbmcubW9kZWwub2ZmKGJpbmRpbmcuZXZlbnQsIGJpbmRpbmcuZm4pO1xuICAgICAgICBtb2RlbHMucHVzaChiaW5kaW5nLm1vZGVsKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsQmluZGluZ3NbaV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gVHJpZ2dlciBhbiBldmVudCBmb3IgZWFjaCBtb2RlbCB0aGF0IHdhcyB1bmJvdW5kLlxuICAgICAgXy5pbnZva2UoXy51bmlxKG1vZGVscyksICd0cmlnZ2VyJywgJ3N0aWNraXQ6dW5zdHVjaycsIHRoaXMuY2lkKTtcbiAgICAgIC8vIENhbGwgYF9kZXN0cm95YCBvbiBhIHVuaXF1ZSBsaXN0IG9mIHRoZSBiaW5kaW5nIGNhbGxiYWNrcy5cbiAgICAgIF8uZWFjaChfLnVuaXEoZGVzdHJveUZucyksIGZ1bmN0aW9uKGZuKSB7IGZuLmNhbGwodGhpcyk7IH0sIHRoaXMpO1xuICAgICAgLy8gQ2xlYW51cCB0aGUgbnVsbCB2YWx1ZXMuXG4gICAgICB0aGlzLl9tb2RlbEJpbmRpbmdzID0gXy5jb21wYWN0KHRoaXMuX21vZGVsQmluZGluZ3MpO1xuXG4gICAgICB0aGlzLiRlbC5vZmYoJy5zdGlja2l0JyArIChtb2RlbCA/ICcuJyArIG1vZGVsLmNpZCA6ICcnKSwgYmluZGluZ1NlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gVXNpbmcgYHRoaXMuYmluZGluZ3NgIGNvbmZpZ3VyYXRpb24gb3IgdGhlIGBvcHRpb25hbEJpbmRpbmdzQ29uZmlnYCwgYmluZHMgYHRoaXMubW9kZWxgXG4gICAgLy8gb3IgdGhlIGBvcHRpb25hbE1vZGVsYCB0byBlbGVtZW50cyBpbiB0aGUgdmlldy5cbiAgICBzdGlja2l0OiBmdW5jdGlvbihvcHRpb25hbE1vZGVsLCBvcHRpb25hbEJpbmRpbmdzQ29uZmlnKSB7XG4gICAgICB2YXIgbW9kZWwgPSBvcHRpb25hbE1vZGVsIHx8IHRoaXMubW9kZWwsXG4gICAgICAgICAgYmluZGluZ3MgPSBvcHRpb25hbEJpbmRpbmdzQ29uZmlnIHx8IF8ucmVzdWx0KHRoaXMsIFwiYmluZGluZ3NcIikgfHwge307XG5cbiAgICAgIHRoaXMuX21vZGVsQmluZGluZ3MgfHwgKHRoaXMuX21vZGVsQmluZGluZ3MgPSBbXSk7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc2VsZWN0b3JzIGluIHRoZSBiaW5kaW5ncyBjb25maWd1cmF0aW9uIGFuZCBjb25maWd1cmVcbiAgICAgIC8vIHRoZSB2YXJpb3VzIG9wdGlvbnMgZm9yIGVhY2ggZmllbGQuXG4gICAgICB0aGlzLmFkZEJpbmRpbmcobW9kZWwsIGJpbmRpbmdzKTtcblxuICAgICAgLy8gV3JhcCBgdmlldy5yZW1vdmVgIHRvIHVuYmluZCBzdGlja2l0IG1vZGVsIGFuZCBkb20gZXZlbnRzLlxuICAgICAgdmFyIHJlbW92ZSA9IHRoaXMucmVtb3ZlO1xuICAgICAgaWYgKCFyZW1vdmUuc3RpY2tpdFdyYXBwZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmV0ID0gdGhpcztcbiAgICAgICAgICB0aGlzLnVuc3RpY2tpdCgpO1xuICAgICAgICAgIGlmIChyZW1vdmUpIHJldCA9IHJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZS5zdGlja2l0V3JhcHBlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHNpbmdsZSBtb2RlbCBiaW5kaW5nIHRvIHRoZSB2aWV3XG4gICAgYWRkQmluZGluZzogZnVuY3Rpb24ob3B0aW9uYWxNb2RlbCwgc2Vjb25kLCBfYmluZGluZykge1xuICAgICAgdmFyICRlbCwgb3B0aW9ucywgbW9kZWxBdHRyLCBjb25maWcsIHNlbGVjdG9yLFxuICAgICAgICBtb2RlbCA9IG9wdGlvbmFsTW9kZWwgfHwgdGhpcy5tb2RlbCxcbiAgICAgICAgbmFtZXNwYWNlID0gJy5zdGlja2l0LicgKyBtb2RlbC5jaWQsXG4gICAgICAgIGJpbmRpbmcgPSBfYmluZGluZyB8fCB7fSxcbiAgICAgICAgYmluZElkID0gXy51bmlxdWVJZCgpO1xuXG4gICAgICAvLyBBbGxvdyBqUXVlcnktc3R5bGUge2tleTogdmFsfSBldmVudCBtYXBzXG4gICAgICBpZiAoXy5pc1N0cmluZyhzZWNvbmQpKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2Vjb25kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gc2Vjb25kO1xuICAgICAgICBfLmVhY2goYmluZGluZ3MsIGZ1bmN0aW9uKHYsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgdGhpcy5hZGRCaW5kaW5nKG1vZGVsLCBzZWxlY3RvciwgYmluZGluZ3Nbc2VsZWN0b3JdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydCAnOmVsJyBzZWxlY3RvciAtIHNwZWNpYWwgY2FzZSBzZWxlY3RvciBmb3IgdGhlIHZpZXcgbWFuYWdlZCBkZWxlZ2F0ZS5cbiAgICAgICRlbCA9IHNlbGVjdG9yID09PSAnOmVsJyA/IHRoaXMuJGVsIDogdGhpcy4kKHNlbGVjdG9yKTtcblxuICAgICAgdGhpcy51bnN0aWNraXQobW9kZWwsIHNlbGVjdG9yKTtcblxuICAgICAgLy8gRmFpbCBmYXN0IGlmIHRoZSBzZWxlY3RvciBkaWRuJ3QgbWF0Y2ggYW4gZWxlbWVudC5cbiAgICAgIGlmICghJGVsLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAvLyBBbGxvdyBzaG9ydGhhbmQgc2V0dGluZyBvZiBtb2RlbCBhdHRyaWJ1dGVzIC0gYCdzZWxlY3Rvcic6J29ic2VydmUnYC5cbiAgICAgIGlmIChfLmlzU3RyaW5nKGJpbmRpbmcpKSBiaW5kaW5nID0ge29ic2VydmU6YmluZGluZ307XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGBvYnNlcnZlYCBpcyBpbiB0aGUgZm9ybSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihiaW5kaW5nLm9ic2VydmUpKSBiaW5kaW5nLm9ic2VydmUgPSBiaW5kaW5nLm9ic2VydmUuY2FsbCh0aGlzKTtcblxuICAgICAgY29uZmlnID0gZ2V0Q29uZmlndXJhdGlvbigkZWwsIGJpbmRpbmcpO1xuICAgICAgY29uZmlnLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICBtb2RlbEF0dHIgPSBjb25maWcub2JzZXJ2ZTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBtb2RlbCBzZXQgb3B0aW9ucyB3aXRoIGEgdW5pcXVlIGBiaW5kSWRgIHNvIHRoYXQgd2VcbiAgICAgIC8vIGNhbiBhdm9pZCBkb3VibGUtYmluZGluZyBpbiB0aGUgYGNoYW5nZTphdHRyaWJ1dGVgIGV2ZW50IGhhbmRsZXIuXG4gICAgICBjb25maWcuYmluZElkID0gYmluZElkO1xuXG4gICAgICAvLyBBZGQgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgZm9yIGhhbmRsZXJzIG9mIHN0aWNraXRDaGFuZ2UgZXZlbnRzXG4gICAgICBjb25maWcudmlldyA9IHRoaXM7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3N0aWNraXRDaGFuZ2U6Y29uZmlnfSwgY29uZmlnLnNldE9wdGlvbnMpO1xuXG4gICAgICAvLyBBZGQgYSBgX2Rlc3Ryb3lgIGNhbGxiYWNrIHRvIHRoZSBjb25maWd1cmF0aW9uLCBpbiBjYXNlIGBkZXN0cm95YFxuICAgICAgLy8gaXMgYSBuYW1lZCBmdW5jdGlvbiBhbmQgd2UgbmVlZCBhIHVuaXF1ZSBmdW5jdGlvbiB3aGVuIHVuc3RpY2tpbmcuXG4gICAgICBjb25maWcuX2Rlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwbHlWaWV3Rm4odGhpcywgY29uZmlnLmRlc3Ryb3ksICRlbCwgbW9kZWwsIGNvbmZpZyk7XG4gICAgICB9O1xuXG4gICAgICBpbml0aWFsaXplQXR0cmlidXRlcyh0aGlzLCAkZWwsIGNvbmZpZywgbW9kZWwsIG1vZGVsQXR0cik7XG5cbiAgICAgIGluaXRpYWxpemVWaXNpYmxlKHRoaXMsICRlbCwgY29uZmlnLCBtb2RlbCwgbW9kZWxBdHRyKTtcblxuICAgICAgaWYgKG1vZGVsQXR0cikge1xuICAgICAgICAvLyBTZXR1cCBvbmUtd2F5LCBmb3JtIGVsZW1lbnQgdG8gbW9kZWwsIGJpbmRpbmdzLlxuICAgICAgICBfLmVhY2goY29uZmlnLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgIHZhciBldmVudCA9IHR5cGUgKyBuYW1lc3BhY2U7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gY29uZmlnLmdldFZhbC5jYWxsKHRoaXMsICRlbCwgZXZlbnQsIGNvbmZpZywgXy5yZXN0KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBtb2RlbCBpZiBmYWxzZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBgdXBkYXRlTW9kZWxgIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICBpZiAoZXZhbHVhdGVCb29sZWFuKHRoaXMsIGNvbmZpZy51cGRhdGVNb2RlbCwgdmFsLCBldmVudCwgY29uZmlnKSlcbiAgICAgICAgICAgICAgc2V0QXR0cihtb2RlbCwgbW9kZWxBdHRyLCB2YWwsIG9wdGlvbnMsIHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICc6ZWwnKSB0aGlzLiRlbC5vbihldmVudCwgbWV0aG9kKTtcbiAgICAgICAgICBlbHNlIHRoaXMuJGVsLm9uKGV2ZW50LCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gU2V0dXAgYSBgY2hhbmdlOm1vZGVsQXR0cmAgb2JzZXJ2ZXIgdG8ga2VlcCB0aGUgdmlldyBlbGVtZW50IGluIHN5bmMuXG4gICAgICAgIC8vIGBtb2RlbEF0dHJgIG1heSBiZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIG9yIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgXy5lYWNoKF8uZmxhdHRlbihbbW9kZWxBdHRyXSksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICBvYnNlcnZlTW9kZWxFdmVudChtb2RlbCwgdGhpcywgJ2NoYW5nZTonK2F0dHIsIGNvbmZpZywgZnVuY3Rpb24obW9kZWwsIHZhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZUlkID0gb3B0aW9ucyAmJiBvcHRpb25zLnN0aWNraXRDaGFuZ2UgJiYgb3B0aW9ucy5zdGlja2l0Q2hhbmdlLmJpbmRJZCB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKGNoYW5nZUlkICE9PSBiaW5kSWQpXG4gICAgICAgICAgICAgIHVwZGF0ZVZpZXdCaW5kRWwodGhpcywgJGVsLCBjb25maWcsIGdldEF0dHIobW9kZWwsIG1vZGVsQXR0ciwgY29uZmlnLCB0aGlzKSwgbW9kZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB1cGRhdGVWaWV3QmluZEVsKHRoaXMsICRlbCwgY29uZmlnLCBnZXRBdHRyKG1vZGVsLCBtb2RlbEF0dHIsIGNvbmZpZywgdGhpcyksIG1vZGVsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgZWFjaCBiaW5kaW5nIGlzIHNldHVwLCBjYWxsIHRoZSBgaW5pdGlhbGl6ZWAgY2FsbGJhY2suXG4gICAgICBhcHBseVZpZXdGbih0aGlzLCBjb25maWcuaW5pdGlhbGl6ZSwgJGVsLCBtb2RlbCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG5cbiAgXy5leHRlbmQoQmFja2JvbmUuVmlldy5wcm90b3R5cGUsIFN0aWNraXQuVmlld01peGluKTtcblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBwYXRoYCAoaW4gb2JqZWN0L2RvdC1ub3RhdGlvbikgcmVsYXRpdmUgdG8gdGhlIGdpdmVuXG4gIC8vIGBvYmpgLiBJZiB0aGUgcGF0aCBpcyBudWxsL3VuZGVmaW5lZCwgdGhlbiB0aGUgZ2l2ZW4gYG9iamAgaXMgcmV0dXJuZWQuXG4gIHZhciBldmFsdWF0ZVBhdGggPSBmdW5jdGlvbihvYmosIHBhdGgpIHtcbiAgICB2YXIgcGFydHMgPSAocGF0aCB8fCAnJykuc3BsaXQoJy4nKTtcbiAgICB2YXIgcmVzdWx0ID0gXy5yZWR1Y2UocGFydHMsIGZ1bmN0aW9uKG1lbW8sIGkpIHsgcmV0dXJuIG1lbW9baV07IH0sIG9iaik7XG4gICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gb2JqIDogcmVzdWx0O1xuICB9O1xuXG4gIC8vIElmIHRoZSBnaXZlbiBgZm5gIGlzIGEgc3RyaW5nLCB0aGVuIHZpZXdbZm5dIGlzIGNhbGxlZCwgb3RoZXJ3aXNlIGl0IGlzXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQuXG4gIHZhciBhcHBseVZpZXdGbiA9IGZ1bmN0aW9uKHZpZXcsIGZuKSB7XG4gICAgaWYgKGZuKSByZXR1cm4gKF8uaXNTdHJpbmcoZm4pID8gZXZhbHVhdGVQYXRoKHZpZXcsZm4pIDogZm4pLmFwcGx5KHZpZXcsIF8ucmVzdChhcmd1bWVudHMsIDIpKTtcbiAgfTtcblxuICB2YXIgZ2V0U2VsZWN0ZWRPcHRpb24gPSBmdW5jdGlvbigkc2VsZWN0KSB7IHJldHVybiAkc2VsZWN0LmZpbmQoJ29wdGlvbicpLm5vdChmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuc2VsZWN0ZWQ7IH0pOyB9O1xuXG4gIC8vIEdpdmVuIGEgZnVuY3Rpb24sIHN0cmluZyAodmlldyBmdW5jdGlvbiByZWZlcmVuY2UpLCBvciBhIGJvb2xlYW5cbiAgLy8gdmFsdWUsIHJldHVybnMgdGhlIHRydXRoeSByZXN1bHQuIEFueSBvdGhlciB0eXBlcyBldmFsdWF0ZSBhcyBmYWxzZS5cbiAgdmFyIGV2YWx1YXRlQm9vbGVhbiA9IGZ1bmN0aW9uKHZpZXcsIHJlZmVyZW5jZSkge1xuICAgIGlmIChfLmlzQm9vbGVhbihyZWZlcmVuY2UpKSByZXR1cm4gcmVmZXJlbmNlO1xuICAgIGVsc2UgaWYgKF8uaXNGdW5jdGlvbihyZWZlcmVuY2UpIHx8IF8uaXNTdHJpbmcocmVmZXJlbmNlKSlcbiAgICAgIHJldHVybiBhcHBseVZpZXdGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBTZXR1cCBhIG1vZGVsIGV2ZW50IGJpbmRpbmcgd2l0aCB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGFuZCB0cmFjayB0aGUgZXZlbnRcbiAgLy8gaW4gdGhlIHZpZXcncyBfbW9kZWxCaW5kaW5ncy5cbiAgdmFyIG9ic2VydmVNb2RlbEV2ZW50ID0gZnVuY3Rpb24obW9kZWwsIHZpZXcsIGV2ZW50LCBjb25maWcsIGZuKSB7XG4gICAgbW9kZWwub24oZXZlbnQsIGZuLCB2aWV3KTtcbiAgICB2aWV3Ll9tb2RlbEJpbmRpbmdzLnB1c2goe21vZGVsOm1vZGVsLCBldmVudDpldmVudCwgZm46Zm4sIGNvbmZpZzpjb25maWd9KTtcbiAgfTtcblxuICAvLyBQcmVwYXJlcyB0aGUgZ2l2ZW4gYHZhbGB1ZSBhbmQgc2V0cyBpdCBpbnRvIHRoZSBgbW9kZWxgLlxuICB2YXIgc2V0QXR0ciA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRyLCB2YWwsIG9wdGlvbnMsIGNvbnRleHQsIGNvbmZpZykge1xuICAgIHZhciB2YWx1ZSA9IHt9O1xuICAgIGlmIChjb25maWcub25TZXQpXG4gICAgICB2YWwgPSBhcHBseVZpZXdGbihjb250ZXh0LCBjb25maWcub25TZXQsIHZhbCwgY29uZmlnKTtcblxuICAgIGlmIChjb25maWcuc2V0KVxuICAgICAgYXBwbHlWaWV3Rm4oY29udGV4dCwgY29uZmlnLnNldCwgYXR0ciwgdmFsLCBvcHRpb25zLCBjb25maWcpO1xuICAgIGVsc2Uge1xuICAgICAgdmFsdWVbYXR0cl0gPSB2YWw7XG4gICAgICAvLyBJZiBgb2JzZXJ2ZWAgaXMgZGVmaW5lZCBhcyBhbiBhcnJheSBhbmQgYG9uU2V0YCByZXR1cm5lZFxuICAgICAgLy8gYW4gYXJyYXksIHRoZW4gbWFwIGF0dHJpYnV0ZXMgdG8gdGhlaXIgdmFsdWVzLlxuICAgICAgaWYgKF8uaXNBcnJheShhdHRyKSAmJiBfLmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWx1ZSA9IF8ucmVkdWNlKGF0dHIsIGZ1bmN0aW9uKG1lbW8sIGF0dHJpYnV0ZSwgaW5kZXgpIHtcbiAgICAgICAgICBtZW1vW2F0dHJpYnV0ZV0gPSBfLmhhcyh2YWwsIGluZGV4KSA/IHZhbFtpbmRleF0gOiBudWxsO1xuICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgICBtb2RlbC5zZXQodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBnaXZlbiBgYXR0cmAncyB2YWx1ZSBmcm9tIHRoZSBgbW9kZWxgLCBlc2NhcGluZyBhbmRcbiAgLy8gZm9ybWF0dGluZyBpZiBuZWNlc3NhcnkuIElmIGBhdHRyYCBpcyBhbiBhcnJheSwgdGhlbiBhbiBhcnJheSBvZlxuICAvLyByZXNwZWN0aXZlIHZhbHVlcyB3aWxsIGJlIHJldHVybmVkLlxuICB2YXIgZ2V0QXR0ciA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRyLCBjb25maWcsIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsLFxuICAgICAgcmV0cmlldmVWYWwgPSBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICByZXR1cm4gbW9kZWxbY29uZmlnLmVzY2FwZSA/ICdlc2NhcGUnIDogJ2dldCddKGZpZWxkKTtcbiAgICAgIH0sXG4gICAgICBzYW5pdGl6ZVZhbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID09IG51bGwgPyAnJyA6IHZhbDtcbiAgICAgIH07XG4gICAgdmFsID0gXy5pc0FycmF5KGF0dHIpID8gXy5tYXAoYXR0ciwgcmV0cmlldmVWYWwpIDogcmV0cmlldmVWYWwoYXR0cik7XG4gICAgaWYgKGNvbmZpZy5vbkdldCkgdmFsID0gYXBwbHlWaWV3Rm4oY29udGV4dCwgY29uZmlnLm9uR2V0LCB2YWwsIGNvbmZpZyk7XG4gICAgcmV0dXJuIF8uaXNBcnJheSh2YWwpID8gXy5tYXAodmFsLCBzYW5pdGl6ZVZhbCkgOiBzYW5pdGl6ZVZhbCh2YWwpO1xuICB9O1xuXG4gIC8vIEZpbmQgaGFuZGxlcnMgaW4gYEJhY2tib25lLlN0aWNraXQuX2hhbmRsZXJzYCB3aXRoIHNlbGVjdG9ycyB0aGF0IG1hdGNoXG4gIC8vIGAkZWxgIGFuZCBnZW5lcmF0ZSBhIGNvbmZpZ3VyYXRpb24gYnkgbWl4aW5nIHRoZW0gaW4gdGhlIG9yZGVyIHRoYXQgdGhleVxuICAvLyB3ZXJlIGZvdW5kIHdpdGggdGhlIGdpdmVuIGBiaW5kaW5nYC5cbiAgdmFyIGdldENvbmZpZ3VyYXRpb24gPSBTdGlja2l0LmdldENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbigkZWwsIGJpbmRpbmcpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbe1xuICAgICAgdXBkYXRlTW9kZWw6IGZhbHNlLFxuICAgICAgdXBkYXRlTWV0aG9kOiAndGV4dCcsXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uKCRlbCwgdmFsLCBtLCBvcHRzKSB7IGlmICgkZWxbb3B0cy51cGRhdGVNZXRob2RdKSAkZWxbb3B0cy51cGRhdGVNZXRob2RdKHZhbCk7IH0sXG4gICAgICBnZXRWYWw6IGZ1bmN0aW9uKCRlbCwgZSwgb3B0cykgeyByZXR1cm4gJGVsW29wdHMudXBkYXRlTWV0aG9kXSgpOyB9XG4gICAgfV07XG4gICAgaGFuZGxlcnMgPSBoYW5kbGVycy5jb25jYXQoXy5maWx0ZXIoU3RpY2tpdC5faGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiAkZWwuaXMoaGFuZGxlci5zZWxlY3Rvcik7XG4gICAgfSkpO1xuICAgIGhhbmRsZXJzLnB1c2goYmluZGluZyk7XG4gICAgdmFyIGNvbmZpZyA9IF8uZXh0ZW5kLmFwcGx5KF8sIGhhbmRsZXJzKTtcbiAgICAvLyBgdXBkYXRlVmlld2AgaXMgZGVmYXVsdGVkIHRvIGZhbHNlIGZvciBjb25maWd1dHJhdGlvbnMgd2l0aFxuICAgIC8vIGB2aXNpYmxlYDsgb3RoZXJ3aXNlLCBgdXBkYXRlVmlld2AgaXMgZGVmYXVsdGVkIHRvIHRydWUuXG4gICAgaWYgKGNvbmZpZy52aXNpYmxlICYmICFfLmhhcyhjb25maWcsICd1cGRhdGVWaWV3JykpIGNvbmZpZy51cGRhdGVWaWV3ID0gZmFsc2U7XG4gICAgZWxzZSBpZiAoIV8uaGFzKGNvbmZpZywgJ3VwZGF0ZVZpZXcnKSkgY29uZmlnLnVwZGF0ZVZpZXcgPSB0cnVlO1xuICAgIHJldHVybiBjb25maWc7XG4gIH07XG5cbiAgLy8gU2V0dXAgdGhlIGF0dHJpYnV0ZXMgY29uZmlndXJhdGlvbiAtIGEgbGlzdCB0aGF0IG1hcHMgYW4gYXR0cmlidXRlIG9yXG4gIC8vIHByb3BlcnR5IGBuYW1lYCwgdG8gYW4gYG9ic2VydmVgZCBtb2RlbCBhdHRyaWJ1dGUsIHVzaW5nIGFuIG9wdGlvbmFsXG4gIC8vIGBvbkdldGAgZm9ybWF0dGVyLlxuICAvL1xuICAvLyAgICAgYXR0cmlidXRlczogW3tcbiAgLy8gICAgICAgbmFtZTogJ2F0dHJpYnV0ZU9yUHJvcGVydHlOYW1lJyxcbiAgLy8gICAgICAgb2JzZXJ2ZTogJ21vZGVsQXR0ck5hbWUnXG4gIC8vICAgICAgIG9uR2V0OiBmdW5jdGlvbihtb2RlbEF0dHJWYWwsIG1vZGVsQXR0ck5hbWUpIHsgLi4uIH1cbiAgLy8gICAgIH0sIC4uLl1cbiAgLy9cbiAgdmFyIGluaXRpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24odmlldywgJGVsLCBjb25maWcsIG1vZGVsLCBtb2RlbEF0dHIpIHtcbiAgICB2YXIgcHJvcHMgPSBbJ2F1dG9mb2N1cycsICdhdXRvcGxheScsICdhc3luYycsICdjaGVja2VkJywgJ2NvbnRyb2xzJywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2hpZGRlbicsICdpbmRldGVybWluYXRlJywgJ2xvb3AnLCAnbXVsdGlwbGUnLCAnb3BlbicsICdyZWFkb25seScsICdyZXF1aXJlZCcsICdzY29wZWQnLCAnc2VsZWN0ZWQnXTtcblxuICAgIF8uZWFjaChjb25maWcuYXR0cmlidXRlcyB8fCBbXSwgZnVuY3Rpb24oYXR0ckNvbmZpZykge1xuICAgICAgdmFyIGxhc3RDbGFzcyA9ICcnLCBvYnNlcnZlZCwgdXBkYXRlQXR0cjtcbiAgICAgIGF0dHJDb25maWcgPSBfLmNsb25lKGF0dHJDb25maWcpO1xuICAgICAgb2JzZXJ2ZWQgPSBhdHRyQ29uZmlnLm9ic2VydmUgfHwgKGF0dHJDb25maWcub2JzZXJ2ZSA9IG1vZGVsQXR0ciksXG4gICAgICB1cGRhdGVBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGRhdGVUeXBlID0gXy5pbmRleE9mKHByb3BzLCBhdHRyQ29uZmlnLm5hbWUsIHRydWUpID4gLTEgPyAncHJvcCcgOiAnYXR0cicsXG4gICAgICAgICAgdmFsID0gZ2V0QXR0cihtb2RlbCwgb2JzZXJ2ZWQsIGF0dHJDb25maWcsIHZpZXcpO1xuICAgICAgICAvLyBJZiBpdCBpcyBhIGNsYXNzIHRoZW4gd2UgbmVlZCB0byByZW1vdmUgdGhlIGxhc3QgdmFsdWUgYW5kIGFkZCB0aGUgbmV3LlxuICAgICAgICBpZiAoYXR0ckNvbmZpZy5uYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGxhc3RDbGFzcykuYWRkQ2xhc3ModmFsKTtcbiAgICAgICAgICBsYXN0Q2xhc3MgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAkZWxbdXBkYXRlVHlwZV0oYXR0ckNvbmZpZy5uYW1lLCB2YWwpO1xuICAgICAgfTtcbiAgICAgIF8uZWFjaChfLmZsYXR0ZW4oW29ic2VydmVkXSksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgb2JzZXJ2ZU1vZGVsRXZlbnQobW9kZWwsIHZpZXcsICdjaGFuZ2U6JyArIGF0dHIsIGNvbmZpZywgdXBkYXRlQXR0cik7XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZUF0dHIoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBJZiBgdmlzaWJsZWAgaXMgY29uZmlndXJlZCwgdGhlbiB0aGUgdmlldyBlbGVtZW50IHdpbGwgYmUgc2hvd24vaGlkZGVuXG4gIC8vIGJhc2VkIG9uIHRoZSB0cnV0aGluZXNzIG9mIHRoZSBtb2RlbGF0dHIncyB2YWx1ZSBvciB0aGUgcmVzdWx0IG9mIHRoZVxuICAvLyBnaXZlbiBjYWxsYmFjay4gSWYgYSBgdmlzaWJsZUZuYCBpcyBhbHNvIHN1cHBsaWVkLCB0aGVuIHRoYXQgY2FsbGJhY2tcbiAgLy8gd2lsbCBiZSBleGVjdXRlZCB0byBtYW51YWxseSBoYW5kbGUgc2hvd2luZy9oaWRpbmcgdGhlIHZpZXcgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAgIG9ic2VydmU6ICdpc1JpZ2h0JyxcbiAgLy8gICAgIHZpc2libGU6IHRydWUsIC8vIG9yIGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge31cbiAgLy8gICAgIHZpc2libGVGbjogZnVuY3Rpb24oJGVsLCBpc1Zpc2libGUsIG9wdGlvbnMpIHt9IC8vIG9wdGlvbmFsIGhhbmRsZXJcbiAgLy9cbiAgdmFyIGluaXRpYWxpemVWaXNpYmxlID0gZnVuY3Rpb24odmlldywgJGVsLCBjb25maWcsIG1vZGVsLCBtb2RlbEF0dHIpIHtcbiAgICBpZiAoY29uZmlnLnZpc2libGUgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciB2aXNpYmxlQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aXNpYmxlID0gY29uZmlnLnZpc2libGUsXG4gICAgICAgICAgdmlzaWJsZUZuID0gY29uZmlnLnZpc2libGVGbixcbiAgICAgICAgICB2YWwgPSBnZXRBdHRyKG1vZGVsLCBtb2RlbEF0dHIsIGNvbmZpZywgdmlldyksXG4gICAgICAgICAgaXNWaXNpYmxlID0gISF2YWw7XG4gICAgICAvLyBJZiBgdmlzaWJsZWAgaXMgYSBmdW5jdGlvbiB0aGVuIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHJlc3VsdCB0byBzaG93L2hpZGUuXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpc2libGUpIHx8IF8uaXNTdHJpbmcodmlzaWJsZSkpIGlzVmlzaWJsZSA9ICEhYXBwbHlWaWV3Rm4odmlldywgdmlzaWJsZSwgdmFsLCBjb25maWcpO1xuICAgICAgLy8gRWl0aGVyIHVzZSB0aGUgY3VzdG9tIGB2aXNpYmxlRm5gLCBpZiBwcm92aWRlZCwgb3IgZXhlY3V0ZSB0aGUgc3RhbmRhcmQgc2hvdy9oaWRlLlxuICAgICAgaWYgKHZpc2libGVGbikgYXBwbHlWaWV3Rm4odmlldywgdmlzaWJsZUZuLCAkZWwsIGlzVmlzaWJsZSwgY29uZmlnKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAkZWwudG9nZ2xlKGlzVmlzaWJsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfLmVhY2goXy5mbGF0dGVuKFttb2RlbEF0dHJdKSwgZnVuY3Rpb24oYXR0cikge1xuICAgICAgb2JzZXJ2ZU1vZGVsRXZlbnQobW9kZWwsIHZpZXcsICdjaGFuZ2U6JyArIGF0dHIsIGNvbmZpZywgdmlzaWJsZUNiKTtcbiAgICB9KTtcbiAgICB2aXNpYmxlQ2IoKTtcbiAgfTtcblxuICAvLyBVcGRhdGUgdGhlIHZhbHVlIG9mIGAkZWxgIHVzaW5nIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIGFuZCB0cmlnZ2VyIHRoZVxuICAvLyBgYWZ0ZXJVcGRhdGVgIGNhbGxiYWNrLiBUaGlzIGFjdGlvbiBtYXkgYmUgYmxvY2tlZCBieSBgY29uZmlnLnVwZGF0ZVZpZXdgLlxuICAvL1xuICAvLyAgICAgdXBkYXRlOiBmdW5jdGlvbigkZWwsIHZhbCwgbW9kZWwsIG9wdGlvbnMpIHt9LCAgLy8gaGFuZGxlciBmb3IgdXBkYXRpbmdcbiAgLy8gICAgIHVwZGF0ZVZpZXc6IHRydWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgLy8gICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbigkZWwsIHZhbCwgb3B0aW9ucykge30gLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAgLy9cbiAgdmFyIHVwZGF0ZVZpZXdCaW5kRWwgPSBmdW5jdGlvbih2aWV3LCAkZWwsIGNvbmZpZywgdmFsLCBtb2RlbCwgaXNJbml0aWFsaXppbmcpIHtcbiAgICBpZiAoIWV2YWx1YXRlQm9vbGVhbih2aWV3LCBjb25maWcudXBkYXRlVmlldywgdmFsLCBjb25maWcpKSByZXR1cm47XG4gICAgYXBwbHlWaWV3Rm4odmlldywgY29uZmlnLnVwZGF0ZSwgJGVsLCB2YWwsIG1vZGVsLCBjb25maWcpO1xuICAgIGlmICghaXNJbml0aWFsaXppbmcpIGFwcGx5Vmlld0ZuKHZpZXcsIGNvbmZpZy5hZnRlclVwZGF0ZSwgJGVsLCB2YWwsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBIYW5kbGVyc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgU3RpY2tpdC5hZGRIYW5kbGVyKFt7XG4gICAgc2VsZWN0b3I6ICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXScsXG4gICAgdXBkYXRlTWV0aG9kOiAnaHRtbCcsXG4gICAgZXZlbnRzOiBbJ2lucHV0JywgJ2NoYW5nZSddXG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJ2lucHV0JyxcbiAgICBldmVudHM6IFsncHJvcGVydHljaGFuZ2UnLCAnaW5wdXQnLCAnY2hhbmdlJ10sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigkZWwsIHZhbCkgeyAkZWwudmFsKHZhbCk7IH0sXG4gICAgZ2V0VmFsOiBmdW5jdGlvbigkZWwpIHtcbiAgICAgIHJldHVybiAkZWwudmFsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICd0ZXh0YXJlYScsXG4gICAgZXZlbnRzOiBbJ3Byb3BlcnR5Y2hhbmdlJywgJ2lucHV0JywgJ2NoYW5nZSddLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oJGVsLCB2YWwpIHsgJGVsLnZhbCh2YWwpOyB9LFxuICAgIGdldFZhbDogZnVuY3Rpb24oJGVsKSB7IHJldHVybiAkZWwudmFsKCk7IH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1cInJhZGlvXCJdJyxcbiAgICBldmVudHM6IFsnY2hhbmdlJ10sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigkZWwsIHZhbCkge1xuICAgICAgJGVsLmZpbHRlcignW3ZhbHVlPVwiJyt2YWwrJ1wiXScpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldFZhbDogZnVuY3Rpb24oJGVsKSB7XG4gICAgICByZXR1cm4gJGVsLmZpbHRlcignOmNoZWNrZWQnKS52YWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsXG4gICAgZXZlbnRzOiBbJ2NoYW5nZSddLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oJGVsLCB2YWwsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG11bHRpcGxlIGNoZWNrYm94ZXMgc28gd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZW0gYW5kIGNoZWNrXG4gICAgICAgIC8vIGFueSB0aGF0IGhhdmUgdmFsdWUgYXR0cmlidXRlcyB0aGF0IG1hdGNoIHdoYXQncyBpbiB0aGUgYXJyYXkgb2YgYHZhbGBzLlxuICAgICAgICB2YWwgfHwgKHZhbCA9IFtdKTtcbiAgICAgICAgJGVsLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICB2YXIgY2hlY2tib3ggPSBCYWNrYm9uZS4kKGVsKTtcbiAgICAgICAgICB2YXIgY2hlY2tlZCA9IF8uY29udGFpbnModmFsLCBjaGVja2JveC52YWwoKSk7XG4gICAgICAgICAgY2hlY2tib3gucHJvcCgnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja2VkID0gXy5pc0Jvb2xlYW4odmFsKSA/IHZhbCA6IHZhbCA9PT0gJGVsLnZhbCgpO1xuICAgICAgICAkZWwucHJvcCgnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VmFsOiBmdW5jdGlvbigkZWwpIHtcbiAgICAgIHZhciB2YWw7XG4gICAgICBpZiAoJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gXy5yZWR1Y2UoJGVsLCBmdW5jdGlvbihtZW1vLCBlbCkge1xuICAgICAgICAgIHZhciBjaGVja2JveCA9IEJhY2tib25lLiQoZWwpO1xuICAgICAgICAgIGlmIChjaGVja2JveC5wcm9wKCdjaGVja2VkJykpIG1lbW8ucHVzaChjaGVja2JveC52YWwoKSk7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9ICRlbC5wcm9wKCdjaGVja2VkJyk7XG4gICAgICAgIC8vIElmIHRoZSBjaGVja2JveCBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgZGVmaW5lZCwgdGhlblxuICAgICAgICAvLyB1c2UgdGhhdCB2YWx1ZS4gTW9zdCBicm93c2VycyB1c2UgXCJvblwiIGFzIGEgZGVmYXVsdC5cbiAgICAgICAgdmFyIGJveHZhbCA9ICRlbC52YWwoKTtcbiAgICAgICAgaWYgKGJveHZhbCAhPT0gJ29uJyAmJiBib3h2YWwgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbCA9IHZhbCA/ICRlbC52YWwoKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICdzZWxlY3QnLFxuICAgIGV2ZW50czogWydjaGFuZ2UnXSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCRlbCwgdmFsLCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIG9wdExpc3QsXG4gICAgICAgIHNlbGVjdENvbmZpZyA9IG9wdGlvbnMuc2VsZWN0T3B0aW9ucyxcbiAgICAgICAgbGlzdCA9IHNlbGVjdENvbmZpZyAmJiBzZWxlY3RDb25maWcuY29sbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICAgIGlzTXVsdGlwbGUgPSAkZWwucHJvcCgnbXVsdGlwbGUnKTtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGBzZWxlY3RPcHRpb25zYCB0aGVuIHdlIGFzc3VtZSB0aGF0IHRoZSBgPHNlbGVjdD5gXG4gICAgICAvLyBpcyBwcmUtcmVuZGVyZWQgYW5kIHRoYXQgd2UgbmVlZCB0byBnZW5lcmF0ZSB0aGUgY29sbGVjdGlvbi5cbiAgICAgIGlmICghc2VsZWN0Q29uZmlnKSB7XG4gICAgICAgIHNlbGVjdENvbmZpZyA9IHt9O1xuICAgICAgICB2YXIgZ2V0TGlzdCA9IGZ1bmN0aW9uKCRlbCkge1xuICAgICAgICAgIHJldHVybiAkZWwubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTp0aGlzLnZhbHVlLCBsYWJlbDp0aGlzLnRleHR9O1xuICAgICAgICAgIH0pLmdldCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoJGVsLmZpbmQoJ29wdGdyb3VwJykubGVuZ3RoKSB7XG4gICAgICAgICAgbGlzdCA9IHtvcHRfbGFiZWxzOltdfTtcbiAgICAgICAgICAvLyBTZWFyY2ggZm9yIG9wdGlvbnMgd2l0aG91dCBvcHRncm91cFxuICAgICAgICAgIGlmICgkZWwuZmluZCgnPiBvcHRpb24nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpc3Qub3B0X2xhYmVscy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBfLmVhY2goJGVsLmZpbmQoJz4gb3B0aW9uJyksIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgIGxpc3RbdW5kZWZpbmVkXSA9IGdldExpc3QoQmFja2JvbmUuJChlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF8uZWFjaCgkZWwuZmluZCgnb3B0Z3JvdXAnKSwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IEJhY2tib25lLiQoZWwpLmF0dHIoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsaXN0Lm9wdF9sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICBsaXN0W2xhYmVsXSA9IGdldExpc3QoQmFja2JvbmUuJChlbCkuZmluZCgnb3B0aW9uJykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3QgPSBnZXRMaXN0KCRlbC5maW5kKCdvcHRpb24nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlsbCBpbiBkZWZhdWx0IGxhYmVsIGFuZCBwYXRoIHZhbHVlcy5cbiAgICAgIHNlbGVjdENvbmZpZy52YWx1ZVBhdGggPSBzZWxlY3RDb25maWcudmFsdWVQYXRoIHx8ICd2YWx1ZSc7XG4gICAgICBzZWxlY3RDb25maWcubGFiZWxQYXRoID0gc2VsZWN0Q29uZmlnLmxhYmVsUGF0aCB8fCAnbGFiZWwnO1xuXG4gICAgICB2YXIgYWRkU2VsZWN0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdExpc3QsICRlbCwgZmllbGRWYWwpIHtcbiAgICAgICAgXy5lYWNoKG9wdExpc3QsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHZhciBvcHRpb24gPSBCYWNrYm9uZS4kKCc8b3B0aW9uLz4nKSwgb3B0aW9uVmFsID0gb2JqO1xuXG4gICAgICAgICAgdmFyIGZpbGxPcHRpb24gPSBmdW5jdGlvbih0ZXh0LCB2YWwpIHtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0KHRleHQpO1xuICAgICAgICAgICAgb3B0aW9uVmFsID0gdmFsO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3B0aW9uIHZhbHVlIGFzIGRhdGEgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIGl0IGxhdGVyLlxuICAgICAgICAgICAgb3B0aW9uLmRhdGEoJ3N0aWNraXRfYmluZF92YWwnLCBvcHRpb25WYWwpO1xuICAgICAgICAgICAgaWYgKCFfLmlzQXJyYXkob3B0aW9uVmFsKSAmJiAhXy5pc09iamVjdChvcHRpb25WYWwpKSBvcHRpb24udmFsKG9wdGlvblZhbCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChvYmogPT09ICdfX2RlZmF1bHRfXycpXG4gICAgICAgICAgICBmaWxsT3B0aW9uKHNlbGVjdENvbmZpZy5kZWZhdWx0T3B0aW9uLmxhYmVsLCBzZWxlY3RDb25maWcuZGVmYXVsdE9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmlsbE9wdGlvbihldmFsdWF0ZVBhdGgob2JqLCBzZWxlY3RDb25maWcubGFiZWxQYXRoKSwgZXZhbHVhdGVQYXRoKG9iaiwgc2VsZWN0Q29uZmlnLnZhbHVlUGF0aCkpO1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIGlmICghaXNNdWx0aXBsZSAmJiBvcHRpb25WYWwgIT0gbnVsbCAmJiBmaWVsZFZhbCAhPSBudWxsICYmIG9wdGlvblZhbCA9PT0gZmllbGRWYWwgfHwgKF8uaXNPYmplY3QoZmllbGRWYWwpICYmIF8uaXNFcXVhbChvcHRpb25WYWwsIGZpZWxkVmFsKSkpXG4gICAgICAgICAgICBvcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICBlbHNlIGlmIChpc011bHRpcGxlICYmIF8uaXNBcnJheShmaWVsZFZhbCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChmaWVsZFZhbCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbCkpIHZhbCA9IGV2YWx1YXRlUGF0aCh2YWwsIHNlbGVjdENvbmZpZy52YWx1ZVBhdGgpO1xuICAgICAgICAgICAgICBpZiAodmFsID09PSBvcHRpb25WYWwgfHwgKF8uaXNPYmplY3QodmFsKSAmJiBfLmlzRXF1YWwob3B0aW9uVmFsLCB2YWwpKSlcbiAgICAgICAgICAgICAgICBvcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5hcHBlbmQob3B0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAkZWwuZmluZCgnKicpLnJlbW92ZSgpO1xuXG4gICAgICAvLyBUaGUgYGxpc3RgIGNvbmZpZ3VyYXRpb24gaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9wdGlvbnMgbGlzdCBvciBhIHN0cmluZ1xuICAgICAgLy8gd2hpY2ggcmVwcmVzZW50cyB0aGUgcGF0aCB0byB0aGUgbGlzdCByZWxhdGl2ZSB0byBgd2luZG93YCBvciB0aGUgdmlldy9gdGhpc2AuXG4gICAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbih2aWV3LCBsaXN0KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gd2luZG93O1xuICAgICAgICBpZiAobGlzdC5pbmRleE9mKCd0aGlzLicpID09PSAwKSBjb250ZXh0ID0gdmlldztcbiAgICAgICAgbGlzdCA9IGxpc3QucmVwbGFjZSgvXlthLXpdKlxcLiguKykkLywgJyQxJyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZVBhdGgoY29udGV4dCwgbGlzdCk7XG4gICAgICB9O1xuICAgICAgaWYgKF8uaXNTdHJpbmcobGlzdCkpIG9wdExpc3QgPSBldmFsdWF0ZSh0aGlzLCBsaXN0KTtcbiAgICAgIGVsc2UgaWYgKF8uaXNGdW5jdGlvbihsaXN0KSkgb3B0TGlzdCA9IGFwcGx5Vmlld0ZuKHRoaXMsIGxpc3QsICRlbCwgb3B0aW9ucyk7XG4gICAgICBlbHNlIG9wdExpc3QgPSBsaXN0O1xuXG4gICAgICAvLyBTdXBwb3J0IEJhY2tib25lLkNvbGxlY3Rpb24gYW5kIGRlc2VyaWFsaXplLlxuICAgICAgaWYgKG9wdExpc3QgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSBvcHRMaXN0ID0gb3B0TGlzdC50b0pTT04oKTtcblxuICAgICAgaWYgKHNlbGVjdENvbmZpZy5kZWZhdWx0T3B0aW9uKSB7XG4gICAgICAgIGFkZFNlbGVjdE9wdGlvbnMoW1wiX19kZWZhdWx0X19cIl0sICRlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzQXJyYXkob3B0TGlzdCkpIHtcbiAgICAgICAgYWRkU2VsZWN0T3B0aW9ucyhvcHRMaXN0LCAkZWwsIHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdExpc3Qub3B0X2xhYmVscykge1xuICAgICAgICAvLyBUbyBkZWZpbmUgYSBzZWxlY3Qgd2l0aCBvcHRncm91cHMsIGZvcm1hdCBzZWxlY3RPcHRpb25zLmNvbGxlY3Rpb24gYXMgYW4gb2JqZWN0XG4gICAgICAgIC8vIHdpdGggYW4gJ29wdF9sYWJlbHMnIHByb3BlcnR5LCBhcyBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAnb3B0X2xhYmVscyc6IFsnTG9vbmV5IFR1bmVzJywgJ1RocmVlIFN0b29nZXMnXSxcbiAgICAgICAgLy8gICAgICAgJ0xvb25leSBUdW5lcyc6IFt7aWQ6IDEsIG5hbWU6ICdCdWdzIEJ1bm55J30sIHtpZDogMiwgbmFtZTogJ0RvbmFsZCBEdWNrJ31dLFxuICAgICAgICAvLyAgICAgICAnVGhyZWUgU3Rvb2dlcyc6IFt7aWQ6IDMsIG5hbWUgOiAnbW9lJ30sIHtpZDogNCwgbmFtZSA6ICdsYXJyeSd9LCB7aWQ6IDUsIG5hbWUgOiAnY3VybHknfV1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgXy5lYWNoKG9wdExpc3Qub3B0X2xhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICB2YXIgJGdyb3VwID0gQmFja2JvbmUuJCgnPG9wdGdyb3VwLz4nKS5hdHRyKCdsYWJlbCcsIGxhYmVsKTtcbiAgICAgICAgICBhZGRTZWxlY3RPcHRpb25zKG9wdExpc3RbbGFiZWxdLCAkZ3JvdXAsIHZhbCk7XG4gICAgICAgICAgJGVsLmFwcGVuZCgkZ3JvdXApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2l0aCBubyAnb3B0X2xhYmVscycgcGFyYW1ldGVyLCB0aGUgb2JqZWN0IGlzIGFzc3VtZWQgdG8gYmUgYSBzaW1wbGUgdmFsdWUtbGFiZWwgbWFwLlxuICAgICAgICAvLyBQYXNzIGEgc2VsZWN0T3B0aW9ucy5jb21wYXJhdG9yIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9yZGVyIG9mIGFscGhhYmV0aWNhbCBieSBsYWJlbC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRzID0gW10sIG9wdDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRMaXN0KSB7XG4gICAgICAgICAgb3B0ID0ge307XG4gICAgICAgICAgb3B0W3NlbGVjdENvbmZpZy52YWx1ZVBhdGhdID0gaTtcbiAgICAgICAgICBvcHRbc2VsZWN0Q29uZmlnLmxhYmVsUGF0aF0gPSBvcHRMaXN0W2ldO1xuICAgICAgICAgIG9wdHMucHVzaChvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFNlbGVjdE9wdGlvbnMoXy5zb3J0Qnkob3B0cywgc2VsZWN0Q29uZmlnLmNvbXBhcmF0b3IgfHwgc2VsZWN0Q29uZmlnLmxhYmVsUGF0aCksICRlbCwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFZhbDogZnVuY3Rpb24oJGVsKSB7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYgKCRlbC5wcm9wKCdtdWx0aXBsZScpKSB7XG4gICAgICAgIHZhbCA9IEJhY2tib25lLiQoZ2V0U2VsZWN0ZWRPcHRpb24oJGVsKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEJhY2tib25lLiQodGhpcykuZGF0YSgnc3RpY2tpdF9iaW5kX3ZhbCcpO1xuICAgICAgICB9KSkuZ2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBnZXRTZWxlY3RlZE9wdGlvbigkZWwpLmRhdGEoJ3N0aWNraXRfYmluZF92YWwnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XSk7XG5cblxuICAvLyBFeHBvcnQgb250byBCYWNrYm9uZSBvYmplY3RcbiAgQmFja2JvbmUuU3RpY2tpdCA9IFN0aWNraXQ7XG5cbiAgcmV0dXJuIEJhY2tib25lLlN0aWNraXQ7XG5cbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhY2tib25lLnN0aWNraXQvYmFja2JvbmUuc3RpY2tpdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIxNi5qcyJ9");

/***/ },
/* 17 */
/*!***********************************!*\
  !*** ./~/idb-wrapper/idbstore.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Copyright (c) 2011 - 2013 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {\n    },\n    onError: defaultErrorHandler,\n    indexes: []\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.4.1\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n      // create a store for customers with an additional index over the\n      // `lastname` property.\n      var myCustomerStore = new IDBStore({\n        dbVersion: 1,\n        storeName: 'customer-index',\n        keyPath: 'customerid',\n        autoIncrement: true,\n        onStoreReady: populateTable,\n        indexes: [\n          { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n        ]\n      });\n   * @example\n      // create a generic store\n      var myCustomerStore = new IDBStore({\n        storeName: 'my-data-store',\n        onStoreReady: function(){\n          // start working with the store.\n        }\n      });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n    onStoreReady && (this.onStoreReady = onStoreReady);\n\n    var env = typeof window == 'object' ? window : self;\n    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n    this.features = {\n      hasAutoIncrement: !env.mozIndexedDB\n    };\n\n    this.consts = {\n      'READ_ONLY':         'readonly',\n      'READ_WRITE':        'readwrite',\n      'VERSION_CHANGE':    'versionchange',\n      'NEXT':              'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV':              'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n\n    this.openDB();\n  };\n\n  IDBStore.prototype = /** @lends IDBStore */ {\n\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @type IDBStore\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type String\n     */\n    version: '1.4.1',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type Object\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type String\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type Number\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type Object\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type String\n     */\n    storeName: null,\n\n    /**\n     * The key path\n     *\n     * @type String\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type Boolean\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type Array\n     */\n    indexes: null,\n\n    /**\n     * A hashmap of features of the used IDB implementation\n     *\n     * @type Object\n     * @proprty {Boolean} autoIncrement If the implementation supports\n     *  native auto increment\n     */\n    features: null,\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type Function\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type Function\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type Number\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (error) {\n\n        var gotVersionErr = false;\n        if ('error' in error.target) {\n          gotVersionErr = error.target.error.name == 'VersionError';\n        } else if ('errorCode' in error.target) {\n          gotVersionErr = error.target.errorCode == 12;\n        }\n\n        if (gotVersionErr) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if(this.db){\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if(typeof this.db.version == 'string'){\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if(!this.db.objectStoreNames.contains(this.storeName)){\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){\n\n        this.db = event.target.result;\n\n        if(this.db.objectStoreNames.contains(this.storeName)){\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = { autoIncrement: this.autoIncrement };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function(_indexName){\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     */\n    deleteDatabase: function () {\n      if (this.idb.deleteDatabase) {\n        this.idb.deleteDatabase(this.dbName);\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n        // Storing an object, using inline keys (the default scenario):\n        var myCustomer = {\n          customerid: 2346223,\n          lastname: 'Doe',\n          firstname: 'John'\n        };\n        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n        // Note that passing success- and error-handlers is optional.\n     * @example\n        // Storing an object, using out-of-line keys:\n       var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n       };\n       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n      // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) { // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else { // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n      \n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      if(Object.prototype.toString.call(dataArray) != '[object Array]'){\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      \n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n          if (this.keyPath !== null) { // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else { // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function(item){\n        return { type: 'put', value: item };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function(key){\n        return { type: 'remove', key: key };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) {  }, arrayType);\n\n     // this is what the `data` array will be like:\n\n     // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n\n     // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n\n     // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      arrayType || (arrayType = 'sparse');\n\n      if(Object.prototype.toString.call(keyArray) != '[object Array]'){\n        onError(new Error('keyArray argument must be of type Array.'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        }\n        else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {Object} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if ( ! (typeof act.contains == 'function' || typeof act.indexOf == 'function') ) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i<m; i++) {\n            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler\n      }, options || {});\n\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          onItem(cursor.value, cursor, cursorTransaction);\n          if (options.autoContinue) {\n            cursor['continue']();\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific query options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [];\n      options = options || {};\n      options.onEnd = function () {\n        onSuccess(result);\n      };\n      return this.iterate(function (item) {\n        result.push(item);\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n\n      var onError = options.onError || defaultErrorHandler;\n\n      var hasSuccess = false,\n          result = null;\n\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n\n      return cursorTransaction;\n    },\n\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options){\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch(true){\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n\n    }\n\n  };\n\n  /** helpers **/\n\n  var noop = function () {\n  };\n  var empty = {};\n  var mixin = function (target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  };\n\n  IDBStore.version = IDBStore.prototype.version;\n\n  return IDBStore;\n\n}, this);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lkYi13cmFwcGVyL2lkYnN0b3JlLmpzP2VmNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw2REFBNkQ7QUFDakk7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsa0VBQWtFLDZEQUE2RDtBQUMvSDs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELElBQUk7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxlQUFlOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZUFBZTs7QUFFdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHdpbmRvdzpmYWxzZSwgc2VsZjpmYWxzZSwgZGVmaW5lOmZhbHNlLCBtb2R1bGU6ZmFsc2UgKi9cblxuLyoqXG4gKiBAbGljZW5zZSBJREJXcmFwcGVyIC0gQSBjcm9zcy1icm93c2VyIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxMyBKZW5zIEFycHNcbiAqIGh0dHA6Ly9qZW5zYXJwcy5kZS9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIChYMTEpIGxpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGdsb2JhbCkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFtuYW1lXSA9IGRlZmluaXRpb24oKTtcbiAgfVxufSkoJ0lEQlN0b3JlJywgZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBzdG9yZU5hbWU6ICdTdG9yZScsXG4gICAgc3RvcmVQcmVmaXg6ICdJREJXcmFwcGVyLScsXG4gICAgZGJWZXJzaW9uOiAxLFxuICAgIGtleVBhdGg6ICdpZCcsXG4gICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICBvblN0b3JlUmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuICAgIG9uRXJyb3I6IGRlZmF1bHRFcnJvckhhbmRsZXIsXG4gICAgaW5kZXhlczogW11cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogVGhlIElEQlN0b3JlIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbmFtZSBJREJTdG9yZVxuICAgKiBAdmVyc2lvbiAxLjQuMVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2t3QXJnc10gQW4gb3B0aW9ucyBvYmplY3QgdXNlZCB0byBjb25maWd1cmUgdGhlIHN0b3JlIGFuZFxuICAgKiAgc2V0IGNhbGxiYWNrc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2t3QXJncy5zdG9yZU5hbWU9J1N0b3JlJ10gVGhlIG5hbWUgb2YgdGhlIHN0b3JlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba3dBcmdzLnN0b3JlUHJlZml4PSdJREJXcmFwcGVyLSddIEEgcHJlZml4IHRoYXQgaXNcbiAgICogIGludGVybmFsbHkgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlLCB3aGljaCB3aWxsIGJlXG4gICAqICBrd0FyZ3Muc3RvcmVQcmVmaXggKyBrd0FyZ3Muc3RvcmVOYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBba3dBcmdzLmRiVmVyc2lvbj0xXSBUaGUgdmVyc2lvbiBvZiB0aGUgc3RvcmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrd0FyZ3Mua2V5UGF0aD0naWQnXSBUaGUga2V5IHBhdGggdG8gdXNlLiBJZiB5b3Ugd2FudCB0b1xuICAgKiAgc2V0dXAgSURCV3JhcHBlciB0byB3b3JrIHdpdGggb3V0LW9mLWxpbmUga2V5cywgeW91IG5lZWQgdG8gc2V0IHRoaXMgdG9cbiAgICogIGBudWxsYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrd0FyZ3MuYXV0b0luY3JlbWVudD10cnVlXSBJZiBzZXQgdG8gdHJ1ZSwgSURCU3RvcmUgd2lsbFxuICAgKiAgYXV0b21hdGljYWxseSBtYWtlIHN1cmUgYSB1bmlxdWUga2V5UGF0aCB2YWx1ZSBpcyBwcmVzZW50IG9uIGVhY2ggb2JqZWN0XG4gICAqICB0aGF0IGlzIHN0b3JlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2t3QXJncy5vblN0b3JlUmVhZHldIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlXG4gICAqICBzdG9yZSBpcyByZWFkeSB0byBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBba3dBcmdzLm9uRXJyb3I9dGhyb3ddIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gYW5cbiAgICogIGVycm9yIG9jY3VycmVkIGR1cmluZyBpbnN0YW50aWF0aW9uIG9mIHRoZSBzdG9yZS5cbiAgICogQHBhcmFtIHtBcnJheX0gW2t3QXJncy5pbmRleGVzPVtdXSBBbiBhcnJheSBvZiBpbmRleERhdGEgb2JqZWN0c1xuICAgKiAgZGVmaW5pbmcgdGhlIGluZGV4ZXMgdG8gdXNlIHdpdGggdGhlIHN0b3JlLiBGb3IgZXZlcnkgaW5kZXggdG8gYmUgdXNlZFxuICAgKiAgb25lIGluZGV4RGF0YSBvYmplY3QgbmVlZHMgdG8gYmUgcGFzc2VkIGluIHRoZSBhcnJheS5cbiAgICogIEFuIGluZGV4RGF0YSBvYmplY3QgaXMgZGVmaW5lZCBhcyBmb2xsb3dzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2t3QXJncy5pbmRleGVzLmluZGV4RGF0YV0gQW4gb2JqZWN0IGRlZmluaW5nIHRoZSBpbmRleCB0b1xuICAgKiAgdXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrd0FyZ3MuaW5kZXhlcy5pbmRleERhdGEubmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrd0FyZ3MuaW5kZXhlcy5pbmRleERhdGEua2V5UGF0aF0gVGhlIGtleSBwYXRoIG9mIHRoZSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrd0FyZ3MuaW5kZXhlcy5pbmRleERhdGEudW5pcXVlXSBXaGV0aGVyIHRoZSBpbmRleCBpcyB1bmlxdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBba3dBcmdzLmluZGV4ZXMuaW5kZXhEYXRhLm11bHRpRW50cnldIFdoZXRoZXIgdGhlIGluZGV4IGlzIG11bHRpIGVudHJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN0b3JlUmVhZHldIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0b3JlXG4gICAqIGlzIHJlYWR5IHRvIGJlIHVzZWQuXG4gICAqIEBleGFtcGxlXG4gICAgICAvLyBjcmVhdGUgYSBzdG9yZSBmb3IgY3VzdG9tZXJzIHdpdGggYW4gYWRkaXRpb25hbCBpbmRleCBvdmVyIHRoZVxuICAgICAgLy8gYGxhc3RuYW1lYCBwcm9wZXJ0eS5cbiAgICAgIHZhciBteUN1c3RvbWVyU3RvcmUgPSBuZXcgSURCU3RvcmUoe1xuICAgICAgICBkYlZlcnNpb246IDEsXG4gICAgICAgIHN0b3JlTmFtZTogJ2N1c3RvbWVyLWluZGV4JyxcbiAgICAgICAga2V5UGF0aDogJ2N1c3RvbWVyaWQnLFxuICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlLFxuICAgICAgICBvblN0b3JlUmVhZHk6IHBvcHVsYXRlVGFibGUsXG4gICAgICAgIGluZGV4ZXM6IFtcbiAgICAgICAgICB7IG5hbWU6ICdsYXN0bmFtZScsIGtleVBhdGg6ICdsYXN0bmFtZScsIHVuaXF1ZTogZmFsc2UsIG11bHRpRW50cnk6IGZhbHNlIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAqIEBleGFtcGxlXG4gICAgICAvLyBjcmVhdGUgYSBnZW5lcmljIHN0b3JlXG4gICAgICB2YXIgbXlDdXN0b21lclN0b3JlID0gbmV3IElEQlN0b3JlKHtcbiAgICAgICAgc3RvcmVOYW1lOiAnbXktZGF0YS1zdG9yZScsXG4gICAgICAgIG9uU3RvcmVSZWFkeTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyBzdGFydCB3b3JraW5nIHdpdGggdGhlIHN0b3JlLlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICovXG4gIHZhciBJREJTdG9yZSA9IGZ1bmN0aW9uIChrd0FyZ3MsIG9uU3RvcmVSZWFkeSkge1xuXG4gICAgaWYgKHR5cGVvZiBvblN0b3JlUmVhZHkgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGt3QXJncyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvblN0b3JlUmVhZHkgPSBrd0FyZ3M7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoa3dBcmdzKSAhPSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAga3dBcmdzID0ge307XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICB0aGlzW2tleV0gPSB0eXBlb2Yga3dBcmdzW2tleV0gIT0gJ3VuZGVmaW5lZCcgPyBrd0FyZ3Nba2V5XSA6IGRlZmF1bHRzW2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5kYk5hbWUgPSB0aGlzLnN0b3JlUHJlZml4ICsgdGhpcy5zdG9yZU5hbWU7XG4gICAgdGhpcy5kYlZlcnNpb24gPSBwYXJzZUludCh0aGlzLmRiVmVyc2lvbiwgMTApIHx8IDE7XG5cbiAgICBvblN0b3JlUmVhZHkgJiYgKHRoaXMub25TdG9yZVJlYWR5ID0gb25TdG9yZVJlYWR5KTtcblxuICAgIHZhciBlbnYgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnID8gd2luZG93IDogc2VsZjtcbiAgICB0aGlzLmlkYiA9IGVudi5pbmRleGVkREIgfHwgZW52LndlYmtpdEluZGV4ZWREQiB8fCBlbnYubW96SW5kZXhlZERCO1xuICAgIHRoaXMua2V5UmFuZ2UgPSBlbnYuSURCS2V5UmFuZ2UgfHwgZW52LndlYmtpdElEQktleVJhbmdlIHx8IGVudi5tb3pJREJLZXlSYW5nZTtcblxuICAgIHRoaXMuZmVhdHVyZXMgPSB7XG4gICAgICBoYXNBdXRvSW5jcmVtZW50OiAhZW52Lm1vekluZGV4ZWREQlxuICAgIH07XG5cbiAgICB0aGlzLmNvbnN0cyA9IHtcbiAgICAgICdSRUFEX09OTFknOiAgICAgICAgICdyZWFkb25seScsXG4gICAgICAnUkVBRF9XUklURSc6ICAgICAgICAncmVhZHdyaXRlJyxcbiAgICAgICdWRVJTSU9OX0NIQU5HRSc6ICAgICd2ZXJzaW9uY2hhbmdlJyxcbiAgICAgICdORVhUJzogICAgICAgICAgICAgICduZXh0JyxcbiAgICAgICdORVhUX05PX0RVUExJQ0FURSc6ICduZXh0dW5pcXVlJyxcbiAgICAgICdQUkVWJzogICAgICAgICAgICAgICdwcmV2JyxcbiAgICAgICdQUkVWX05PX0RVUExJQ0FURSc6ICdwcmV2dW5pcXVlJ1xuICAgIH07XG5cbiAgICB0aGlzLm9wZW5EQigpO1xuICB9O1xuXG4gIElEQlN0b3JlLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgSURCU3RvcmUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQSBwb2ludGVyIHRvIHRoZSBJREJTdG9yZSBjdG9yXG4gICAgICpcbiAgICAgKiBAdHlwZSBJREJTdG9yZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBJREJTdG9yZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIElEQlN0b3JlXG4gICAgICpcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uOiAnMS40LjEnLFxuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIEluZGV4ZWREQiBvYmplY3RcbiAgICAgKlxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGRiOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgbmFtZSBvZiB0aGUgSW5kZXhlZERCIHVzZWQgYnkgSURCU3RvcmUsIGNvbXBvc2VkIG9mXG4gICAgICogdGhpcy5zdG9yZVByZWZpeCArIHRoaXMuc3RvcmVOYW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBkYk5hbWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgSW5kZXhlZERCIHVzZWQgYnkgSURCU3RvcmVcbiAgICAgKlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGRiVmVyc2lvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3RTdG9yZSB1c2VkIGJ5IElEQlN0b3JlXG4gICAgICpcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBzdG9yZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdG9yZSBuYW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBzdG9yZU5hbWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHBhdGhcbiAgICAgKlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGtleVBhdGg6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIElEQlN0b3JlIHVzZXMgYXV0b0luY3JlbWVudFxuICAgICAqXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGF1dG9JbmNyZW1lbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXhlcyB1c2VkIGJ5IElEQlN0b3JlXG4gICAgICpcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGluZGV4ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBIGhhc2htYXAgb2YgZmVhdHVyZXMgb2YgdGhlIHVzZWQgSURCIGltcGxlbWVudGF0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJvcHJ0eSB7Qm9vbGVhbn0gYXV0b0luY3JlbWVudCBJZiB0aGUgaW1wbGVtZW50YXRpb24gc3VwcG9ydHNcbiAgICAgKiAgbmF0aXZlIGF1dG8gaW5jcmVtZW50XG4gICAgICovXG4gICAgZmVhdHVyZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0b3JlIGlzIHJlYWR5IHRvIGJlIHVzZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICovXG4gICAgb25TdG9yZVJlYWR5OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaW5zdGFudGlhdGlvblxuICAgICAqIG9mIHRoZSBzdG9yZVxuICAgICAqXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbkVycm9yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGluc2VydElEIGNvdW50ZXJcbiAgICAgKlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luc2VydElkQ291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbiBJbmRleGVkREI7IGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBXaWxsIGNoZWNrIGlmIHZlcnNpb25zIG1hdGNoIGFuZCBjb21wYXJlIHByb3ZpZGVkIGluZGV4IGNvbmZpZ3VyYXRpb25cbiAgICAgKiB3aXRoIGV4aXN0aW5nIG9uZXMsIGFuZCB1cGRhdGUgaW5kZXhlcyBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBXaWxsIGNhbGwgdGhpcy5vblN0b3JlUmVhZHkoKSBpZiBldmVyeXRoaW5nIHdlbnQgd2VsbCBhbmQgdGhlIHN0b3JlXG4gICAgICogaXMgcmVhZHkgdG8gdXNlLCBhbmQgdGhpcy5vbkVycm9yKCkgaXMgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG4gICAgb3BlbkRCOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHZhciBvcGVuUmVxdWVzdCA9IHRoaXMuaWRiLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMuZGJWZXJzaW9uKTtcbiAgICAgIHZhciBwcmV2ZW50U3VjY2Vzc0NhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblxuICAgICAgICB2YXIgZ290VmVyc2lvbkVyciA9IGZhbHNlO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiBlcnJvci50YXJnZXQpIHtcbiAgICAgICAgICBnb3RWZXJzaW9uRXJyID0gZXJyb3IudGFyZ2V0LmVycm9yLm5hbWUgPT0gJ1ZlcnNpb25FcnJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2Vycm9yQ29kZScgaW4gZXJyb3IudGFyZ2V0KSB7XG4gICAgICAgICAgZ290VmVyc2lvbkVyciA9IGVycm9yLnRhcmdldC5lcnJvckNvZGUgPT0gMTI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ290VmVyc2lvbkVycikge1xuICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ1RoZSB2ZXJzaW9uIG51bWJlciBwcm92aWRlZCBpcyBsb3dlciB0aGFuIHRoZSBleGlzdGluZyBvbmUuJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKHByZXZlbnRTdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmRiKXtcbiAgICAgICAgICB0aGlzLm9uU3RvcmVSZWFkeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLmRiLnZlcnNpb24gPT0gJ3N0cmluZycpe1xuICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ1RoZSBJbmRleGVkREIgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBicm93c2VyIGlzIG91dGRhdGVkLiBQbGVhc2UgdXBncmFkZSB5b3VyIGJyb3dzZXIuJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKXtcbiAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZXZlciBnZXQgaGVyZS5cbiAgICAgICAgICAvLyBMZXRzIG5vdGlmeSB0aGUgdXNlciBhbnl3YXkuXG4gICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcignU29tZXRoaW5nIGlzIHdyb25nIHdpdGggdGhlIEluZGV4ZWREQiBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIGJyb3dzZXIuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYnJvd3Nlci4nKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVtcHR5VHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIHRoaXMuY29uc3RzLlJFQURfT05MWSk7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBlbXB0eVRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAvLyBjaGVjayBpbmRleGVzXG4gICAgICAgIHZhciBleGlzdGluZ0luZGV4ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmdldEluZGV4TGlzdCgpKTtcbiAgICAgICAgdGhpcy5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24oaW5kZXhEYXRhKXtcbiAgICAgICAgICB2YXIgaW5kZXhOYW1lID0gaW5kZXhEYXRhLm5hbWU7XG5cbiAgICAgICAgICBpZighaW5kZXhOYW1lKXtcbiAgICAgICAgICAgIHByZXZlbnRTdWNjZXNzQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBpbmRleDogTm8gaW5kZXggbmFtZSBnaXZlbi4nKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ub3JtYWxpemVJbmRleERhdGEoaW5kZXhEYXRhKTtcblxuICAgICAgICAgIGlmKHRoaXMuaGFzSW5kZXgoaW5kZXhOYW1lKSl7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpdCBjb21wbGllc1xuICAgICAgICAgICAgdmFyIGFjdHVhbEluZGV4ID0gdGhpcy5zdG9yZS5pbmRleChpbmRleE5hbWUpO1xuICAgICAgICAgICAgdmFyIGNvbXBsaWVzID0gdGhpcy5pbmRleENvbXBsaWVzKGFjdHVhbEluZGV4LCBpbmRleERhdGEpO1xuICAgICAgICAgICAgaWYoIWNvbXBsaWVzKXtcbiAgICAgICAgICAgICAgcHJldmVudFN1Y2Nlc3NDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgaW5kZXggXCInICsgaW5kZXhOYW1lICsgJ1wiIGZvciBjdXJyZW50IHZlcnNpb24uIFBsZWFzZSBidW1wIHZlcnNpb24gbnVtYmVyIHRvICcgKyAoIHRoaXMuZGJWZXJzaW9uICsgMSApICsgJy4nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4aXN0aW5nSW5kZXhlcy5zcGxpY2UoZXhpc3RpbmdJbmRleGVzLmluZGV4T2YoaW5kZXhOYW1lKSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZlbnRTdWNjZXNzQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBuZXcgaW5kZXggXCInICsgaW5kZXhOYW1lICsgJ1wiIGZvciBjdXJyZW50IHZlcnNpb24uIFBsZWFzZSBidW1wIHZlcnNpb24gbnVtYmVyIHRvICcgKyAoIHRoaXMuZGJWZXJzaW9uICsgMSApICsgJy4nKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJldmVudFN1Y2Nlc3NDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcignQ2Fubm90IGRlbGV0ZSBpbmRleChlcykgXCInICsgZXhpc3RpbmdJbmRleGVzLnRvU3RyaW5nKCkgKyAnXCIgZm9yIGN1cnJlbnQgdmVyc2lvbi4gUGxlYXNlIGJ1bXAgdmVyc2lvbiBudW1iZXIgdG8gJyArICggdGhpcy5kYlZlcnNpb24gKyAxICkgKyAnLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZlbnRTdWNjZXNzQ2FsbGJhY2sgfHwgdGhpcy5vblN0b3JlUmVhZHkoKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oLyogSURCVmVyc2lvbkNoYW5nZUV2ZW50ICovIGV2ZW50KXtcblxuICAgICAgICB0aGlzLmRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICBpZih0aGlzLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKXtcbiAgICAgICAgICB0aGlzLnN0b3JlID0gZXZlbnQudGFyZ2V0LnRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbWV0ZXJzID0geyBhdXRvSW5jcmVtZW50OiB0aGlzLmF1dG9JbmNyZW1lbnQgfTtcbiAgICAgICAgICBpZiAodGhpcy5rZXlQYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcmFtZXRlcnMua2V5UGF0aCA9IHRoaXMua2V5UGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdG9yZSA9IHRoaXMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUsIG9wdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpc3RpbmdJbmRleGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5nZXRJbmRleExpc3QoKSk7XG4gICAgICAgIHRoaXMuaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4RGF0YSl7XG4gICAgICAgICAgdmFyIGluZGV4TmFtZSA9IGluZGV4RGF0YS5uYW1lO1xuXG4gICAgICAgICAgaWYoIWluZGV4TmFtZSl7XG4gICAgICAgICAgICBwcmV2ZW50U3VjY2Vzc0NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgaW5kZXg6IE5vIGluZGV4IG5hbWUgZ2l2ZW4uJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubm9ybWFsaXplSW5kZXhEYXRhKGluZGV4RGF0YSk7XG5cbiAgICAgICAgICBpZih0aGlzLmhhc0luZGV4KGluZGV4TmFtZSkpe1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgY29tcGxpZXNcbiAgICAgICAgICAgIHZhciBhY3R1YWxJbmRleCA9IHRoaXMuc3RvcmUuaW5kZXgoaW5kZXhOYW1lKTtcbiAgICAgICAgICAgIHZhciBjb21wbGllcyA9IHRoaXMuaW5kZXhDb21wbGllcyhhY3R1YWxJbmRleCwgaW5kZXhEYXRhKTtcbiAgICAgICAgICAgIGlmKCFjb21wbGllcyl7XG4gICAgICAgICAgICAgIC8vIGluZGV4IGRpZmZlcnMsIG5lZWQgdG8gZGVsZXRlIGFuZCByZS1jcmVhdGVcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kZWxldGVJbmRleChpbmRleE5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlLmNyZWF0ZUluZGV4KGluZGV4TmFtZSwgaW5kZXhEYXRhLmtleVBhdGgsIHsgdW5pcXVlOiBpbmRleERhdGEudW5pcXVlLCBtdWx0aUVudHJ5OiBpbmRleERhdGEubXVsdGlFbnRyeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpc3RpbmdJbmRleGVzLnNwbGljZShleGlzdGluZ0luZGV4ZXMuaW5kZXhPZihpbmRleE5hbWUpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5jcmVhdGVJbmRleChpbmRleE5hbWUsIGluZGV4RGF0YS5rZXlQYXRoLCB7IHVuaXF1ZTogaW5kZXhEYXRhLnVuaXF1ZSwgbXVsdGlFbnRyeTogaW5kZXhEYXRhLm11bHRpRW50cnkgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZXhpc3RpbmdJbmRleGVzLmZvckVhY2goZnVuY3Rpb24oX2luZGV4TmFtZSl7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZUluZGV4KF9pbmRleE5hbWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZGF0YWJhc2UgdXNlZCBmb3IgdGhpcyBzdG9yZSBpZiB0aGUgSURCIGltcGxlbWVudGF0aW9uc1xuICAgICAqIHByb3ZpZGVzIHRoYXQgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBkZWxldGVEYXRhYmFzZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuaWRiLmRlbGV0ZURhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMuaWRiLmRlbGV0ZURhdGFiYXNlKHRoaXMuZGJOYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIGRhdGEgbWFuaXB1bGF0aW9uICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogUHV0cyBhbiBvYmplY3QgaW50byB0aGUgc3RvcmUuIElmIGFuIGVudHJ5IHdpdGggdGhlIGdpdmVuIGlkIGV4aXN0cyxcbiAgICAgKiBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBUaGlzIG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGZvciBpbmxpbmVcbiAgICAgKiBrZXlzIGFuZCBvdXQtb2YtbGluZSBrZXlzOyBwbGVhc2Ugc2VlIHRoZSBleGFtcGxlcyBiZWxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gW2tleV0gVGhlIGtleSB0byBzdG9yZS4gVGhpcyBpcyBvbmx5IG5lZWRlZCBpZiBJREJXcmFwcGVyXG4gICAgICogIGlzIHNldCB0byB1c2Ugb3V0LW9mLWxpbmUga2V5cy4gRm9yIGlubGluZSBrZXlzIC0gdGhlIGRlZmF1bHQgc2NlbmFyaW8gLVxuICAgICAqICB0aGlzIGNhbiBiZSBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgZGF0YSBvYmplY3QgdG8gc3RvcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpZiBpbnNlcnRpb25cbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaWYgaW5zZXJ0aW9uXG4gICAgICogIGZhaWxlZC5cbiAgICAgKiBAcmV0dXJucyB7SURCVHJhbnNhY3Rpb259IFRoZSB0cmFuc2FjdGlvbiB1c2VkIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAgICAvLyBTdG9yaW5nIGFuIG9iamVjdCwgdXNpbmcgaW5saW5lIGtleXMgKHRoZSBkZWZhdWx0IHNjZW5hcmlvKTpcbiAgICAgICAgdmFyIG15Q3VzdG9tZXIgPSB7XG4gICAgICAgICAgY3VzdG9tZXJpZDogMjM0NjIyMyxcbiAgICAgICAgICBsYXN0bmFtZTogJ0RvZScsXG4gICAgICAgICAgZmlyc3RuYW1lOiAnSm9obidcbiAgICAgICAgfTtcbiAgICAgICAgbXlDdXN0b21lclN0b3JlLnB1dChteUN1c3RvbWVyLCBteVN1Y2Nlc3NIYW5kbGVyLCBteUVycm9ySGFuZGxlcik7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBwYXNzaW5nIHN1Y2Nlc3MtIGFuZCBlcnJvci1oYW5kbGVycyBpcyBvcHRpb25hbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAgICAvLyBTdG9yaW5nIGFuIG9iamVjdCwgdXNpbmcgb3V0LW9mLWxpbmUga2V5czpcbiAgICAgICB2YXIgbXlDdXN0b21lciA9IHtcbiAgICAgICAgIGxhc3RuYW1lOiAnRG9lJyxcbiAgICAgICAgIGZpcnN0bmFtZTogJ0pvaG4nXG4gICAgICAgfTtcbiAgICAgICBteUN1c3RvbWVyU3RvcmUucHV0KDIzNDYyMjMsIG15Q3VzdG9tZXIsIG15U3VjY2Vzc0hhbmRsZXIsIG15RXJyb3JIYW5kbGVyKTtcbiAgICAgIC8vIE5vdGUgdGhhdCBwYXNzaW5nIHN1Y2Nlc3MtIGFuZCBlcnJvci1oYW5kbGVycyBpcyBvcHRpb25hbC5cbiAgICAgKi9cbiAgICBwdXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLmtleVBhdGggIT09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IG9uU3VjY2VzcztcbiAgICAgICAgb25TdWNjZXNzID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0ga2V5O1xuICAgICAgfVxuICAgICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXIpO1xuICAgICAgb25TdWNjZXNzIHx8IChvblN1Y2Nlc3MgPSBub29wKTtcblxuICAgICAgdmFyIGhhc1N1Y2Nlc3MgPSBmYWxzZSxcbiAgICAgICAgICByZXN1bHQgPSBudWxsLFxuICAgICAgICAgIHB1dFJlcXVlc3Q7XG5cbiAgICAgIHZhciBwdXRUcmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgdGhpcy5jb25zdHMuUkVBRF9XUklURSk7XG4gICAgICBwdXRUcmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBoYXNTdWNjZXNzID8gb25TdWNjZXNzIDogb25FcnJvcjtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgICBwdXRUcmFuc2FjdGlvbi5vbmFib3J0ID0gb25FcnJvcjtcbiAgICAgIHB1dFRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICBpZiAodGhpcy5rZXlQYXRoICE9PSBudWxsKSB7IC8vIGluLWxpbmUga2V5c1xuICAgICAgICB0aGlzLl9hZGRJZFByb3BlcnR5SWZOZWVkZWQodmFsdWUpO1xuICAgICAgICBwdXRSZXF1ZXN0ID0gcHV0VHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpLnB1dCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgeyAvLyBvdXQtb2YtbGluZSBrZXlzXG4gICAgICAgIHB1dFJlcXVlc3QgPSBwdXRUcmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkucHV0KHZhbHVlLCBrZXkpO1xuICAgICAgfVxuICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcblxuICAgICAgcmV0dXJuIHB1dFRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gb2JqZWN0IGZyb20gdGhlIHN0b3JlLiBJZiBubyBlbnRyeSBleGlzdHMgd2l0aCB0aGUgZ2l2ZW4gaWQsXG4gICAgICogdGhlIHN1Y2Nlc3MgaGFuZGxlciB3aWxsIGJlIGNhbGxlZCB3aXRoIG51bGwgYXMgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUgaWQgb2YgdGhlIG9iamVjdCB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGlmIGZldGNoaW5nXG4gICAgICogIHdhcyBzdWNjZXNzZnVsLiBXaWxsIHJlY2VpdmUgdGhlIG9iamVjdCBhcyBvbmx5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgYW4gZXJyb3JcbiAgICAgKiAgb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0lEQlRyYW5zYWN0aW9ufSBUaGUgdHJhbnNhY3Rpb24gdXNlZCBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IgfHwgKG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyKTtcbiAgICAgIG9uU3VjY2VzcyB8fCAob25TdWNjZXNzID0gbm9vcCk7XG5cbiAgICAgIHZhciBoYXNTdWNjZXNzID0gZmFsc2UsXG4gICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgIFxuICAgICAgdmFyIGdldFRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCB0aGlzLmNvbnN0cy5SRUFEX09OTFkpO1xuICAgICAgZ2V0VHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gaGFzU3VjY2VzcyA/IG9uU3VjY2VzcyA6IG9uRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgZ2V0VHJhbnNhY3Rpb24ub25hYm9ydCA9IG9uRXJyb3I7XG4gICAgICBnZXRUcmFuc2FjdGlvbi5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgIHZhciBnZXRSZXF1ZXN0ID0gZ2V0VHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpLmdldChrZXkpO1xuICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICB9O1xuICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcblxuICAgICAgcmV0dXJuIGdldFRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBpZCBvZiB0aGUgb2JqZWN0IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGlmIHRoZSByZW1vdmFsXG4gICAgICogIHdhcyBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgYW4gZXJyb3JcbiAgICAgKiAgb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0lEQlRyYW5zYWN0aW9ufSBUaGUgdHJhbnNhY3Rpb24gdXNlZCBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5LCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IgfHwgKG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyKTtcbiAgICAgIG9uU3VjY2VzcyB8fCAob25TdWNjZXNzID0gbm9vcCk7XG5cbiAgICAgIHZhciBoYXNTdWNjZXNzID0gZmFsc2UsXG4gICAgICAgICAgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgdmFyIHJlbW92ZVRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCB0aGlzLmNvbnN0cy5SRUFEX1dSSVRFKTtcbiAgICAgIHJlbW92ZVRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGhhc1N1Y2Nlc3MgPyBvblN1Y2Nlc3MgOiBvbkVycm9yO1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlbW92ZVRyYW5zYWN0aW9uLm9uYWJvcnQgPSBvbkVycm9yO1xuICAgICAgcmVtb3ZlVHJhbnNhY3Rpb24ub25lcnJvciA9IG9uRXJyb3I7XG5cbiAgICAgIHZhciBkZWxldGVSZXF1ZXN0ID0gcmVtb3ZlVHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpWydkZWxldGUnXShrZXkpO1xuICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICB9O1xuICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcblxuICAgICAgcmV0dXJuIHJlbW92ZVRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgYmF0Y2ggb2YgcHV0IGFuZC9vciByZW1vdmUgb3BlcmF0aW9ucyBvbiB0aGUgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBvcGVyYXRpb24gdG8gcnVuXG4gICAgICogIGFuZCB0aGUgZGF0YSBvYmplY3QgKGZvciBwdXQgb3BlcmF0aW9ucykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpZiBhbGwgb3BlcmF0aW9uc1xuICAgICAqICB3ZXJlIHN1Y2Nlc3NmdWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaWYgYW4gZXJyb3JcbiAgICAgKiAgb2NjdXJyZWQgZHVyaW5nIG9uZSBvZiB0aGUgb3BlcmF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7SURCVHJhbnNhY3Rpb259IFRoZSB0cmFuc2FjdGlvbiB1c2VkIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBiYXRjaDogZnVuY3Rpb24gKGRhdGFBcnJheSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICBvbkVycm9yIHx8IChvbkVycm9yID0gZGVmYXVsdEVycm9ySGFuZGxlcik7XG4gICAgICBvblN1Y2Nlc3MgfHwgKG9uU3VjY2VzcyA9IG5vb3ApO1xuXG4gICAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YUFycmF5KSAhPSAnW29iamVjdCBBcnJheV0nKXtcbiAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoJ2RhdGFBcnJheSBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgQXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgdmFyIGJhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0gLCB0aGlzLmNvbnN0cy5SRUFEX1dSSVRFKTtcbiAgICAgIGJhdGNoVHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gaGFzU3VjY2VzcyA/IG9uU3VjY2VzcyA6IG9uRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrKGhhc1N1Y2Nlc3MpO1xuICAgICAgfTtcbiAgICAgIGJhdGNoVHJhbnNhY3Rpb24ub25hYm9ydCA9IG9uRXJyb3I7XG4gICAgICBiYXRjaFRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgXG4gICAgICB2YXIgY291bnQgPSBkYXRhQXJyYXkubGVuZ3RoO1xuICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgdmFyIGhhc1N1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgdmFyIG9uSXRlbVN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvdW50LS07XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCAmJiAhY2FsbGVkKSB7XG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBoYXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICB2YXIgdHlwZSA9IG9wZXJhdGlvbi50eXBlO1xuICAgICAgICB2YXIga2V5ID0gb3BlcmF0aW9uLmtleTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3BlcmF0aW9uLnZhbHVlO1xuXG4gICAgICAgIHZhciBvbkl0ZW1FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBiYXRjaFRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBvbkVycm9yKGVyciwgdHlwZSwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICB2YXIgZGVsZXRlUmVxdWVzdCA9IGJhdGNoVHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpWydkZWxldGUnXShrZXkpO1xuICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gb25JdGVtU3VjY2VzcztcbiAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSBvbkl0ZW1FcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdwdXQnKSB7XG4gICAgICAgICAgdmFyIHB1dFJlcXVlc3Q7XG4gICAgICAgICAgaWYgKHRoaXMua2V5UGF0aCAhPT0gbnVsbCkgeyAvLyBpbi1saW5lIGtleXNcbiAgICAgICAgICAgIHRoaXMuX2FkZElkUHJvcGVydHlJZk5lZWRlZCh2YWx1ZSk7XG4gICAgICAgICAgICBwdXRSZXF1ZXN0ID0gYmF0Y2hUcmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkucHV0KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBvdXQtb2YtbGluZSBrZXlzXG4gICAgICAgICAgICBwdXRSZXF1ZXN0ID0gYmF0Y2hUcmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkucHV0KHZhbHVlLCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IG9uSXRlbVN1Y2Nlc3M7XG4gICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gb25JdGVtRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gYmF0Y2hUcmFuc2FjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgc3RvcmVzIHRoZW0gaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBzdG9yZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaWYgYWxsIG9wZXJhdGlvbnNcbiAgICAgKiAgd2VyZSBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGlmIGFuIGVycm9yXG4gICAgICogIG9jY3VycmVkIGR1cmluZyBvbmUgb2YgdGhlIG9wZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge0lEQlRyYW5zYWN0aW9ufSBUaGUgdHJhbnNhY3Rpb24gdXNlZCBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcHV0QmF0Y2g6IGZ1bmN0aW9uIChkYXRhQXJyYXksIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgdmFyIGJhdGNoRGF0YSA9IGRhdGFBcnJheS5tYXAoZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwdXQnLCB2YWx1ZTogaXRlbSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmJhdGNoKGJhdGNoRGF0YSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2Yga2V5cyBhbmQgcmVtb3ZlcyBtYXRjaGluZyBvYmplY3RzIGluIGEgc2luZ2xlXG4gICAgICogdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlBcnJheSBBbiBhcnJheSBvZiBrZXlzIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaWYgYWxsIG9wZXJhdGlvbnNcbiAgICAgKiAgd2VyZSBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGlmIGFuIGVycm9yXG4gICAgICogIG9jY3VycmVkIGR1cmluZyBvbmUgb2YgdGhlIG9wZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMge0lEQlRyYW5zYWN0aW9ufSBUaGUgdHJhbnNhY3Rpb24gdXNlZCBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcmVtb3ZlQmF0Y2g6IGZ1bmN0aW9uIChrZXlBcnJheSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICB2YXIgYmF0Y2hEYXRhID0ga2V5QXJyYXkubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdyZW1vdmUnLCBrZXk6IGtleSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmJhdGNoKGJhdGNoRGF0YSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2Yga2V5cyBhbmQgZmV0Y2hlcyBtYXRjaGluZyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlBcnJheSBBbiBhcnJheSBvZiBrZXlzIGlkZW50aWZ5aW5nIHRoZSBvYmplY3RzIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpZiBhbGwgb3BlcmF0aW9uc1xuICAgICAqICB3ZXJlIHN1Y2Nlc3NmdWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgaWYgYW4gZXJyb3JcbiAgICAgKiAgb2NjdXJyZWQgZHVyaW5nIG9uZSBvZiB0aGUgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FycmF5VHlwZT0nc3BhcnNlJ10gVGhlIHR5cGUgb2YgYXJyYXkgdG8gcGFzcyB0byB0aGVcbiAgICAgKiAgc3VjY2VzcyBoYW5kbGVyLiBNYXkgYmUgb25lIG9mICdzcGFyc2UnLCAnZGVuc2UnIG9yICdza2lwJy4gRGVmYXVsdHMgdG9cbiAgICAgKiAgJ3NwYXJzZScuIFRoaXMgcGFyYW1ldGVyIHNwZWNpZmllcyBob3cgdG8gaGFuZGxlIHRoZSBzaXR1YXRpb24gaWYgYSBnZXRcbiAgICAgKiAgb3BlcmF0aW9uIGRpZCBub3QgdGhyb3cgYW4gZXJyb3IsIGJ1dCB0aGVyZSB3YXMgbm8gbWF0Y2hpbmcgb2JqZWN0IGluXG4gICAgICogIHRoZSBkYXRhYmFzZS4gSW4gbW9zdCBjYXNlcywgJ3NwYXJzZScgcHJvdmlkZXMgdGhlIG1vc3QgZGVzaXJlZFxuICAgICAqICBiZWhhdmlvci4gU2VlIHRoZSBleGFtcGxlcyBmb3IgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7SURCVHJhbnNhY3Rpb259IFRoZSB0cmFuc2FjdGlvbiB1c2VkIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAvLyBnaXZlbiB0aGF0IHRoZXJlIGFyZSB0d28gb2JqZWN0cyBpbiB0aGUgZGF0YWJhc2Ugd2l0aCB0aGUga2V5cGF0aFxuICAgICAvLyB2YWx1ZXMgMSBhbmQgMiwgYW5kIHRoZSBjYWxsIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgbXlTdG9yZS5nZXRCYXRjaChbMSwgNSwgMl0sIG9uRXJyb3IsIGZ1bmN0aW9uIChkYXRhKSB7IOKApiB9LCBhcnJheVR5cGUpO1xuXG4gICAgIC8vIHRoaXMgaXMgd2hhdCB0aGUgYGRhdGFgIGFycmF5IHdpbGwgYmUgbGlrZTpcblxuICAgICAvLyBhcnJheVR5cGUgPT0gJ3NwYXJzZSc6XG4gICAgIC8vIGRhdGEgaXMgYSBzcGFyc2UgYXJyYXkgY29udGFpbmluZyB0d28gZW50cmllcyBhbmQgaGF2aW5nIGEgbGVuZ3RoIG9mIDM6XG4gICAgICAgW09iamVjdCwgMjogT2JqZWN0XVxuICAgICAgICAgMDogT2JqZWN0XG4gICAgICAgICAyOiBPYmplY3RcbiAgICAgICAgIGxlbmd0aDogM1xuICAgICAgICAgX19wcm90b19fOiBBcnJheVswXVxuICAgICAvLyBjYWxsaW5nIGZvckVhY2ggb24gZGF0YSB3aWxsIHJlc3VsdCBpbiB0aGUgY2FsbGJhY2sgYmVpbmcgY2FsbGVkIHR3b1xuICAgICAvLyB0aW1lcywgd2l0aCB0aGUgaW5kZXggcGFyYW1ldGVyIG1hdGNoaW5nIHRoZSBpbmRleCBvZiB0aGUga2V5IGluIHRoZVxuICAgICAvLyBrZXlBcnJheS5cblxuICAgICAvLyBhcnJheVR5cGUgPT0gJ2RlbnNlJzpcbiAgICAgLy8gZGF0YSBpcyBhIGRlbnNlIGFycmF5IGNvbnRhaW5pbmcgdGhyZWUgZW50cmllcyBhbmQgaGF2aW5nIGEgbGVuZ3RoIG9mIDMsXG4gICAgIC8vIHdoZXJlIGRhdGFbMV0gaXMgb2YgdHlwZSB1bmRlZmluZWQ6XG4gICAgICAgW09iamVjdCwgdW5kZWZpbmVkLCBPYmplY3RdXG4gICAgICAgICAwOiBPYmplY3RcbiAgICAgICAgIDE6IHVuZGVmaW5lZFxuICAgICAgICAgMjogT2JqZWN0XG4gICAgICAgICBsZW5ndGg6IDNcbiAgICAgICAgIF9fcHJvdG9fXzogQXJyYXlbMF1cbiAgICAgLy8gY2FsbGluZyBmb3JFYWNoIG9uIGRhdGEgd2lsbCByZXN1bHQgaW4gdGhlIGNhbGxiYWNrIGJlaW5nIGNhbGxlZCB0aHJlZVxuICAgICAvLyB0aW1lcywgd2l0aCB0aGUgaW5kZXggcGFyYW1ldGVyIG1hdGNoaW5nIHRoZSBpbmRleCBvZiB0aGUga2V5IGluIHRoZVxuICAgICAvLyBrZXlBcnJheSwgYnV0IHRoZSBzZWNvbmQgY2FsbCB3aWxsIGhhdmUgdW5kZWZpbmVkIGFzIGZpcnN0IGFyZ3VtZW50LlxuXG4gICAgIC8vIGFycmF5VHlwZSA9PSAnc2tpcCc6XG4gICAgIC8vIGRhdGEgaXMgYSBkZW5zZSBhcnJheSBjb250YWluaW5nIHR3byBlbnRyaWVzIGFuZCBoYXZpbmcgYSBsZW5ndGggb2YgMjpcbiAgICAgICBbT2JqZWN0LCBPYmplY3RdXG4gICAgICAgICAwOiBPYmplY3RcbiAgICAgICAgIDE6IE9iamVjdFxuICAgICAgICAgbGVuZ3RoOiAyXG4gICAgICAgICBfX3Byb3RvX186IEFycmF5WzBdXG4gICAgIC8vIGNhbGxpbmcgZm9yRWFjaCBvbiBkYXRhIHdpbGwgcmVzdWx0IGluIHRoZSBjYWxsYmFjayBiZWluZyBjYWxsZWQgdHdvXG4gICAgIC8vIHRpbWVzLCB3aXRoIHRoZSBpbmRleCBwYXJhbWV0ZXIgbm90IG1hdGNoaW5nIHRoZSBpbmRleCBvZiB0aGUga2V5IGluIHRoZVxuICAgICAvLyBrZXlBcnJheS5cbiAgICAgKi9cbiAgICBnZXRCYXRjaDogZnVuY3Rpb24gKGtleUFycmF5LCBvblN1Y2Nlc3MsIG9uRXJyb3IsIGFycmF5VHlwZSkge1xuICAgICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXIpO1xuICAgICAgb25TdWNjZXNzIHx8IChvblN1Y2Nlc3MgPSBub29wKTtcbiAgICAgIGFycmF5VHlwZSB8fCAoYXJyYXlUeXBlID0gJ3NwYXJzZScpO1xuXG4gICAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoa2V5QXJyYXkpICE9ICdbb2JqZWN0IEFycmF5XScpe1xuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcigna2V5QXJyYXkgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdICwgdGhpcy5jb25zdHMuUkVBRF9PTkxZKTtcbiAgICAgIGJhdGNoVHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gaGFzU3VjY2VzcyA/IG9uU3VjY2VzcyA6IG9uRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgYmF0Y2hUcmFuc2FjdGlvbi5vbmFib3J0ID0gb25FcnJvcjtcbiAgICAgIGJhdGNoVHJhbnNhY3Rpb24ub25lcnJvciA9IG9uRXJyb3I7XG5cbiAgICAgIHZhciBkYXRhID0gW107XG4gICAgICB2YXIgY291bnQgPSBrZXlBcnJheS5sZW5ndGg7XG4gICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICB2YXIgaGFzU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgIHZhciBvbkl0ZW1TdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQucmVzdWx0IHx8IGFycmF5VHlwZSA9PSAnZGVuc2UnKSB7XG4gICAgICAgICAgZGF0YS5wdXNoKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5VHlwZSA9PSAnc3BhcnNlJykge1xuICAgICAgICAgIGRhdGEubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQtLTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBoYXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBrZXlBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICB2YXIgb25JdGVtRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBlcnI7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIGJhdGNoVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGJhdGNoVHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpLmdldChrZXkpO1xuICAgICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IG9uSXRlbVN1Y2Nlc3M7XG4gICAgICAgIGdldFJlcXVlc3Qub25lcnJvciA9IG9uSXRlbUVycm9yO1xuXG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIGJhdGNoVHJhbnNhY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIGVudHJpZXMgaW4gdGhlIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCBpZiB0aGUgb3BlcmF0aW9uXG4gICAgICogIHdhcyBzdWNjZXNzZnVsLiBXaWxsIHJlY2VpdmUgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGlmIGFuIGVycm9yXG4gICAgICogIG9jY3VycmVkIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtJREJUcmFuc2FjdGlvbn0gVGhlIHRyYW5zYWN0aW9uIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldEFsbDogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXIpO1xuICAgICAgb25TdWNjZXNzIHx8IChvblN1Y2Nlc3MgPSBub29wKTtcbiAgICAgIHZhciBnZXRBbGxUcmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgdGhpcy5jb25zdHMuUkVBRF9PTkxZKTtcbiAgICAgIHZhciBzdG9yZSA9IGdldEFsbFRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGlmIChzdG9yZS5nZXRBbGwpIHtcbiAgICAgICAgdGhpcy5fZ2V0QWxsTmF0aXZlKGdldEFsbFRyYW5zYWN0aW9uLCBzdG9yZSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2dldEFsbEN1cnNvcihnZXRBbGxUcmFuc2FjdGlvbiwgc3RvcmUsIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRBbGxUcmFuc2FjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBnZXRBbGwgZm9yIElEQiBpbXBsZW1lbnRhdGlvbnMgdGhhdCBoYXZlIGEgbm9uLXN0YW5kYXJkXG4gICAgICogZ2V0QWxsKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdldEFsbFRyYW5zYWN0aW9uIEFuIG9wZW4gUkVBRCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmUgQSByZWZlcmVuY2UgdG8gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3VjY2VzcyBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlXG4gICAgICogIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiBhblxuICAgICAqICBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBbGxOYXRpdmU6IGZ1bmN0aW9uIChnZXRBbGxUcmFuc2FjdGlvbiwgc3RvcmUsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgdmFyIGhhc1N1Y2Nlc3MgPSBmYWxzZSxcbiAgICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgICBnZXRBbGxUcmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBoYXNTdWNjZXNzID8gb25TdWNjZXNzIDogb25FcnJvcjtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgICBnZXRBbGxUcmFuc2FjdGlvbi5vbmFib3J0ID0gb25FcnJvcjtcbiAgICAgIGdldEFsbFRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICB2YXIgZ2V0QWxsUmVxdWVzdCA9IHN0b3JlLmdldEFsbCgpO1xuICAgICAgZ2V0QWxsUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICB9O1xuICAgICAgZ2V0QWxsUmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBnZXRBbGwgZm9yIElEQiBpbXBsZW1lbnRhdGlvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIGdldEFsbCgpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdldEFsbFRyYW5zYWN0aW9uIEFuIG9wZW4gUkVBRCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmUgQSByZWZlcmVuY2UgdG8gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3VjY2VzcyBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlXG4gICAgICogIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiBhblxuICAgICAqICBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBbGxDdXJzb3I6IGZ1bmN0aW9uIChnZXRBbGxUcmFuc2FjdGlvbiwgc3RvcmUsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgdmFyIGFsbCA9IFtdLFxuICAgICAgICAgIGhhc1N1Y2Nlc3MgPSBmYWxzZSxcbiAgICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgICBnZXRBbGxUcmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBoYXNTdWNjZXNzID8gb25TdWNjZXNzIDogb25FcnJvcjtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgICBnZXRBbGxUcmFuc2FjdGlvbi5vbmFib3J0ID0gb25FcnJvcjtcbiAgICAgIGdldEFsbFRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICB2YXIgY3Vyc29yUmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgYWxsLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICBjdXJzb3JbJ2NvbnRpbnVlJ10oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBoYXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBhbGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjdXJzb3JSZXF1ZXN0Lm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHN0b3JlLCBpLmUuIGRlbGV0ZXMgYWxsIGVudHJpZXMgaW4gdGhlIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGlmIHRoZVxuICAgICAqICBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiBhblxuICAgICAqICBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7SURCVHJhbnNhY3Rpb259IFRoZSB0cmFuc2FjdGlvbiB1c2VkIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgb25FcnJvciB8fCAob25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXIpO1xuICAgICAgb25TdWNjZXNzIHx8IChvblN1Y2Nlc3MgPSBub29wKTtcblxuICAgICAgdmFyIGhhc1N1Y2Nlc3MgPSBmYWxzZSxcbiAgICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgICB2YXIgY2xlYXJUcmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgdGhpcy5jb25zdHMuUkVBRF9XUklURSk7XG4gICAgICBjbGVhclRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGhhc1N1Y2Nlc3MgPyBvblN1Y2Nlc3MgOiBvbkVycm9yO1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIGNsZWFyVHJhbnNhY3Rpb24ub25hYm9ydCA9IG9uRXJyb3I7XG4gICAgICBjbGVhclRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICB2YXIgY2xlYXJSZXF1ZXN0ID0gY2xlYXJUcmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkuY2xlYXIoKTtcbiAgICAgIGNsZWFyUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY2xlYXJSZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuXG4gICAgICByZXR1cm4gY2xlYXJUcmFuc2FjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFuIGlkIHByb3BlcnR5IG5lZWRzIHRvIHByZXNlbnQgb24gYSBvYmplY3QgYW5kIGFkZHMgb25lIGlmXG4gICAgICogbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFPYmogVGhlIGRhdGEgb2JqZWN0IHRoYXQgaXMgYWJvdXQgdG8gYmUgc3RvcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkSWRQcm9wZXJ0eUlmTmVlZGVkOiBmdW5jdGlvbiAoZGF0YU9iaikge1xuICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzLmhhc0F1dG9JbmNyZW1lbnQgJiYgdHlwZW9mIGRhdGFPYmpbdGhpcy5rZXlQYXRoXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkYXRhT2JqW3RoaXMua2V5UGF0aF0gPSB0aGlzLl9pbnNlcnRJZENvdW50KysgKyBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKioqKioqKioqKioqXG4gICAgICogaW5kZXhpbmcgKlxuICAgICAqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgRE9NU3RyaW5nTGlzdCBvZiBpbmRleCBuYW1lcyBvZiB0aGUgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtET01TdHJpbmdMaXN0fSBUaGUgbGlzdCBvZiBpbmRleCBuYW1lc1xuICAgICAqL1xuICAgIGdldEluZGV4TGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuaW5kZXhOYW1lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFuIGluZGV4IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzIGluIHRoZSBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbmRleE5hbWUgVGhlIG5hbWUgb2YgdGhlIGluZGV4IHRvIGxvb2sgZm9yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgc3RvcmUgY29udGFpbnMgYW4gaW5kZXggd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqL1xuICAgIGhhc0luZGV4OiBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKGluZGV4TmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5kZXggZGF0YSBhbmQgYXNzdXJlcyB0aGF0IGFsbFxuICAgICAqIHByb3BlcnRpZXMgYXJlIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleERhdGEgVGhlIGluZGV4IGRhdGEgb2JqZWN0IHRvIG5vcm1hbGl6ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbmRleERhdGEubmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2luZGV4RGF0YS5rZXlQYXRoXSBUaGUga2V5IHBhdGggb2YgdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5kZXhEYXRhLnVuaXF1ZV0gV2hldGhlciB0aGUgaW5kZXggaXMgdW5pcXVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5kZXhEYXRhLm11bHRpRW50cnldIFdoZXRoZXIgdGhlIGluZGV4IGlzIG11bHRpIGVudHJ5XG4gICAgICovXG4gICAgbm9ybWFsaXplSW5kZXhEYXRhOiBmdW5jdGlvbiAoaW5kZXhEYXRhKSB7XG4gICAgICBpbmRleERhdGEua2V5UGF0aCA9IGluZGV4RGF0YS5rZXlQYXRoIHx8IGluZGV4RGF0YS5uYW1lO1xuICAgICAgaW5kZXhEYXRhLnVuaXF1ZSA9ICEhaW5kZXhEYXRhLnVuaXF1ZTtcbiAgICAgIGluZGV4RGF0YS5tdWx0aUVudHJ5ID0gISFpbmRleERhdGEubXVsdGlFbnRyeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFuIGFjdHVhbCBpbmRleCBjb21wbGllcyB3aXRoIGFuIGV4cGVjdGVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjdHVhbCBUaGUgYWN0dWFsIGluZGV4IGZvdW5kIGluIHRoZSBzdG9yZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCBBbiBPYmplY3QgZGVzY3JpYmluZyBhbiBleHBlY3RlZCBpbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYm90aCBpbmRleCBkZWZpbml0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAgICovXG4gICAgaW5kZXhDb21wbGllczogZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBjb21wbGllcyA9IFsna2V5UGF0aCcsICd1bmlxdWUnLCAnbXVsdGlFbnRyeSddLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gSUUxMCByZXR1cm5zIHVuZGVmaW5lZCBmb3Igbm8gbXVsdGlFbnRyeVxuICAgICAgICBpZiAoa2V5ID09ICdtdWx0aUVudHJ5JyAmJiBhY3R1YWxba2V5XSA9PT0gdW5kZWZpbmVkICYmIGV4cGVjdGVkW2tleV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcG91bmQga2V5c1xuICAgICAgICBpZiAoa2V5ID09ICdrZXlQYXRoJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWRba2V5XSkgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgIHZhciBleHAgPSBleHBlY3RlZC5rZXlQYXRoO1xuICAgICAgICAgIHZhciBhY3QgPSBhY3R1YWwua2V5UGF0aDtcblxuICAgICAgICAgIC8vIElFMTAgY2FuJ3QgaGFuZGxlIGtleVBhdGggc2VxdWVuY2VzIGFuZCBzdG9yZXMgdGhlbSBhcyBhIHN0cmluZy5cbiAgICAgICAgICAvLyBUaGUgaW5kZXggd2lsbCBiZSB1bnVzYWJsZSB0aGVyZSwgYnV0IGxldCdzIHN0aWxsIHJldHVybiB0cnVlIGlmXG4gICAgICAgICAgLy8gdGhlIGtleVBhdGggc2VxdWVuY2UgbWF0Y2hlcy5cbiAgICAgICAgICBpZiAodHlwZW9mIGFjdCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGV4cC50b1N0cmluZygpID09IGFjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaHJvbWUvT3BlcmEgc3RvcmVzIGtleVBhdGggc3F1ZW5jZXMgYXMgRE9NU3RyaW5nTGlzdCwgRmlyZWZveFxuICAgICAgICAgIC8vIGFzIEFycmF5XG4gICAgICAgICAgaWYgKCAhICh0eXBlb2YgYWN0LmNvbnRhaW5zID09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFjdC5pbmRleE9mID09ICdmdW5jdGlvbicpICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3QubGVuZ3RoICE9PSBleHAubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG0gPSBleHAubGVuZ3RoOyBpPG07IGkrKykge1xuICAgICAgICAgICAgaWYgKCAhICggKGFjdC5jb250YWlucyAmJiBhY3QuY29udGFpbnMoZXhwW2ldKSkgfHwgYWN0LmluZGV4T2YoZXhwW2ldICE9PSAtMSkgKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZFtrZXldID09IGFjdHVhbFtrZXldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGxpZXM7XG4gICAgfSxcblxuICAgIC8qKioqKioqKioqXG4gICAgICogY3Vyc29yICpcbiAgICAgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIHN0b3JlIHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBjYWxsaW5nIG9uSXRlbVxuICAgICAqIGZvciBlYWNoIGVudHJ5IG1hdGNoaW5nIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25JdGVtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIG1hdGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgZGVmaW5pbmcgc3BlY2lmaWMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbmRleD1udWxsXSBBbiBJREJJbmRleCB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yZGVyPUFTQ10gVGhlIG9yZGVyIGluIHdoaWNoIHRvIHByb3ZpZGUgdGhlXG4gICAgICogIHJlc3VsdHMsIGNhbiBiZSAnREVTQycgb3IgJ0FTQydcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Db250aW51ZT10cnVlXSBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgaXRlcmF0ZSB0aGUgY3Vyc29yIHRvIHRoZSBuZXh0IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmlsdGVyRHVwbGljYXRlcz1mYWxzZV0gV2hldGhlciB0byBleGNsdWRlXG4gICAgICogIGR1cGxpY2F0ZSBtYXRjaGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmtleVJhbmdlPW51bGxdIEFuIElEQktleVJhbmdlIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud3JpdGVBY2Nlc3M9ZmFsc2VdIFdoZXRoZXIgZ3JhbnQgd3JpdGUgYWNjZXNzXG4gICAgICogIHRvIHRoZSBzdG9yZSBpbiB0aGUgb25JdGVtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25FbmQ9bnVsbF0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgKiAgaXRlcmF0aW9uIGhhcyBlbmRlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRXJyb3I9dGhyb3ddIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gICAgICogIGlmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtJREJUcmFuc2FjdGlvbn0gVGhlIHRyYW5zYWN0aW9uIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGl0ZXJhdGU6IGZ1bmN0aW9uIChvbkl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBtaXhpbih7XG4gICAgICAgIGluZGV4OiBudWxsLFxuICAgICAgICBvcmRlcjogJ0FTQycsXG4gICAgICAgIGF1dG9Db250aW51ZTogdHJ1ZSxcbiAgICAgICAgZmlsdGVyRHVwbGljYXRlczogZmFsc2UsXG4gICAgICAgIGtleVJhbmdlOiBudWxsLFxuICAgICAgICB3cml0ZUFjY2VzczogZmFsc2UsXG4gICAgICAgIG9uRW5kOiBudWxsLFxuICAgICAgICBvbkVycm9yOiBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgdmFyIGRpcmVjdGlvblR5cGUgPSBvcHRpb25zLm9yZGVyLnRvTG93ZXJDYXNlKCkgPT0gJ2Rlc2MnID8gJ1BSRVYnIDogJ05FWFQnO1xuICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyRHVwbGljYXRlcykge1xuICAgICAgICBkaXJlY3Rpb25UeXBlICs9ICdfTk9fRFVQTElDQVRFJztcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc1N1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIHZhciBjdXJzb3JUcmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgdGhpcy5jb25zdHNbb3B0aW9ucy53cml0ZUFjY2VzcyA/ICdSRUFEX1dSSVRFJyA6ICdSRUFEX09OTFknXSk7XG4gICAgICB2YXIgY3Vyc29yVGFyZ2V0ID0gY3Vyc29yVHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZXgpIHtcbiAgICAgICAgY3Vyc29yVGFyZ2V0ID0gY3Vyc29yVGFyZ2V0LmluZGV4KG9wdGlvbnMuaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBjdXJzb3JUcmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWhhc1N1Y2Nlc3MpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRXJyb3IobnVsbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uRW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uSXRlbShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGN1cnNvclRyYW5zYWN0aW9uLm9uYWJvcnQgPSBvcHRpb25zLm9uRXJyb3I7XG4gICAgICBjdXJzb3JUcmFuc2FjdGlvbi5vbmVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXG4gICAgICB2YXIgY3Vyc29yUmVxdWVzdCA9IGN1cnNvclRhcmdldC5vcGVuQ3Vyc29yKG9wdGlvbnMua2V5UmFuZ2UsIHRoaXMuY29uc3RzW2RpcmVjdGlvblR5cGVdKTtcbiAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9IG9wdGlvbnMub25FcnJvcjtcbiAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgb25JdGVtKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBjdXJzb3JUcmFuc2FjdGlvbik7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0NvbnRpbnVlKSB7XG4gICAgICAgICAgICBjdXJzb3JbJ2NvbnRpbnVlJ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjdXJzb3JUcmFuc2FjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHF1ZXJ5IGFnYWluc3QgdGhlIHN0b3JlIGFuZCBwYXNzZXMgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGVkXG4gICAgICogb2JqZWN0cyB0byB0aGUgc3VjY2VzcyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdWNjZXNzIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG9wZXJhdGlvblxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBkZWZpbmluZyBzcGVjaWZpYyBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmluZGV4PW51bGxdIEFuIElEQkluZGV4IHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JkZXI9QVNDXSBUaGUgb3JkZXIgaW4gd2hpY2ggdG8gcHJvdmlkZSB0aGVcbiAgICAgKiAgcmVzdWx0cywgY2FuIGJlICdERVNDJyBvciAnQVNDJ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmlsdGVyRHVwbGljYXRlcz1mYWxzZV0gV2hldGhlciB0byBleGNsdWRlXG4gICAgICogIGR1cGxpY2F0ZSBtYXRjaGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmtleVJhbmdlPW51bGxdIEFuIElEQktleVJhbmdlIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRXJyb3I9dGhyb3ddIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGlmIGFuIGVycm9yXG4gICAgICogIG9jY3VycmVkIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtJREJUcmFuc2FjdGlvbn0gVGhlIHRyYW5zYWN0aW9uIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHF1ZXJ5OiBmdW5jdGlvbiAob25TdWNjZXNzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMub25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uU3VjY2VzcyhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSdW5zIGEgcXVlcnkgYWdhaW5zdCB0aGUgc3RvcmUsIGJ1dCBvbmx5IHJldHVybnMgdGhlIG51bWJlciBvZiBtYXRjaGVzXG4gICAgICogaW5zdGVhZCBvZiB0aGUgbWF0Y2hlcyBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN1Y2Nlc3MgQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgaWYgdGhlIG9wcmF0aW9uXG4gICAgICogIHdhcyBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGRlZmluaW5nIHNwZWNpZmljIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW5kZXg9bnVsbF0gQW4gSURCSW5kZXggdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5rZXlSYW5nZT1udWxsXSBBbiBJREJLZXlSYW5nZSB0byB1c2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkVycm9yPXRocm93XSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiBhbiBlcnJvclxuICAgICAqICBvY2N1cnJlZCBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7SURCVHJhbnNhY3Rpb259IFRoZSB0cmFuc2FjdGlvbiB1c2VkIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBjb3VudDogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb3B0aW9ucykge1xuXG4gICAgICBvcHRpb25zID0gbWl4aW4oe1xuICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAga2V5UmFuZ2U6IG51bGxcbiAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICB2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0RXJyb3JIYW5kbGVyO1xuXG4gICAgICB2YXIgaGFzU3VjY2VzcyA9IGZhbHNlLFxuICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgIHZhciBjdXJzb3JUcmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgdGhpcy5jb25zdHMuUkVBRF9PTkxZKTtcbiAgICAgIGN1cnNvclRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGhhc1N1Y2Nlc3MgPyBvblN1Y2Nlc3MgOiBvbkVycm9yO1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIGN1cnNvclRyYW5zYWN0aW9uLm9uYWJvcnQgPSBvbkVycm9yO1xuICAgICAgY3Vyc29yVHJhbnNhY3Rpb24ub25lcnJvciA9IG9uRXJyb3I7XG5cbiAgICAgIHZhciBjdXJzb3JUYXJnZXQgPSBjdXJzb3JUcmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBpZiAob3B0aW9ucy5pbmRleCkge1xuICAgICAgICBjdXJzb3JUYXJnZXQgPSBjdXJzb3JUYXJnZXQuaW5kZXgob3B0aW9ucy5pbmRleCk7XG4gICAgICB9XG4gICAgICB2YXIgY291bnRSZXF1ZXN0ID0gY3Vyc29yVGFyZ2V0LmNvdW50KG9wdGlvbnMua2V5UmFuZ2UpO1xuICAgICAgY291bnRSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaGFzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGNvdW50UmVxdWVzdC5vbkVycm9yID0gb25FcnJvcjtcblxuICAgICAgcmV0dXJuIGN1cnNvclRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKioqKioqKioqKioqKiovXG4gICAgLyoga2V5IHJhbmdlcyAqL1xuICAgIC8qKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBrZXkgcmFuZ2UgdXNpbmcgc3BlY2lmaWVkIG9wdGlvbnMuIFRoaXMga2V5IHJhbmdlIGNhbiBiZVxuICAgICAqIGhhbmRlZCBvdmVyIHRvIHRoZSBjb3VudCgpIGFuZCBpdGVyYXRlKCkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9yIGJvdGggb2YgXCJsb3dlclwiIG9yIFwidXBwZXJcIiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUga2V5IHJhbmdlIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMubG93ZXJdIFRoZSBsb3dlciBib3VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXhjbHVkZUxvd2VyXSBXaGV0aGVyIHRvIGV4Y2x1ZGUgdGhlIGxvd2VyXG4gICAgICogIGJvdW5kIHBhc3NlZCBpbiBvcHRpb25zLmxvd2VyIGZyb20gdGhlIGtleSByYW5nZVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMudXBwZXJdIFRoZSB1cHBlciBib3VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXhjbHVkZVVwcGVyXSBXaGV0aGVyIHRvIGV4Y2x1ZGUgdGhlIHVwcGVyXG4gICAgICogIGJvdW5kIHBhc3NlZCBpbiBvcHRpb25zLnVwcGVyIGZyb20gdGhlIGtleSByYW5nZVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMub25seV0gQSBzaW5nbGUga2V5IHZhbHVlLiBVc2UgdGhpcyBpZiB5b3UgbmVlZCBhIGtleVxuICAgICAqICByYW5nZSB0aGF0IG9ubHkgaW5jbHVkZXMgb25lIHZhbHVlIGZvciBhIGtleS4gUHJvdmlkaW5nIHRoaXNcbiAgICAgKiAgcHJvcGVydHkgaW52YWxpZGF0ZXMgYWxsIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgSURCS2V5UmFuZ2UgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgb3B0aW9uc1xuICAgICAqL1xuICAgIG1ha2VLZXlSYW5nZTogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAvKmpzaGludCBvbmVjYXNlOnRydWUgKi9cbiAgICAgIHZhciBrZXlSYW5nZSxcbiAgICAgICAgICBoYXNMb3dlciA9IHR5cGVvZiBvcHRpb25zLmxvd2VyICE9ICd1bmRlZmluZWQnLFxuICAgICAgICAgIGhhc1VwcGVyID0gdHlwZW9mIG9wdGlvbnMudXBwZXIgIT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgaXNPbmx5ID0gdHlwZW9mIG9wdGlvbnMub25seSAhPSAndW5kZWZpbmVkJztcblxuICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICBjYXNlIGlzT25seTpcbiAgICAgICAgICBrZXlSYW5nZSA9IHRoaXMua2V5UmFuZ2Uub25seShvcHRpb25zLm9ubHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGhhc0xvd2VyICYmIGhhc1VwcGVyOlxuICAgICAgICAgIGtleVJhbmdlID0gdGhpcy5rZXlSYW5nZS5ib3VuZChvcHRpb25zLmxvd2VyLCBvcHRpb25zLnVwcGVyLCBvcHRpb25zLmV4Y2x1ZGVMb3dlciwgb3B0aW9ucy5leGNsdWRlVXBwZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGhhc0xvd2VyOlxuICAgICAgICAgIGtleVJhbmdlID0gdGhpcy5rZXlSYW5nZS5sb3dlckJvdW5kKG9wdGlvbnMubG93ZXIsIG9wdGlvbnMuZXhjbHVkZUxvd2VyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBoYXNVcHBlcjpcbiAgICAgICAgICBrZXlSYW5nZSA9IHRoaXMua2V5UmFuZ2UudXBwZXJCb3VuZChvcHRpb25zLnVwcGVyLCBvcHRpb25zLmV4Y2x1ZGVVcHBlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIEtleVJhbmdlLiBQcm92aWRlIG9uZSBvciBib3RoIG9mIFwibG93ZXJcIiBvciBcInVwcGVyXCIgdmFsdWUsIG9yIGFuIFwib25seVwiIHZhbHVlLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5UmFuZ2U7XG5cbiAgICB9XG5cbiAgfTtcblxuICAvKiogaGVscGVycyAqKi9cblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgfTtcbiAgdmFyIGVtcHR5ID0ge307XG4gIHZhciBtaXhpbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBuYW1lLCBzO1xuICAgIGZvciAobmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgIHMgPSBzb3VyY2VbbmFtZV07XG4gICAgICBpZiAocyAhPT0gZW1wdHlbbmFtZV0gJiYgcyAhPT0gdGFyZ2V0W25hbWVdKSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgSURCU3RvcmUudmVyc2lvbiA9IElEQlN0b3JlLnByb3RvdHlwZS52ZXJzaW9uO1xuXG4gIHJldHVybiBJREJTdG9yZTtcblxufSwgdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pZGItd3JhcHBlci9pZGJzdG9yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIxNy5qcyJ9");

/***/ },
/* 18 */
/*!************************************************************************!*\
  !*** ./~/backbone-filtered-collection/backbone-filtered-collection.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("(function (root, factory) {\n  if (true) {\n    module.exports = factory(__webpack_require__(/*! underscore */ 2), __webpack_require__(/*! backbone */ 1));\n  }\n  else if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'backbone'], factory);\n  }\n  else {\n    var globalAlias = 'FilteredCollection';\n    var namespace = globalAlias.split('.');\n    var parent = root;\n    for ( var i = 0; i < namespace.length-1; i++ ) {\n      if ( parent[namespace[i]] === undefined ) parent[namespace[i]] = {};\n      parent = parent[namespace[i]];\n    }\n    parent[namespace[namespace.length-1]] = factory(root['_'], root['Backbone']);\n  }\n}(this, function(_, Backbone) {\n  function _requireDep(name) {\n    return {'underscore': _, 'backbone': Backbone}[name];\n  }\n\n  var _bundleExports = (function (define) {\n    function _require(index) {\n        var module = _require.cache[index];\n        if (!module) {\n            var exports = {};\n            module = _require.cache[index] = {\n                id: index,\n                exports: exports\n            };\n            _require.modules[index].call(exports, module, exports);\n        }\n        return module.exports;\n    }\n    _require.cache = [];\n    _require.modules = [\n        function (module, exports) {\n            var _ = _requireDep('underscore');\n            var Backbone = _requireDep('backbone');\n            var proxyCollection = _require(1);\n            var createFilter = _require(2);\n            function invalidateCache() {\n                this._filterResultCache = {};\n            }\n            function invalidateCacheForFilter(filterName) {\n                for (var cid in this._filterResultCache) {\n                    if (this._filterResultCache.hasOwnProperty(cid)) {\n                        delete this._filterResultCache[cid][filterName];\n                    }\n                }\n            }\n            function addFilter(filterName, filterObj) {\n                if (this._filters[filterName]) {\n                    invalidateCacheForFilter.call(this, filterName);\n                }\n                this._filters[filterName] = filterObj;\n                this.trigger('filtered:add', filterName);\n            }\n            function removeFilter(filterName) {\n                delete this._filters[filterName];\n                invalidateCacheForFilter.call(this, filterName);\n                this.trigger('filtered:remove', filterName);\n            }\n            function execFilterOnModel(model) {\n                if (!this._filterResultCache[model.cid]) {\n                    this._filterResultCache[model.cid] = {};\n                }\n                var cache = this._filterResultCache[model.cid];\n                for (var filterName in this._filters) {\n                    if (this._filters.hasOwnProperty(filterName)) {\n                        if (!cache.hasOwnProperty(filterName)) {\n                            cache[filterName] = this._filters[filterName].fn(model);\n                        }\n                        if (!cache[filterName]) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            function execFilter() {\n                var filtered = [];\n                if (this._superset) {\n                    filtered = this._superset.filter(_.bind(execFilterOnModel, this));\n                }\n                this._collection.reset(filtered);\n                this.length = this._collection.length;\n            }\n            function onAddChange(model) {\n                this._filterResultCache[model.cid] = {};\n                if (execFilterOnModel.call(this, model)) {\n                    if (!this._collection.get(model.cid)) {\n                        var index = this.superset().indexOf(model);\n                        var filteredIndex = null;\n                        for (var i = index - 1; i >= 0; i -= 1) {\n                            if (this.contains(this.superset().at(i))) {\n                                filteredIndex = this.indexOf(this.superset().at(i)) + 1;\n                                break;\n                            }\n                        }\n                        filteredIndex = filteredIndex || 0;\n                        this._collection.add(model, { at: filteredIndex });\n                    }\n                } else {\n                    if (this._collection.get(model.cid)) {\n                        this._collection.remove(model);\n                    }\n                }\n                this.length = this._collection.length;\n            }\n            function onModelAttributeChange(model) {\n                this._filterResultCache[model.cid] = {};\n                if (!execFilterOnModel.call(this, model)) {\n                    if (this._collection.get(model.cid)) {\n                        this._collection.remove(model);\n                    }\n                }\n            }\n            function onAll(eventName, model, value) {\n                if (eventName.slice(0, 7) === 'change:') {\n                    onModelAttributeChange.call(this, arguments[1]);\n                }\n            }\n            function onModelRemove(model) {\n                if (this.contains(model)) {\n                    this._collection.remove(model);\n                }\n                this.length = this._collection.length;\n            }\n            function Filtered(superset) {\n                this._superset = superset;\n                this._collection = new Backbone.Collection(superset.toArray());\n                proxyCollection(this._collection, this);\n                this.resetFilters();\n                this.listenTo(this._superset, 'reset sort', execFilter);\n                this.listenTo(this._superset, 'add change', onAddChange);\n                this.listenTo(this._superset, 'remove', onModelRemove);\n                this.listenTo(this._superset, 'all', onAll);\n            }\n            var methods = {\n                    defaultFilterName: '__default',\n                    filterBy: function (filterName, filter) {\n                        if (!filter) {\n                            filter = filterName;\n                            filterName = this.defaultFilterName;\n                        }\n                        addFilter.call(this, filterName, createFilter(filter));\n                        execFilter.call(this);\n                        return this;\n                    },\n                    removeFilter: function (filterName) {\n                        if (!filterName) {\n                            filterName = this.defaultFilterName;\n                        }\n                        removeFilter.call(this, filterName);\n                        execFilter.call(this);\n                        return this;\n                    },\n                    resetFilters: function () {\n                        this._filters = {};\n                        invalidateCache.call(this);\n                        this.trigger('filtered:reset');\n                        execFilter.call(this);\n                        return this;\n                    },\n                    superset: function () {\n                        return this._superset;\n                    },\n                    refilter: function (arg) {\n                        if (typeof arg === 'object' && arg.cid) {\n                            onAddChange.call(this, arg);\n                        } else {\n                            invalidateCache.call(this);\n                            execFilter.call(this);\n                        }\n                        return this;\n                    },\n                    getFilters: function () {\n                        return _.keys(this._filters);\n                    },\n                    hasFilter: function (name) {\n                        return _.contains(this.getFilters(), name);\n                    },\n                    destroy: function () {\n                        this.stopListening();\n                        this._collection.reset([]);\n                        this._superset = this._collection;\n                        this.length = 0;\n                        this.trigger('filtered:destroy');\n                    }\n                };\n            _.extend(Filtered.prototype, methods, Backbone.Events);\n            module.exports = Filtered;\n        },\n        function (module, exports) {\n            var _ = _requireDep('underscore');\n            var Backbone = _requireDep('backbone');\n            var blacklistedMethods = [\n                    '_onModelEvent',\n                    '_prepareModel',\n                    '_removeReference',\n                    '_reset',\n                    'add',\n                    'initialize',\n                    'sync',\n                    'remove',\n                    'reset',\n                    'set',\n                    'push',\n                    'pop',\n                    'unshift',\n                    'shift',\n                    'sort',\n                    'parse',\n                    'fetch',\n                    'create',\n                    'model',\n                    'off',\n                    'on',\n                    'listenTo',\n                    'listenToOnce',\n                    'bind',\n                    'trigger',\n                    'once',\n                    'stopListening'\n                ];\n            var eventWhiteList = [\n                    'add',\n                    'remove',\n                    'reset',\n                    'sort',\n                    'destroy',\n                    'sync',\n                    'request',\n                    'error'\n                ];\n            function proxyCollection(from, target) {\n                function updateLength() {\n                    target.length = from.length;\n                }\n                function pipeEvents(eventName) {\n                    var args = _.toArray(arguments);\n                    var isChangeEvent = eventName === 'change' || eventName.slice(0, 7) === 'change:';\n                    if (eventName === 'reset') {\n                        target.models = from.models;\n                    }\n                    if (_.contains(eventWhiteList, eventName)) {\n                        if (_.contains([\n                                'add',\n                                'remove',\n                                'destroy'\n                            ], eventName)) {\n                            args[2] = target;\n                        } else if (_.contains([\n                                'reset',\n                                'sort'\n                            ], eventName)) {\n                            args[1] = target;\n                        }\n                        target.trigger.apply(this, args);\n                    } else if (isChangeEvent) {\n                        if (target.contains(args[1])) {\n                            target.trigger.apply(this, args);\n                        }\n                    }\n                }\n                var methods = {};\n                _.each(_.functions(Backbone.Collection.prototype), function (method) {\n                    if (!_.contains(blacklistedMethods, method)) {\n                        methods[method] = function () {\n                            return from[method].apply(from, arguments);\n                        };\n                    }\n                });\n                _.extend(target, Backbone.Events, methods);\n                target.listenTo(from, 'all', updateLength);\n                target.listenTo(from, 'all', pipeEvents);\n                target.models = from.models;\n                updateLength();\n                return target;\n            }\n            module.exports = proxyCollection;\n        },\n        function (module, exports) {\n            var _ = _requireDep('underscore');\n            function convertKeyValueToFunction(key, value) {\n                return function (model) {\n                    return model.get(key) === value;\n                };\n            }\n            function convertKeyFunctionToFunction(key, fn) {\n                return function (model) {\n                    return fn(model.get(key));\n                };\n            }\n            function createFilterObject(filterFunction, keys) {\n                if (!_.isArray(keys)) {\n                    keys = null;\n                }\n                return {\n                    fn: filterFunction,\n                    keys: keys\n                };\n            }\n            function createFilterFromObject(filterObj) {\n                var keys = _.keys(filterObj);\n                var filterFunctions = _.map(keys, function (key) {\n                        var val = filterObj[key];\n                        if (_.isFunction(val)) {\n                            return convertKeyFunctionToFunction(key, val);\n                        }\n                        return convertKeyValueToFunction(key, val);\n                    });\n                var filterFunction = function (model) {\n                    for (var i = 0; i < filterFunctions.length; i++) {\n                        if (!filterFunctions[i](model)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n                return createFilterObject(filterFunction, keys);\n            }\n            function createFilter(filter, keys) {\n                if (_.isFunction(filter)) {\n                    return createFilterObject(filter, keys);\n                }\n                if (_.isObject(filter)) {\n                    return createFilterFromObject(filter);\n                }\n            }\n            module.exports = createFilter;\n        }\n    ];\n    return  _require(0);\n}());\n\n  return _bundleExports;\n}));//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLWZpbHRlcmVkLWNvbGxlY3Rpb24vYmFja2JvbmUtZmlsdGVyZWQtY29sbGVjdGlvbi5qcz8zYWVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndW5kZXJzY29yZScpLCByZXF1aXJlKCdiYWNrYm9uZScpKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2JhY2tib25lJ10sIGZhY3RvcnkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBnbG9iYWxBbGlhcyA9ICdGaWx0ZXJlZENvbGxlY3Rpb24nO1xuICAgIHZhciBuYW1lc3BhY2UgPSBnbG9iYWxBbGlhcy5zcGxpdCgnLicpO1xuICAgIHZhciBwYXJlbnQgPSByb290O1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGgtMTsgaSsrICkge1xuICAgICAgaWYgKCBwYXJlbnRbbmFtZXNwYWNlW2ldXSA9PT0gdW5kZWZpbmVkICkgcGFyZW50W25hbWVzcGFjZVtpXV0gPSB7fTtcbiAgICAgIHBhcmVudCA9IHBhcmVudFtuYW1lc3BhY2VbaV1dO1xuICAgIH1cbiAgICBwYXJlbnRbbmFtZXNwYWNlW25hbWVzcGFjZS5sZW5ndGgtMV1dID0gZmFjdG9yeShyb290WydfJ10sIHJvb3RbJ0JhY2tib25lJ10pO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKF8sIEJhY2tib25lKSB7XG4gIGZ1bmN0aW9uIF9yZXF1aXJlRGVwKG5hbWUpIHtcbiAgICByZXR1cm4geyd1bmRlcnNjb3JlJzogXywgJ2JhY2tib25lJzogQmFja2JvbmV9W25hbWVdO1xuICB9XG5cbiAgdmFyIF9idW5kbGVFeHBvcnRzID0gKGZ1bmN0aW9uIChkZWZpbmUpIHtcbiAgICBmdW5jdGlvbiBfcmVxdWlyZShpbmRleCkge1xuICAgICAgICB2YXIgbW9kdWxlID0gX3JlcXVpcmUuY2FjaGVbaW5kZXhdO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAgICAgICAgIG1vZHVsZSA9IF9yZXF1aXJlLmNhY2hlW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9yZXF1aXJlLm1vZHVsZXNbaW5kZXhdLmNhbGwoZXhwb3J0cywgbW9kdWxlLCBleHBvcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gICAgfVxuICAgIF9yZXF1aXJlLmNhY2hlID0gW107XG4gICAgX3JlcXVpcmUubW9kdWxlcyA9IFtcbiAgICAgICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIF8gPSBfcmVxdWlyZURlcCgndW5kZXJzY29yZScpO1xuICAgICAgICAgICAgdmFyIEJhY2tib25lID0gX3JlcXVpcmVEZXAoJ2JhY2tib25lJyk7XG4gICAgICAgICAgICB2YXIgcHJveHlDb2xsZWN0aW9uID0gX3JlcXVpcmUoMSk7XG4gICAgICAgICAgICB2YXIgY3JlYXRlRmlsdGVyID0gX3JlcXVpcmUoMik7XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyUmVzdWx0Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUZvckZpbHRlcihmaWx0ZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2lkIGluIHRoaXMuX2ZpbHRlclJlc3VsdENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWx0ZXJSZXN1bHRDYWNoZS5oYXNPd25Qcm9wZXJ0eShjaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmlsdGVyUmVzdWx0Q2FjaGVbY2lkXVtmaWx0ZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZEZpbHRlcihmaWx0ZXJOYW1lLCBmaWx0ZXJPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsdGVyc1tmaWx0ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVGb3JGaWx0ZXIuY2FsbCh0aGlzLCBmaWx0ZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tmaWx0ZXJOYW1lXSA9IGZpbHRlck9iajtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZpbHRlcmVkOmFkZCcsIGZpbHRlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRmlsdGVyKGZpbHRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmlsdGVyc1tmaWx0ZXJOYW1lXTtcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVGb3JGaWx0ZXIuY2FsbCh0aGlzLCBmaWx0ZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZpbHRlcmVkOnJlbW92ZScsIGZpbHRlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZXhlY0ZpbHRlck9uTW9kZWwobW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlclJlc3VsdENhY2hlW21vZGVsLmNpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyUmVzdWx0Q2FjaGVbbW9kZWwuY2lkXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9maWx0ZXJSZXN1bHRDYWNoZVttb2RlbC5jaWRdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpbHRlck5hbWUgaW4gdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsdGVycy5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlW2ZpbHRlck5hbWVdID0gdGhpcy5fZmlsdGVyc1tmaWx0ZXJOYW1lXS5mbihtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlW2ZpbHRlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZXhlY0ZpbHRlcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3VwZXJzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSB0aGlzLl9zdXBlcnNldC5maWx0ZXIoXy5iaW5kKGV4ZWNGaWx0ZXJPbk1vZGVsLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucmVzZXQoZmlsdGVyZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkFkZENoYW5nZShtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlclJlc3VsdENhY2hlW21vZGVsLmNpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoZXhlY0ZpbHRlck9uTW9kZWwuY2FsbCh0aGlzLCBtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsZWN0aW9uLmdldChtb2RlbC5jaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnN1cGVyc2V0KCkuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKHRoaXMuc3VwZXJzZXQoKS5hdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRJbmRleCA9IHRoaXMuaW5kZXhPZih0aGlzLnN1cGVyc2V0KCkuYXQoaSkpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRJbmRleCA9IGZpbHRlcmVkSW5kZXggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24uYWRkKG1vZGVsLCB7IGF0OiBmaWx0ZXJlZEluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24uZ2V0KG1vZGVsLmNpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2NvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25Nb2RlbEF0dHJpYnV0ZUNoYW5nZShtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlclJlc3VsdENhY2hlW21vZGVsLmNpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNGaWx0ZXJPbk1vZGVsLmNhbGwodGhpcywgbW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uLmdldChtb2RlbC5jaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uLnJlbW92ZShtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkFsbChldmVudE5hbWUsIG1vZGVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUuc2xpY2UoMCwgNykgPT09ICdjaGFuZ2U6Jykge1xuICAgICAgICAgICAgICAgICAgICBvbk1vZGVsQXR0cmlidXRlQ2hhbmdlLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vZGVsUmVtb3ZlKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnMobW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLl9jb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbHRlcmVkKHN1cGVyc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VwZXJzZXQgPSBzdXBlcnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oc3VwZXJzZXQudG9BcnJheSgpKTtcbiAgICAgICAgICAgICAgICBwcm94eUNvbGxlY3Rpb24odGhpcy5fY29sbGVjdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZpbHRlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3N1cGVyc2V0LCAncmVzZXQgc29ydCcsIGV4ZWNGaWx0ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5fc3VwZXJzZXQsICdhZGQgY2hhbmdlJywgb25BZGRDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5fc3VwZXJzZXQsICdyZW1vdmUnLCBvbk1vZGVsUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3N1cGVyc2V0LCAnYWxsJywgb25BbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRGaWx0ZXJOYW1lOiAnX19kZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyQnk6IGZ1bmN0aW9uIChmaWx0ZXJOYW1lLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJOYW1lID0gdGhpcy5kZWZhdWx0RmlsdGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZpbHRlci5jYWxsKHRoaXMsIGZpbHRlck5hbWUsIGNyZWF0ZUZpbHRlcihmaWx0ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNGaWx0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uIChmaWx0ZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJOYW1lID0gdGhpcy5kZWZhdWx0RmlsdGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUZpbHRlci5jYWxsKHRoaXMsIGZpbHRlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0ZpbHRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0RmlsdGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZUNhY2hlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZpbHRlcmVkOnJlc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjRmlsdGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdXBlcnNldDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVmaWx0ZXI6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcuY2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25BZGRDaGFuZ2UuY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjRmlsdGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RmlsdGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ua2V5cyh0aGlzLl9maWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRmlsdGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uY29udGFpbnModGhpcy5nZXRGaWx0ZXJzKCksIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucmVzZXQoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VwZXJzZXQgPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmaWx0ZXJlZDpkZXN0cm95Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXy5leHRlbmQoRmlsdGVyZWQucHJvdG90eXBlLCBtZXRob2RzLCBCYWNrYm9uZS5FdmVudHMpO1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIF8gPSBfcmVxdWlyZURlcCgndW5kZXJzY29yZScpO1xuICAgICAgICAgICAgdmFyIEJhY2tib25lID0gX3JlcXVpcmVEZXAoJ2JhY2tib25lJyk7XG4gICAgICAgICAgICB2YXIgYmxhY2tsaXN0ZWRNZXRob2RzID0gW1xuICAgICAgICAgICAgICAgICAgICAnX29uTW9kZWxFdmVudCcsXG4gICAgICAgICAgICAgICAgICAgICdfcHJlcGFyZU1vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ19yZW1vdmVSZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgICAgICAnX3Jlc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICdpbml0aWFsaXplJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bmMnLFxuICAgICAgICAgICAgICAgICAgICAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Jlc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICdwdXNoJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BvcCcsXG4gICAgICAgICAgICAgICAgICAgICd1bnNoaWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3NoaWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3NvcnQnLFxuICAgICAgICAgICAgICAgICAgICAncGFyc2UnLFxuICAgICAgICAgICAgICAgICAgICAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICAnY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ21vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ29mZicsXG4gICAgICAgICAgICAgICAgICAgICdvbicsXG4gICAgICAgICAgICAgICAgICAgICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgICdsaXN0ZW5Ub09uY2UnLFxuICAgICAgICAgICAgICAgICAgICAnYmluZCcsXG4gICAgICAgICAgICAgICAgICAgICd0cmlnZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgJ29uY2UnLFxuICAgICAgICAgICAgICAgICAgICAnc3RvcExpc3RlbmluZydcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGV2ZW50V2hpdGVMaXN0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgICdyZXNldCcsXG4gICAgICAgICAgICAgICAgICAgICdzb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2Rlc3Ryb3knLFxuICAgICAgICAgICAgICAgICAgICAnc3luYycsXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm94eUNvbGxlY3Rpb24oZnJvbSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlTGVuZ3RoKCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gZnJvbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVFdmVudHMoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NoYW5nZUV2ZW50ID0gZXZlbnROYW1lID09PSAnY2hhbmdlJyB8fCBldmVudE5hbWUuc2xpY2UoMCwgNykgPT09ICdjaGFuZ2U6JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm1vZGVscyA9IGZyb20ubW9kZWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmNvbnRhaW5zKGV2ZW50V2hpdGVMaXN0LCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5jb250YWlucyhbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhZGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Rlc3Ryb3knXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uY29udGFpbnMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc29ydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMoYXJnc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudHJpZ2dlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZSksIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGJsYWNrbGlzdGVkTWV0aG9kcywgbWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tW21ldGhvZF0uYXBwbHkoZnJvbSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmV4dGVuZCh0YXJnZXQsIEJhY2tib25lLkV2ZW50cywgbWV0aG9kcyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmxpc3RlblRvKGZyb20sICdhbGwnLCB1cGRhdGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5saXN0ZW5Ubyhmcm9tLCAnYWxsJywgcGlwZUV2ZW50cyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1vZGVscyA9IGZyb20ubW9kZWxzO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3h5Q29sbGVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIF8gPSBfcmVxdWlyZURlcCgndW5kZXJzY29yZScpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY29udmVydEtleVZhbHVlVG9GdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KGtleSkgPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0S2V5RnVuY3Rpb25Ub0Z1bmN0aW9uKGtleSwgZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihtb2RlbC5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbHRlck9iamVjdChmaWx0ZXJGdW5jdGlvbiwga2V5cykge1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmbjogZmlsdGVyRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyRnJvbU9iamVjdChmaWx0ZXJPYmopIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhmaWx0ZXJPYmopO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJGdW5jdGlvbnMgPSBfLm1hcChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZmlsdGVyT2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydEtleUZ1bmN0aW9uVG9GdW5jdGlvbihrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydEtleVZhbHVlVG9GdW5jdGlvbihrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJGdW5jdGlvbnNbaV0obW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbHRlck9iamVjdChmaWx0ZXJGdW5jdGlvbiwga2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsdGVyLCBrZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWx0ZXJPYmplY3QoZmlsdGVyLCBrZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmlsdGVyRnJvbU9iamVjdChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmlsdGVyO1xuICAgICAgICB9XG4gICAgXTtcbiAgICByZXR1cm4gIF9yZXF1aXJlKDApO1xufSgpKTtcblxuICByZXR1cm4gX2J1bmRsZUV4cG9ydHM7XG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja2JvbmUtZmlsdGVyZWQtY29sbGVjdGlvbi9iYWNrYm9uZS1maWx0ZXJlZC1jb2xsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjE4LmpzIn0=");

/***/ },
/* 19 */,
/* 20 */,
/* 21 */
/*!**************************************************!*\
  !*** ./~/backbone.syphon/lib/backbone.syphon.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ 2), __webpack_require__(/*! backbone */ 1), __webpack_require__(/*! jquery */ 24)], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, Backbone, $) {\n      return factory(_, Backbone, $);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var Backbone = require('backbone');\n    var $ = require('jquery');\n    module.exports = factory(_, Backbone, $);\n  } else {\n    factory(root._, root.Backbone, root.jQuery);\n  }\n\n}(this, function(_, Backbone, $) {\n  'use strict';\n\n  var previousSyphon = Backbone.Syphon;\n\n  var Syphon = Backbone.Syphon = {};\n\n  Syphon.VERSION = '0.5.0';\n\n  Syphon.noConflict = function() {\n    Backbone.Syphon = previousSyphon;\n    return this;\n  };\n\n  /* jshint maxstatements: 13, maxlen: 102, maxcomplexity: 8, latedef: false */\n  \n  // Ignore Element Types\n  // --------------------\n  \n  // Tell Syphon to ignore all elements of these types. You can\n  // push new types to ignore directly in to this array.\n  Syphon.ignoredTypes = ['button', 'submit', 'reset', 'fieldset'];\n  \n  // Syphon\n  // ------\n  \n  // Get a JSON object that represents\n  // all of the form inputs, in this view.\n  // Alternately, pass a form element directly\n  // in place of the view.\n  Syphon.serialize = function(view, options){\n    var data = {};\n  \n    // Build the configuration\n    var config = buildConfig(options);\n  \n    // Get all of the elements to process\n    var elements = getInputElements(view, config);\n  \n    // Process all of the elements\n    _.each(elements, function(el){\n      var $el = $(el);\n      var type = getElementType($el);\n  \n      // Get the key for the input\n      var keyExtractor = config.keyExtractors.get(type);\n      var key = keyExtractor($el);\n  \n      // Get the value for the input\n      var inputReader = config.inputReaders.get(type);\n      var value = inputReader($el);\n  \n      // Get the key assignment validator and make sure\n      // it's valid before assigning the value to the key\n      var validKeyAssignment = config.keyAssignmentValidators.get(type);\n      if (validKeyAssignment($el, key, value)){\n        var keychain = config.keySplitter(key);\n        data = assignKeyValue(data, keychain, value);\n      }\n    });\n  \n    // Done; send back the results.\n    return data;\n  };\n  \n  // Use the given JSON object to populate\n  // all of the form inputs, in this view.\n  // Alternately, pass a form element directly\n  // in place of the view.\n  Syphon.deserialize = function(view, data, options){\n    // Build the configuration\n    var config = buildConfig(options);\n  \n    // Get all of the elements to process\n    var elements = getInputElements(view, config);\n  \n    // Flatten the data structure that we are deserializing\n    var flattenedData = flattenData(config, data);\n  \n    // Process all of the elements\n    _.each(elements, function(el){\n      var $el = $(el);\n      var type = getElementType($el);\n  \n      // Get the key for the input\n      var keyExtractor = config.keyExtractors.get(type);\n      var key = keyExtractor($el);\n  \n      // Get the input writer and the value to write\n      var inputWriter = config.inputWriters.get(type);\n      var value = flattenedData[key];\n  \n      // Write the value to the input\n      inputWriter($el, value);\n    });\n  };\n  \n  // Helpers\n  // -------\n  \n  // Retrieve all of the form inputs\n  // from the form\n  var getInputElements = function(view, config){\n    var form = getForm(view);\n    var elements = form.elements;\n  \n    elements = _.reject(elements, function(el){\n      var reject;\n      var type = getElementType(el);\n      var extractor = config.keyExtractors.get(type);\n      var identifier = extractor($(el));\n  \n      var foundInIgnored = _.include(config.ignoredTypes, type);\n      var foundInInclude = _.include(config.include, identifier);\n      var foundInExclude = _.include(config.exclude, identifier);\n  \n      if (foundInInclude){\n        reject = false;\n      } else {\n        if (config.include){\n          reject = true;\n        } else {\n          reject = (foundInExclude || foundInIgnored);\n        }\n      }\n  \n      return reject;\n    });\n  \n    return elements;\n  };\n  \n  // Determine what type of element this is. It\n  // will either return the `type` attribute of\n  // an `<input>` element, or the `tagName` of\n  // the element when the element is not an `<input>`.\n  var getElementType = function(el){\n    var typeAttr;\n    var $el = $(el);\n    var tagName = $el[0].tagName;\n    var type = tagName;\n  \n    if (tagName.toLowerCase() === 'input'){\n      typeAttr = $el.attr('type');\n      if (typeAttr){\n        type = typeAttr;\n      } else {\n        type = 'text';\n      }\n    }\n  \n    // Always return the type as lowercase\n    // so it can be matched to lowercase\n    // type registrations.\n    return type.toLowerCase();\n  };\n  \n  // If a form element is given, just return it.\n  // Otherwise, get the form element from the view.\n  var getForm = function(viewOrForm){\n    if (_.isUndefined(viewOrForm.$el) && viewOrForm.tagName.toLowerCase() === 'form'){\n      return viewOrForm;\n    } else {\n      return viewOrForm.$el.is('form') ? viewOrForm.el : viewOrForm.$('form')[0];\n    }\n  };\n  \n  // Build a configuration object and initialize\n  // default values.\n  var buildConfig = function(options){\n    var config = _.clone(options) || {};\n  \n    config.ignoredTypes = _.clone(Syphon.ignoredTypes);\n    config.inputReaders = config.inputReaders || Syphon.InputReaders;\n    config.inputWriters = config.inputWriters || Syphon.InputWriters;\n    config.keyExtractors = config.keyExtractors || Syphon.KeyExtractors;\n    config.keySplitter = config.keySplitter || Syphon.KeySplitter;\n    config.keyJoiner = config.keyJoiner || Syphon.KeyJoiner;\n    config.keyAssignmentValidators = config.keyAssignmentValidators || Syphon.KeyAssignmentValidators;\n  \n    return config;\n  };\n  \n  // Assigns `value` to a parsed JSON key.\n  //\n  // The first parameter is the object which will be\n  // modified to store the key/value pair.\n  //\n  // The second parameter accepts an array of keys as a\n  // string with an option array containing a\n  // single string as the last option.\n  //\n  // The third parameter is the value to be assigned.\n  //\n  // Examples:\n  //\n  // `['foo', 'bar', 'baz'] => {foo: {bar: {baz: 'value'}}}`\n  //\n  // `['foo', 'bar', ['baz']] => {foo: {bar: {baz: ['value']}}}`\n  //\n  // When the final value is an array with a string, the key\n  // becomes an array, and values are pushed in to the array,\n  // allowing multiple fields with the same name to be\n  // assigned to the array.\n  var assignKeyValue = function(obj, keychain, value) {\n    if (!keychain){ return obj; }\n  \n    var key = keychain.shift();\n  \n    // build the current object we need to store data\n    if (!obj[key]){\n      obj[key] = _.isArray(key) ? [] : {};\n    }\n  \n    // if it's the last key in the chain, assign the value directly\n    if (keychain.length === 0){\n      if (_.isArray(obj[key])){\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n  \n    // recursive parsing of the array, depth-first\n    if (keychain.length > 0){\n      assignKeyValue(obj[key], keychain, value);\n    }\n  \n    return obj;\n  };\n  \n  // Flatten the data structure in to nested strings, using the\n  // provided `KeyJoiner` function.\n  //\n  // Example:\n  //\n  // This input:\n  //\n  // ```js\n  // {\n  //   widget: 'wombat',\n  //   foo: {\n  //     bar: 'baz',\n  //     baz: {\n  //       quux: 'qux'\n  //     },\n  //     quux: ['foo', 'bar']\n  //   }\n  // }\n  // ```\n  //\n  // With a KeyJoiner that uses [ ] square brackets,\n  // should produce this output:\n  //\n  // ```js\n  // {\n  //  'widget': 'wombat',\n  //  'foo[bar]': 'baz',\n  //  'foo[baz][quux]': 'qux',\n  //  'foo[quux]': ['foo', 'bar']\n  // }\n  // ```\n  var flattenData = function(config, data, parentKey){\n    var flatData = {};\n  \n    _.each(data, function(value, keyName){\n      var hash = {};\n  \n      // If there is a parent key, join it with\n      // the current, child key.\n      if (parentKey){\n        keyName = config.keyJoiner(parentKey, keyName);\n      }\n  \n      if (_.isArray(value)){\n        keyName += '[]';\n        hash[keyName] = value;\n      } else if (_.isObject(value)){\n        hash = flattenData(config, value, keyName);\n      } else {\n        hash[keyName] = value;\n      }\n  \n      // Store the resulting key/value pairs in the\n      // final flattened data object\n      _.extend(flatData, hash);\n    });\n  \n    return flatData;\n  };\n  \n  // Type Registry\n  // -------------\n  \n  // Type Registries allow you to register something to\n  // an input type, and retrieve either the item registered\n  // for a specific type or the default registration\n  var TypeRegistry = Syphon.TypeRegistry = function() {\n    this.registeredTypes = {};\n  };\n  \n  // Borrow Backbone's `extend` keyword for our TypeRegistry\n  TypeRegistry.extend = Backbone.Model.extend;\n  \n  _.extend(TypeRegistry.prototype, {\n  \n    // Get the registered item by type. If nothing is\n    // found for the specified type, the default is\n    // returned.\n    get: function(type){\n      return this.registeredTypes[type] || this.registeredTypes['default'];\n    },\n  \n    // Register a new item for a specified type\n    register: function(type, item) {\n      this.registeredTypes[type] = item;\n    },\n  \n    // Register a default item to be used when no\n    // item for a specified type is found\n    registerDefault: function(item) {\n      this.registeredTypes['default'] = item;\n    },\n  \n    // Remove an item from a given type registration\n    unregister: function(type) {\n      if (this.registeredTypes[type]) {\n        delete this.registeredTypes[type];\n      }\n    }\n  });\n  \n  // Key Extractors\n  // --------------\n  \n  // Key extractors produce the \"key\" in `{key: \"value\"}`\n  // pairs, when serializing.\n  var KeyExtractorSet = Syphon.KeyExtractorSet = TypeRegistry.extend();\n  \n  // Built-in Key Extractors\n  var KeyExtractors = Syphon.KeyExtractors = new KeyExtractorSet();\n  \n  // The default key extractor, which uses the\n  // input element's \"name\" attribute\n  KeyExtractors.registerDefault(function($el) {\n    return $el.prop('name') || '';\n  });\n  \n  // Input Readers\n  // -------------\n  \n  // Input Readers are used to extract the value from\n  // an input element, for the serialized object result\n  var InputReaderSet = Syphon.InputReaderSet = TypeRegistry.extend();\n  \n  // Built-in Input Readers\n  var InputReaders = Syphon.InputReaders = new InputReaderSet();\n  \n  // The default input reader, which uses an input\n  // element's \"value\"\n  InputReaders.registerDefault(function($el){\n    return $el.val();\n  });\n  \n  // Checkbox reader, returning a boolean value for\n  // whether or not the checkbox is checked.\n  InputReaders.register('checkbox', function($el) {\n    return $el.prop('checked');\n  });\n  \n  // Input Writers\n  // -------------\n  \n  // Input Writers are used to insert a value from an\n  // object into an input element.\n  var InputWriterSet = Syphon.InputWriterSet = TypeRegistry.extend();\n  \n  // Built-in Input Writers\n  var InputWriters = Syphon.InputWriters = new InputWriterSet();\n  \n  // The default input writer, which sets an input\n  // element's \"value\"\n  InputWriters.registerDefault(function($el, value) {\n    $el.val(value);\n  });\n  \n  // Checkbox writer, set whether or not the checkbox is checked\n  // depending on the boolean value.\n  InputWriters.register('checkbox', function($el, value) {\n    $el.prop('checked', value);\n  });\n  \n  // Radio button writer, set whether or not the radio button is\n  // checked.  The button should only be checked if it's value\n  // equals the given value.\n  InputWriters.register('radio', function($el, value) {\n    $el.prop('checked', $el.val() === value.toString());\n  });\n  \n  // Key Assignment Validators\n  // -------------------------\n  \n  // Key Assignment Validators are used to determine whether or not a\n  // key should be assigned to a value, after the key and value have been\n  // extracted from the element. This is the last opportunity to prevent\n  // bad data from getting serialized to your object.\n  \n  var KeyAssignmentValidatorSet = Syphon.KeyAssignmentValidatorSet = TypeRegistry.extend();\n  \n  // Build-in Key Assignment Validators\n  var KeyAssignmentValidators = Syphon.KeyAssignmentValidators = new KeyAssignmentValidatorSet();\n  \n  // Everything is valid by default\n  KeyAssignmentValidators.registerDefault(function() {\n    return true;\n  });\n  \n  // But only the \"checked\" radio button for a given\n  // radio button group is valid\n  KeyAssignmentValidators.register('radio', function($el, key, value) {\n    return $el.prop('checked');\n  });\n  \n  // Backbone.Syphon.KeySplitter\n  // ---------------------------\n  \n  // This function is used to split DOM element keys in to an array\n  // of parts, which are then used to create a nested result structure.\n  // returning `[\"foo\", \"bar\"]` results in `{foo: { bar: \"value\" }}`.\n  //\n  // Override this method to use a custom key splitter, such as:\n  // `<input name=\"foo.bar.baz\">`, `return key.split(\".\")`\n  Syphon.KeySplitter = function(key) {\n    var matches = key.match(/[^\\[\\]]+/g);\n    var lastKey;\n  \n    if (key.indexOf('[]') === key.length - 2) {\n      lastKey = matches.pop();\n      matches.push([lastKey]);\n    }\n  \n    return matches;\n  };\n  \n  // Backbone.Syphon.KeyJoiner\n  // -------------------------\n  \n  // Take two segments of a key and join them together, to create the\n  // de-normalized key name, when deserializing a data structure back\n  // in to a form.\n  //\n  // Example:\n  //\n  // With this data strucutre `{foo: { bar: {baz: \"value\", quux: \"another\"} } }`,\n  // the key joiner will be called with these parameters, and assuming the\n  // join happens with \"[ ]\" square brackets, the specified output:\n  //\n  // `KeyJoiner(\"foo\", \"bar\")` //=> \"foo[bar]\"\n  // `KeyJoiner(\"foo[bar]\", \"baz\")` //=> \"foo[bar][baz]\"\n  // `KeyJoiner(\"foo[bar]\", \"quux\")` //=> \"foo[bar][quux]\"\n  \n  Syphon.KeyJoiner = function(parentKey, childKey) {\n    return parentKey + '[' + childKey + ']';\n  };\n  \n\n  return Backbone.Syphon;\n}));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLnN5cGhvbi9saWIvYmFja2JvbmUuc3lwaG9uLmpzPzUzZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNLE1BQU0sZUFBZTtBQUMzRDtBQUNBLGtDQUFrQyxNQUFNLE1BQU0saUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU0sT0FBTyw4QkFBOEIsRUFBRSxFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnYmFja2JvbmUnLCAnanF1ZXJ5J10sIGZ1bmN0aW9uKF8sIEJhY2tib25lLCAkKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShfLCBCYWNrYm9uZSwgJCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgdmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbiAgICB2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfLCBCYWNrYm9uZSwgJCk7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeShyb290Ll8sIHJvb3QuQmFja2JvbmUsIHJvb3QualF1ZXJ5KTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uKF8sIEJhY2tib25lLCAkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcHJldmlvdXNTeXBob24gPSBCYWNrYm9uZS5TeXBob247XG5cbiAgdmFyIFN5cGhvbiA9IEJhY2tib25lLlN5cGhvbiA9IHt9O1xuXG4gIFN5cGhvbi5WRVJTSU9OID0gJzAuNS4wJztcblxuICBTeXBob24ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIEJhY2tib25lLlN5cGhvbiA9IHByZXZpb3VzU3lwaG9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAxMywgbWF4bGVuOiAxMDIsIG1heGNvbXBsZXhpdHk6IDgsIGxhdGVkZWY6IGZhbHNlICovXG4gIFxuICAvLyBJZ25vcmUgRWxlbWVudCBUeXBlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gVGVsbCBTeXBob24gdG8gaWdub3JlIGFsbCBlbGVtZW50cyBvZiB0aGVzZSB0eXBlcy4gWW91IGNhblxuICAvLyBwdXNoIG5ldyB0eXBlcyB0byBpZ25vcmUgZGlyZWN0bHkgaW4gdG8gdGhpcyBhcnJheS5cbiAgU3lwaG9uLmlnbm9yZWRUeXBlcyA9IFsnYnV0dG9uJywgJ3N1Ym1pdCcsICdyZXNldCcsICdmaWVsZHNldCddO1xuICBcbiAgLy8gU3lwaG9uXG4gIC8vIC0tLS0tLVxuICBcbiAgLy8gR2V0IGEgSlNPTiBvYmplY3QgdGhhdCByZXByZXNlbnRzXG4gIC8vIGFsbCBvZiB0aGUgZm9ybSBpbnB1dHMsIGluIHRoaXMgdmlldy5cbiAgLy8gQWx0ZXJuYXRlbHksIHBhc3MgYSBmb3JtIGVsZW1lbnQgZGlyZWN0bHlcbiAgLy8gaW4gcGxhY2Ugb2YgdGhlIHZpZXcuXG4gIFN5cGhvbi5zZXJpYWxpemUgPSBmdW5jdGlvbih2aWV3LCBvcHRpb25zKXtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICBcbiAgICAvLyBCdWlsZCB0aGUgY29uZmlndXJhdGlvblxuICAgIHZhciBjb25maWcgPSBidWlsZENvbmZpZyhvcHRpb25zKTtcbiAgXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgZWxlbWVudHMgdG8gcHJvY2Vzc1xuICAgIHZhciBlbGVtZW50cyA9IGdldElucHV0RWxlbWVudHModmlldywgY29uZmlnKTtcbiAgXG4gICAgLy8gUHJvY2VzcyBhbGwgb2YgdGhlIGVsZW1lbnRzXG4gICAgXy5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbCl7XG4gICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICB2YXIgdHlwZSA9IGdldEVsZW1lbnRUeXBlKCRlbCk7XG4gIFxuICAgICAgLy8gR2V0IHRoZSBrZXkgZm9yIHRoZSBpbnB1dFxuICAgICAgdmFyIGtleUV4dHJhY3RvciA9IGNvbmZpZy5rZXlFeHRyYWN0b3JzLmdldCh0eXBlKTtcbiAgICAgIHZhciBrZXkgPSBrZXlFeHRyYWN0b3IoJGVsKTtcbiAgXG4gICAgICAvLyBHZXQgdGhlIHZhbHVlIGZvciB0aGUgaW5wdXRcbiAgICAgIHZhciBpbnB1dFJlYWRlciA9IGNvbmZpZy5pbnB1dFJlYWRlcnMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRSZWFkZXIoJGVsKTtcbiAgXG4gICAgICAvLyBHZXQgdGhlIGtleSBhc3NpZ25tZW50IHZhbGlkYXRvciBhbmQgbWFrZSBzdXJlXG4gICAgICAvLyBpdCdzIHZhbGlkIGJlZm9yZSBhc3NpZ25pbmcgdGhlIHZhbHVlIHRvIHRoZSBrZXlcbiAgICAgIHZhciB2YWxpZEtleUFzc2lnbm1lbnQgPSBjb25maWcua2V5QXNzaWdubWVudFZhbGlkYXRvcnMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKHZhbGlkS2V5QXNzaWdubWVudCgkZWwsIGtleSwgdmFsdWUpKXtcbiAgICAgICAgdmFyIGtleWNoYWluID0gY29uZmlnLmtleVNwbGl0dGVyKGtleSk7XG4gICAgICAgIGRhdGEgPSBhc3NpZ25LZXlWYWx1ZShkYXRhLCBrZXljaGFpbiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICAvLyBEb25lOyBzZW5kIGJhY2sgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIFxuICAvLyBVc2UgdGhlIGdpdmVuIEpTT04gb2JqZWN0IHRvIHBvcHVsYXRlXG4gIC8vIGFsbCBvZiB0aGUgZm9ybSBpbnB1dHMsIGluIHRoaXMgdmlldy5cbiAgLy8gQWx0ZXJuYXRlbHksIHBhc3MgYSBmb3JtIGVsZW1lbnQgZGlyZWN0bHlcbiAgLy8gaW4gcGxhY2Ugb2YgdGhlIHZpZXcuXG4gIFN5cGhvbi5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHZpZXcsIGRhdGEsIG9wdGlvbnMpe1xuICAgIC8vIEJ1aWxkIHRoZSBjb25maWd1cmF0aW9uXG4gICAgdmFyIGNvbmZpZyA9IGJ1aWxkQ29uZmlnKG9wdGlvbnMpO1xuICBcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBlbGVtZW50cyB0byBwcm9jZXNzXG4gICAgdmFyIGVsZW1lbnRzID0gZ2V0SW5wdXRFbGVtZW50cyh2aWV3LCBjb25maWcpO1xuICBcbiAgICAvLyBGbGF0dGVuIHRoZSBkYXRhIHN0cnVjdHVyZSB0aGF0IHdlIGFyZSBkZXNlcmlhbGl6aW5nXG4gICAgdmFyIGZsYXR0ZW5lZERhdGEgPSBmbGF0dGVuRGF0YShjb25maWcsIGRhdGEpO1xuICBcbiAgICAvLyBQcm9jZXNzIGFsbCBvZiB0aGUgZWxlbWVudHNcbiAgICBfLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsKXtcbiAgICAgIHZhciAkZWwgPSAkKGVsKTtcbiAgICAgIHZhciB0eXBlID0gZ2V0RWxlbWVudFR5cGUoJGVsKTtcbiAgXG4gICAgICAvLyBHZXQgdGhlIGtleSBmb3IgdGhlIGlucHV0XG4gICAgICB2YXIga2V5RXh0cmFjdG9yID0gY29uZmlnLmtleUV4dHJhY3RvcnMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIGtleSA9IGtleUV4dHJhY3RvcigkZWwpO1xuICBcbiAgICAgIC8vIEdldCB0aGUgaW5wdXQgd3JpdGVyIGFuZCB0aGUgdmFsdWUgdG8gd3JpdGVcbiAgICAgIHZhciBpbnB1dFdyaXRlciA9IGNvbmZpZy5pbnB1dFdyaXRlcnMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIHZhbHVlID0gZmxhdHRlbmVkRGF0YVtrZXldO1xuICBcbiAgICAgIC8vIFdyaXRlIHRoZSB2YWx1ZSB0byB0aGUgaW5wdXRcbiAgICAgIGlucHV0V3JpdGVyKCRlbCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG4gIFxuICAvLyBSZXRyaWV2ZSBhbGwgb2YgdGhlIGZvcm0gaW5wdXRzXG4gIC8vIGZyb20gdGhlIGZvcm1cbiAgdmFyIGdldElucHV0RWxlbWVudHMgPSBmdW5jdGlvbih2aWV3LCBjb25maWcpe1xuICAgIHZhciBmb3JtID0gZ2V0Rm9ybSh2aWV3KTtcbiAgICB2YXIgZWxlbWVudHMgPSBmb3JtLmVsZW1lbnRzO1xuICBcbiAgICBlbGVtZW50cyA9IF8ucmVqZWN0KGVsZW1lbnRzLCBmdW5jdGlvbihlbCl7XG4gICAgICB2YXIgcmVqZWN0O1xuICAgICAgdmFyIHR5cGUgPSBnZXRFbGVtZW50VHlwZShlbCk7XG4gICAgICB2YXIgZXh0cmFjdG9yID0gY29uZmlnLmtleUV4dHJhY3RvcnMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBleHRyYWN0b3IoJChlbCkpO1xuICBcbiAgICAgIHZhciBmb3VuZEluSWdub3JlZCA9IF8uaW5jbHVkZShjb25maWcuaWdub3JlZFR5cGVzLCB0eXBlKTtcbiAgICAgIHZhciBmb3VuZEluSW5jbHVkZSA9IF8uaW5jbHVkZShjb25maWcuaW5jbHVkZSwgaWRlbnRpZmllcik7XG4gICAgICB2YXIgZm91bmRJbkV4Y2x1ZGUgPSBfLmluY2x1ZGUoY29uZmlnLmV4Y2x1ZGUsIGlkZW50aWZpZXIpO1xuICBcbiAgICAgIGlmIChmb3VuZEluSW5jbHVkZSl7XG4gICAgICAgIHJlamVjdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbmZpZy5pbmNsdWRlKXtcbiAgICAgICAgICByZWplY3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCA9IChmb3VuZEluRXhjbHVkZSB8fCBmb3VuZEluSWdub3JlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gcmVqZWN0O1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH07XG4gIFxuICAvLyBEZXRlcm1pbmUgd2hhdCB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gSXRcbiAgLy8gd2lsbCBlaXRoZXIgcmV0dXJuIHRoZSBgdHlwZWAgYXR0cmlidXRlIG9mXG4gIC8vIGFuIGA8aW5wdXQ+YCBlbGVtZW50LCBvciB0aGUgYHRhZ05hbWVgIG9mXG4gIC8vIHRoZSBlbGVtZW50IHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFuIGA8aW5wdXQ+YC5cbiAgdmFyIGdldEVsZW1lbnRUeXBlID0gZnVuY3Rpb24oZWwpe1xuICAgIHZhciB0eXBlQXR0cjtcbiAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgdmFyIHRhZ05hbWUgPSAkZWxbMF0udGFnTmFtZTtcbiAgICB2YXIgdHlwZSA9IHRhZ05hbWU7XG4gIFxuICAgIGlmICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpe1xuICAgICAgdHlwZUF0dHIgPSAkZWwuYXR0cigndHlwZScpO1xuICAgICAgaWYgKHR5cGVBdHRyKXtcbiAgICAgICAgdHlwZSA9IHR5cGVBdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIHR5cGUgYXMgbG93ZXJjYXNlXG4gICAgLy8gc28gaXQgY2FuIGJlIG1hdGNoZWQgdG8gbG93ZXJjYXNlXG4gICAgLy8gdHlwZSByZWdpc3RyYXRpb25zLlxuICAgIHJldHVybiB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIH07XG4gIFxuICAvLyBJZiBhIGZvcm0gZWxlbWVudCBpcyBnaXZlbiwganVzdCByZXR1cm4gaXQuXG4gIC8vIE90aGVyd2lzZSwgZ2V0IHRoZSBmb3JtIGVsZW1lbnQgZnJvbSB0aGUgdmlldy5cbiAgdmFyIGdldEZvcm0gPSBmdW5jdGlvbih2aWV3T3JGb3JtKXtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh2aWV3T3JGb3JtLiRlbCkgJiYgdmlld09yRm9ybS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb3JtJyl7XG4gICAgICByZXR1cm4gdmlld09yRm9ybTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpZXdPckZvcm0uJGVsLmlzKCdmb3JtJykgPyB2aWV3T3JGb3JtLmVsIDogdmlld09yRm9ybS4kKCdmb3JtJylbMF07XG4gICAgfVxuICB9O1xuICBcbiAgLy8gQnVpbGQgYSBjb25maWd1cmF0aW9uIG9iamVjdCBhbmQgaW5pdGlhbGl6ZVxuICAvLyBkZWZhdWx0IHZhbHVlcy5cbiAgdmFyIGJ1aWxkQ29uZmlnID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgdmFyIGNvbmZpZyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XG4gIFxuICAgIGNvbmZpZy5pZ25vcmVkVHlwZXMgPSBfLmNsb25lKFN5cGhvbi5pZ25vcmVkVHlwZXMpO1xuICAgIGNvbmZpZy5pbnB1dFJlYWRlcnMgPSBjb25maWcuaW5wdXRSZWFkZXJzIHx8IFN5cGhvbi5JbnB1dFJlYWRlcnM7XG4gICAgY29uZmlnLmlucHV0V3JpdGVycyA9IGNvbmZpZy5pbnB1dFdyaXRlcnMgfHwgU3lwaG9uLklucHV0V3JpdGVycztcbiAgICBjb25maWcua2V5RXh0cmFjdG9ycyA9IGNvbmZpZy5rZXlFeHRyYWN0b3JzIHx8IFN5cGhvbi5LZXlFeHRyYWN0b3JzO1xuICAgIGNvbmZpZy5rZXlTcGxpdHRlciA9IGNvbmZpZy5rZXlTcGxpdHRlciB8fCBTeXBob24uS2V5U3BsaXR0ZXI7XG4gICAgY29uZmlnLmtleUpvaW5lciA9IGNvbmZpZy5rZXlKb2luZXIgfHwgU3lwaG9uLktleUpvaW5lcjtcbiAgICBjb25maWcua2V5QXNzaWdubWVudFZhbGlkYXRvcnMgPSBjb25maWcua2V5QXNzaWdubWVudFZhbGlkYXRvcnMgfHwgU3lwaG9uLktleUFzc2lnbm1lbnRWYWxpZGF0b3JzO1xuICBcbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuICBcbiAgLy8gQXNzaWducyBgdmFsdWVgIHRvIGEgcGFyc2VkIEpTT04ga2V5LlxuICAvL1xuICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBiZVxuICAvLyBtb2RpZmllZCB0byBzdG9yZSB0aGUga2V5L3ZhbHVlIHBhaXIuXG4gIC8vXG4gIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGFjY2VwdHMgYW4gYXJyYXkgb2Yga2V5cyBhcyBhXG4gIC8vIHN0cmluZyB3aXRoIGFuIG9wdGlvbiBhcnJheSBjb250YWluaW5nIGFcbiAgLy8gc2luZ2xlIHN0cmluZyBhcyB0aGUgbGFzdCBvcHRpb24uXG4gIC8vXG4gIC8vIFRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgdGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkLlxuICAvL1xuICAvLyBFeGFtcGxlczpcbiAgLy9cbiAgLy8gYFsnZm9vJywgJ2JhcicsICdiYXonXSA9PiB7Zm9vOiB7YmFyOiB7YmF6OiAndmFsdWUnfX19YFxuICAvL1xuICAvLyBgWydmb28nLCAnYmFyJywgWydiYXonXV0gPT4ge2Zvbzoge2Jhcjoge2JhejogWyd2YWx1ZSddfX19YFxuICAvL1xuICAvLyBXaGVuIHRoZSBmaW5hbCB2YWx1ZSBpcyBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLCB0aGUga2V5XG4gIC8vIGJlY29tZXMgYW4gYXJyYXksIGFuZCB2YWx1ZXMgYXJlIHB1c2hlZCBpbiB0byB0aGUgYXJyYXksXG4gIC8vIGFsbG93aW5nIG11bHRpcGxlIGZpZWxkcyB3aXRoIHRoZSBzYW1lIG5hbWUgdG8gYmVcbiAgLy8gYXNzaWduZWQgdG8gdGhlIGFycmF5LlxuICB2YXIgYXNzaWduS2V5VmFsdWUgPSBmdW5jdGlvbihvYmosIGtleWNoYWluLCB2YWx1ZSkge1xuICAgIGlmICgha2V5Y2hhaW4peyByZXR1cm4gb2JqOyB9XG4gIFxuICAgIHZhciBrZXkgPSBrZXljaGFpbi5zaGlmdCgpO1xuICBcbiAgICAvLyBidWlsZCB0aGUgY3VycmVudCBvYmplY3Qgd2UgbmVlZCB0byBzdG9yZSBkYXRhXG4gICAgaWYgKCFvYmpba2V5XSl7XG4gICAgICBvYmpba2V5XSA9IF8uaXNBcnJheShrZXkpID8gW10gOiB7fTtcbiAgICB9XG4gIFxuICAgIC8vIGlmIGl0J3MgdGhlIGxhc3Qga2V5IGluIHRoZSBjaGFpbiwgYXNzaWduIHRoZSB2YWx1ZSBkaXJlY3RseVxuICAgIGlmIChrZXljaGFpbi5sZW5ndGggPT09IDApe1xuICAgICAgaWYgKF8uaXNBcnJheShvYmpba2V5XSkpe1xuICAgICAgICBvYmpba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyByZWN1cnNpdmUgcGFyc2luZyBvZiB0aGUgYXJyYXksIGRlcHRoLWZpcnN0XG4gICAgaWYgKGtleWNoYWluLmxlbmd0aCA+IDApe1xuICAgICAgYXNzaWduS2V5VmFsdWUob2JqW2tleV0sIGtleWNoYWluLCB2YWx1ZSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuICBcbiAgLy8gRmxhdHRlbiB0aGUgZGF0YSBzdHJ1Y3R1cmUgaW4gdG8gbmVzdGVkIHN0cmluZ3MsIHVzaW5nIHRoZVxuICAvLyBwcm92aWRlZCBgS2V5Sm9pbmVyYCBmdW5jdGlvbi5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gVGhpcyBpbnB1dDpcbiAgLy9cbiAgLy8gYGBganNcbiAgLy8ge1xuICAvLyAgIHdpZGdldDogJ3dvbWJhdCcsXG4gIC8vICAgZm9vOiB7XG4gIC8vICAgICBiYXI6ICdiYXonLFxuICAvLyAgICAgYmF6OiB7XG4gIC8vICAgICAgIHF1dXg6ICdxdXgnXG4gIC8vICAgICB9LFxuICAvLyAgICAgcXV1eDogWydmb28nLCAnYmFyJ11cbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gYGBgXG4gIC8vXG4gIC8vIFdpdGggYSBLZXlKb2luZXIgdGhhdCB1c2VzIFsgXSBzcXVhcmUgYnJhY2tldHMsXG4gIC8vIHNob3VsZCBwcm9kdWNlIHRoaXMgb3V0cHV0OlxuICAvL1xuICAvLyBgYGBqc1xuICAvLyB7XG4gIC8vICAnd2lkZ2V0JzogJ3dvbWJhdCcsXG4gIC8vICAnZm9vW2Jhcl0nOiAnYmF6JyxcbiAgLy8gICdmb29bYmF6XVtxdXV4XSc6ICdxdXgnLFxuICAvLyAgJ2Zvb1txdXV4XSc6IFsnZm9vJywgJ2JhciddXG4gIC8vIH1cbiAgLy8gYGBgXG4gIHZhciBmbGF0dGVuRGF0YSA9IGZ1bmN0aW9uKGNvbmZpZywgZGF0YSwgcGFyZW50S2V5KXtcbiAgICB2YXIgZmxhdERhdGEgPSB7fTtcbiAgXG4gICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXlOYW1lKXtcbiAgICAgIHZhciBoYXNoID0ge307XG4gIFxuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQga2V5LCBqb2luIGl0IHdpdGhcbiAgICAgIC8vIHRoZSBjdXJyZW50LCBjaGlsZCBrZXkuXG4gICAgICBpZiAocGFyZW50S2V5KXtcbiAgICAgICAga2V5TmFtZSA9IGNvbmZpZy5rZXlKb2luZXIocGFyZW50S2V5LCBrZXlOYW1lKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSl7XG4gICAgICAgIGtleU5hbWUgKz0gJ1tdJztcbiAgICAgICAgaGFzaFtrZXlOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSl7XG4gICAgICAgIGhhc2ggPSBmbGF0dGVuRGF0YShjb25maWcsIHZhbHVlLCBrZXlOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc2hba2V5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBTdG9yZSB0aGUgcmVzdWx0aW5nIGtleS92YWx1ZSBwYWlycyBpbiB0aGVcbiAgICAgIC8vIGZpbmFsIGZsYXR0ZW5lZCBkYXRhIG9iamVjdFxuICAgICAgXy5leHRlbmQoZmxhdERhdGEsIGhhc2gpO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gZmxhdERhdGE7XG4gIH07XG4gIFxuICAvLyBUeXBlIFJlZ2lzdHJ5XG4gIC8vIC0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIFR5cGUgUmVnaXN0cmllcyBhbGxvdyB5b3UgdG8gcmVnaXN0ZXIgc29tZXRoaW5nIHRvXG4gIC8vIGFuIGlucHV0IHR5cGUsIGFuZCByZXRyaWV2ZSBlaXRoZXIgdGhlIGl0ZW0gcmVnaXN0ZXJlZFxuICAvLyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9yIHRoZSBkZWZhdWx0IHJlZ2lzdHJhdGlvblxuICB2YXIgVHlwZVJlZ2lzdHJ5ID0gU3lwaG9uLlR5cGVSZWdpc3RyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZFR5cGVzID0ge307XG4gIH07XG4gIFxuICAvLyBCb3Jyb3cgQmFja2JvbmUncyBgZXh0ZW5kYCBrZXl3b3JkIGZvciBvdXIgVHlwZVJlZ2lzdHJ5XG4gIFR5cGVSZWdpc3RyeS5leHRlbmQgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQ7XG4gIFxuICBfLmV4dGVuZChUeXBlUmVnaXN0cnkucHJvdG90eXBlLCB7XG4gIFxuICAgIC8vIEdldCB0aGUgcmVnaXN0ZXJlZCBpdGVtIGJ5IHR5cGUuIElmIG5vdGhpbmcgaXNcbiAgICAvLyBmb3VuZCBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCB0aGUgZGVmYXVsdCBpc1xuICAgIC8vIHJldHVybmVkLlxuICAgIGdldDogZnVuY3Rpb24odHlwZSl7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkVHlwZXNbdHlwZV0gfHwgdGhpcy5yZWdpc3RlcmVkVHlwZXNbJ2RlZmF1bHQnXTtcbiAgICB9LFxuICBcbiAgICAvLyBSZWdpc3RlciBhIG5ldyBpdGVtIGZvciBhIHNwZWNpZmllZCB0eXBlXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHR5cGUsIGl0ZW0pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZFR5cGVzW3R5cGVdID0gaXRlbTtcbiAgICB9LFxuICBcbiAgICAvLyBSZWdpc3RlciBhIGRlZmF1bHQgaXRlbSB0byBiZSB1c2VkIHdoZW4gbm9cbiAgICAvLyBpdGVtIGZvciBhIHNwZWNpZmllZCB0eXBlIGlzIGZvdW5kXG4gICAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRUeXBlc1snZGVmYXVsdCddID0gaXRlbTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgYW4gaXRlbSBmcm9tIGEgZ2l2ZW4gdHlwZSByZWdpc3RyYXRpb25cbiAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBpZiAodGhpcy5yZWdpc3RlcmVkVHlwZXNbdHlwZV0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0ZXJlZFR5cGVzW3R5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBLZXkgRXh0cmFjdG9yc1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gS2V5IGV4dHJhY3RvcnMgcHJvZHVjZSB0aGUgXCJrZXlcIiBpbiBge2tleTogXCJ2YWx1ZVwifWBcbiAgLy8gcGFpcnMsIHdoZW4gc2VyaWFsaXppbmcuXG4gIHZhciBLZXlFeHRyYWN0b3JTZXQgPSBTeXBob24uS2V5RXh0cmFjdG9yU2V0ID0gVHlwZVJlZ2lzdHJ5LmV4dGVuZCgpO1xuICBcbiAgLy8gQnVpbHQtaW4gS2V5IEV4dHJhY3RvcnNcbiAgdmFyIEtleUV4dHJhY3RvcnMgPSBTeXBob24uS2V5RXh0cmFjdG9ycyA9IG5ldyBLZXlFeHRyYWN0b3JTZXQoKTtcbiAgXG4gIC8vIFRoZSBkZWZhdWx0IGtleSBleHRyYWN0b3IsIHdoaWNoIHVzZXMgdGhlXG4gIC8vIGlucHV0IGVsZW1lbnQncyBcIm5hbWVcIiBhdHRyaWJ1dGVcbiAgS2V5RXh0cmFjdG9ycy5yZWdpc3RlckRlZmF1bHQoZnVuY3Rpb24oJGVsKSB7XG4gICAgcmV0dXJuICRlbC5wcm9wKCduYW1lJykgfHwgJyc7XG4gIH0pO1xuICBcbiAgLy8gSW5wdXQgUmVhZGVyc1xuICAvLyAtLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBJbnB1dCBSZWFkZXJzIGFyZSB1c2VkIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb21cbiAgLy8gYW4gaW5wdXQgZWxlbWVudCwgZm9yIHRoZSBzZXJpYWxpemVkIG9iamVjdCByZXN1bHRcbiAgdmFyIElucHV0UmVhZGVyU2V0ID0gU3lwaG9uLklucHV0UmVhZGVyU2V0ID0gVHlwZVJlZ2lzdHJ5LmV4dGVuZCgpO1xuICBcbiAgLy8gQnVpbHQtaW4gSW5wdXQgUmVhZGVyc1xuICB2YXIgSW5wdXRSZWFkZXJzID0gU3lwaG9uLklucHV0UmVhZGVycyA9IG5ldyBJbnB1dFJlYWRlclNldCgpO1xuICBcbiAgLy8gVGhlIGRlZmF1bHQgaW5wdXQgcmVhZGVyLCB3aGljaCB1c2VzIGFuIGlucHV0XG4gIC8vIGVsZW1lbnQncyBcInZhbHVlXCJcbiAgSW5wdXRSZWFkZXJzLnJlZ2lzdGVyRGVmYXVsdChmdW5jdGlvbigkZWwpe1xuICAgIHJldHVybiAkZWwudmFsKCk7XG4gIH0pO1xuICBcbiAgLy8gQ2hlY2tib3ggcmVhZGVyLCByZXR1cm5pbmcgYSBib29sZWFuIHZhbHVlIGZvclxuICAvLyB3aGV0aGVyIG9yIG5vdCB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZC5cbiAgSW5wdXRSZWFkZXJzLnJlZ2lzdGVyKCdjaGVja2JveCcsIGZ1bmN0aW9uKCRlbCkge1xuICAgIHJldHVybiAkZWwucHJvcCgnY2hlY2tlZCcpO1xuICB9KTtcbiAgXG4gIC8vIElucHV0IFdyaXRlcnNcbiAgLy8gLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gSW5wdXQgV3JpdGVycyBhcmUgdXNlZCB0byBpbnNlcnQgYSB2YWx1ZSBmcm9tIGFuXG4gIC8vIG9iamVjdCBpbnRvIGFuIGlucHV0IGVsZW1lbnQuXG4gIHZhciBJbnB1dFdyaXRlclNldCA9IFN5cGhvbi5JbnB1dFdyaXRlclNldCA9IFR5cGVSZWdpc3RyeS5leHRlbmQoKTtcbiAgXG4gIC8vIEJ1aWx0LWluIElucHV0IFdyaXRlcnNcbiAgdmFyIElucHV0V3JpdGVycyA9IFN5cGhvbi5JbnB1dFdyaXRlcnMgPSBuZXcgSW5wdXRXcml0ZXJTZXQoKTtcbiAgXG4gIC8vIFRoZSBkZWZhdWx0IGlucHV0IHdyaXRlciwgd2hpY2ggc2V0cyBhbiBpbnB1dFxuICAvLyBlbGVtZW50J3MgXCJ2YWx1ZVwiXG4gIElucHV0V3JpdGVycy5yZWdpc3RlckRlZmF1bHQoZnVuY3Rpb24oJGVsLCB2YWx1ZSkge1xuICAgICRlbC52YWwodmFsdWUpO1xuICB9KTtcbiAgXG4gIC8vIENoZWNrYm94IHdyaXRlciwgc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjaGVja2JveCBpcyBjaGVja2VkXG4gIC8vIGRlcGVuZGluZyBvbiB0aGUgYm9vbGVhbiB2YWx1ZS5cbiAgSW5wdXRXcml0ZXJzLnJlZ2lzdGVyKCdjaGVja2JveCcsIGZ1bmN0aW9uKCRlbCwgdmFsdWUpIHtcbiAgICAkZWwucHJvcCgnY2hlY2tlZCcsIHZhbHVlKTtcbiAgfSk7XG4gIFxuICAvLyBSYWRpbyBidXR0b24gd3JpdGVyLCBzZXQgd2hldGhlciBvciBub3QgdGhlIHJhZGlvIGJ1dHRvbiBpc1xuICAvLyBjaGVja2VkLiAgVGhlIGJ1dHRvbiBzaG91bGQgb25seSBiZSBjaGVja2VkIGlmIGl0J3MgdmFsdWVcbiAgLy8gZXF1YWxzIHRoZSBnaXZlbiB2YWx1ZS5cbiAgSW5wdXRXcml0ZXJzLnJlZ2lzdGVyKCdyYWRpbycsIGZ1bmN0aW9uKCRlbCwgdmFsdWUpIHtcbiAgICAkZWwucHJvcCgnY2hlY2tlZCcsICRlbC52YWwoKSA9PT0gdmFsdWUudG9TdHJpbmcoKSk7XG4gIH0pO1xuICBcbiAgLy8gS2V5IEFzc2lnbm1lbnQgVmFsaWRhdG9yc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBLZXkgQXNzaWdubWVudCBWYWxpZGF0b3JzIGFyZSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhXG4gIC8vIGtleSBzaG91bGQgYmUgYXNzaWduZWQgdG8gYSB2YWx1ZSwgYWZ0ZXIgdGhlIGtleSBhbmQgdmFsdWUgaGF2ZSBiZWVuXG4gIC8vIGV4dHJhY3RlZCBmcm9tIHRoZSBlbGVtZW50LiBUaGlzIGlzIHRoZSBsYXN0IG9wcG9ydHVuaXR5IHRvIHByZXZlbnRcbiAgLy8gYmFkIGRhdGEgZnJvbSBnZXR0aW5nIHNlcmlhbGl6ZWQgdG8geW91ciBvYmplY3QuXG4gIFxuICB2YXIgS2V5QXNzaWdubWVudFZhbGlkYXRvclNldCA9IFN5cGhvbi5LZXlBc3NpZ25tZW50VmFsaWRhdG9yU2V0ID0gVHlwZVJlZ2lzdHJ5LmV4dGVuZCgpO1xuICBcbiAgLy8gQnVpbGQtaW4gS2V5IEFzc2lnbm1lbnQgVmFsaWRhdG9yc1xuICB2YXIgS2V5QXNzaWdubWVudFZhbGlkYXRvcnMgPSBTeXBob24uS2V5QXNzaWdubWVudFZhbGlkYXRvcnMgPSBuZXcgS2V5QXNzaWdubWVudFZhbGlkYXRvclNldCgpO1xuICBcbiAgLy8gRXZlcnl0aGluZyBpcyB2YWxpZCBieSBkZWZhdWx0XG4gIEtleUFzc2lnbm1lbnRWYWxpZGF0b3JzLnJlZ2lzdGVyRGVmYXVsdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIFxuICAvLyBCdXQgb25seSB0aGUgXCJjaGVja2VkXCIgcmFkaW8gYnV0dG9uIGZvciBhIGdpdmVuXG4gIC8vIHJhZGlvIGJ1dHRvbiBncm91cCBpcyB2YWxpZFxuICBLZXlBc3NpZ25tZW50VmFsaWRhdG9ycy5yZWdpc3RlcigncmFkaW8nLCBmdW5jdGlvbigkZWwsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gJGVsLnByb3AoJ2NoZWNrZWQnKTtcbiAgfSk7XG4gIFxuICAvLyBCYWNrYm9uZS5TeXBob24uS2V5U3BsaXR0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gc3BsaXQgRE9NIGVsZW1lbnQga2V5cyBpbiB0byBhbiBhcnJheVxuICAvLyBvZiBwYXJ0cywgd2hpY2ggYXJlIHRoZW4gdXNlZCB0byBjcmVhdGUgYSBuZXN0ZWQgcmVzdWx0IHN0cnVjdHVyZS5cbiAgLy8gcmV0dXJuaW5nIGBbXCJmb29cIiwgXCJiYXJcIl1gIHJlc3VsdHMgaW4gYHtmb286IHsgYmFyOiBcInZhbHVlXCIgfX1gLlxuICAvL1xuICAvLyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byB1c2UgYSBjdXN0b20ga2V5IHNwbGl0dGVyLCBzdWNoIGFzOlxuICAvLyBgPGlucHV0IG5hbWU9XCJmb28uYmFyLmJhelwiPmAsIGByZXR1cm4ga2V5LnNwbGl0KFwiLlwiKWBcbiAgU3lwaG9uLktleVNwbGl0dGVyID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBrZXkubWF0Y2goL1teXFxbXFxdXSsvZyk7XG4gICAgdmFyIGxhc3RLZXk7XG4gIFxuICAgIGlmIChrZXkuaW5kZXhPZignW10nKSA9PT0ga2V5Lmxlbmd0aCAtIDIpIHtcbiAgICAgIGxhc3RLZXkgPSBtYXRjaGVzLnBvcCgpO1xuICAgICAgbWF0Y2hlcy5wdXNoKFtsYXN0S2V5XSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcbiAgXG4gIC8vIEJhY2tib25lLlN5cGhvbi5LZXlKb2luZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gVGFrZSB0d28gc2VnbWVudHMgb2YgYSBrZXkgYW5kIGpvaW4gdGhlbSB0b2dldGhlciwgdG8gY3JlYXRlIHRoZVxuICAvLyBkZS1ub3JtYWxpemVkIGtleSBuYW1lLCB3aGVuIGRlc2VyaWFsaXppbmcgYSBkYXRhIHN0cnVjdHVyZSBiYWNrXG4gIC8vIGluIHRvIGEgZm9ybS5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gV2l0aCB0aGlzIGRhdGEgc3RydWN1dHJlIGB7Zm9vOiB7IGJhcjoge2JhejogXCJ2YWx1ZVwiLCBxdXV4OiBcImFub3RoZXJcIn0gfSB9YCxcbiAgLy8gdGhlIGtleSBqb2luZXIgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVzZSBwYXJhbWV0ZXJzLCBhbmQgYXNzdW1pbmcgdGhlXG4gIC8vIGpvaW4gaGFwcGVucyB3aXRoIFwiWyBdXCIgc3F1YXJlIGJyYWNrZXRzLCB0aGUgc3BlY2lmaWVkIG91dHB1dDpcbiAgLy9cbiAgLy8gYEtleUpvaW5lcihcImZvb1wiLCBcImJhclwiKWAgLy89PiBcImZvb1tiYXJdXCJcbiAgLy8gYEtleUpvaW5lcihcImZvb1tiYXJdXCIsIFwiYmF6XCIpYCAvLz0+IFwiZm9vW2Jhcl1bYmF6XVwiXG4gIC8vIGBLZXlKb2luZXIoXCJmb29bYmFyXVwiLCBcInF1dXhcIilgIC8vPT4gXCJmb29bYmFyXVtxdXV4XVwiXG4gIFxuICBTeXBob24uS2V5Sm9pbmVyID0gZnVuY3Rpb24ocGFyZW50S2V5LCBjaGlsZEtleSkge1xuICAgIHJldHVybiBwYXJlbnRLZXkgKyAnWycgKyBjaGlsZEtleSArICddJztcbiAgfTtcbiAgXG5cbiAgcmV0dXJuIEJhY2tib25lLlN5cGhvbjtcbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhY2tib25lLnN5cGhvbi9saWIvYmFja2JvbmUuc3lwaG9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjIxLmpzIn0=");

/***/ },
/* 22 */
/*!***************************************************************!*\
  !*** ./~/backbone-validation/dist/backbone-validation-amd.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("// Backbone.Validation v0.9.1\n//\n// Copyright (c) 2011-2014 Thomas Pedersen\n// Distributed under MIT License\n//\n// Documentation and full license available at:\n// http://thedersen.com/projects/backbone-validation\n(function (factory) {\n  if (true) {\n    module.exports = factory(__webpack_require__(/*! backbone */ 1), __webpack_require__(/*! underscore */ 2));\n  } else if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'underscore'], factory);\n  }\n}(function (Backbone, _) {\n  Backbone.Validation = (function(_){\n    'use strict';\n  \n    // Default options\n    // ---------------\n  \n    var defaultOptions = {\n      forceUpdate: false,\n      selector: 'name',\n      labelFormatter: 'sentenceCase',\n      valid: Function.prototype,\n      invalid: Function.prototype\n    };\n  \n  \n    // Helper functions\n    // ----------------\n  \n    // Formatting functions used for formatting error messages\n    var formatFunctions = {\n      // Uses the configured label formatter to format the attribute name\n      // to make it more readable for the user\n      formatLabel: function(attrName, model) {\n        return defaultLabelFormatters[defaultOptions.labelFormatter](attrName, model);\n      },\n  \n      // Replaces nummeric placeholders like {0} in a string with arguments\n      // passed to the function\n      format: function() {\n        var args = Array.prototype.slice.call(arguments),\n            text = args.shift();\n        return text.replace(/\\{(\\d+)\\}/g, function(match, number) {\n          return typeof args[number] !== 'undefined' ? args[number] : match;\n        });\n      }\n    };\n  \n    // Flattens an object\n    // eg:\n    //\n    //     var o = {\n    //       address: {\n    //         street: 'Street',\n    //         zip: 1234\n    //       }\n    //     };\n    //\n    // becomes:\n    //\n    //     var o = {\n    //       'address.street': 'Street',\n    //       'address.zip': 1234\n    //     };\n    var flatten = function (obj, into, prefix) {\n      into = into || {};\n      prefix = prefix || '';\n  \n      _.each(obj, function(val, key) {\n        if(obj.hasOwnProperty(key)) {\n          if (val && typeof val === 'object' && !(\n            val instanceof Array ||\n            val instanceof Date ||\n            val instanceof RegExp ||\n            val instanceof Backbone.Model ||\n            val instanceof Backbone.Collection)\n          ) {\n            flatten(val, into, prefix + key + '.');\n          }\n          else {\n            into[prefix + key] = val;\n          }\n        }\n      });\n  \n      return into;\n    };\n  \n    // Validation\n    // ----------\n  \n    var Validation = (function(){\n  \n      // Returns an object with undefined properties for all\n      // attributes on the model that has defined one or more\n      // validation rules.\n      var getValidatedAttrs = function(model) {\n        return _.reduce(_.keys(_.result(model, 'validation') || {}), function(memo, key) {\n          memo[key] = void 0;\n          return memo;\n        }, {});\n      };\n  \n      // Looks on the model for validations for a specified\n      // attribute. Returns an array of any validators defined,\n      // or an empty array if none is defined.\n      var getValidators = function(model, attr) {\n        var attrValidationSet = model.validation ? _.result(model, 'validation')[attr] || {} : {};\n  \n        // If the validator is a function or a string, wrap it in a function validator\n        if (_.isFunction(attrValidationSet) || _.isString(attrValidationSet)) {\n          attrValidationSet = {\n            fn: attrValidationSet\n          };\n        }\n  \n        // Stick the validator object into an array\n        if(!_.isArray(attrValidationSet)) {\n          attrValidationSet = [attrValidationSet];\n        }\n  \n        // Reduces the array of validators into a new array with objects\n        // with a validation method to call, the value to validate against\n        // and the specified error message, if any\n        return _.reduce(attrValidationSet, function(memo, attrValidation) {\n          _.each(_.without(_.keys(attrValidation), 'msg'), function(validator) {\n            memo.push({\n              fn: defaultValidators[validator],\n              val: attrValidation[validator],\n              msg: attrValidation.msg\n            });\n          });\n          return memo;\n        }, []);\n      };\n  \n      // Validates an attribute against all validators defined\n      // for that attribute. If one or more errors are found,\n      // the first error message is returned.\n      // If the attribute is valid, an empty string is returned.\n      var validateAttr = function(model, attr, value, computed) {\n        // Reduces the array of validators to an error message by\n        // applying all the validators and returning the first error\n        // message, if any.\n        return _.reduce(getValidators(model, attr), function(memo, validator){\n          // Pass the format functions plus the default\n          // validators as the context to the validator\n          var ctx = _.extend({}, formatFunctions, defaultValidators),\n              result = validator.fn.call(ctx, value, attr, validator.val, model, computed);\n  \n          if(result === false || memo === false) {\n            return false;\n          }\n          if (result && !memo) {\n            return _.result(validator, 'msg') || result;\n          }\n          return memo;\n        }, '');\n      };\n  \n      // Loops through the model's attributes and validates them all.\n      // Returns and object containing names of invalid attributes\n      // as well as error messages.\n      var validateModel = function(model, attrs) {\n        var error,\n            invalidAttrs = {},\n            isValid = true,\n            computed = _.clone(attrs),\n            flattened = flatten(attrs);\n  \n        _.each(flattened, function(val, attr) {\n          error = validateAttr(model, attr, val, computed);\n          if (error) {\n            invalidAttrs[attr] = error;\n            isValid = false;\n          }\n        });\n  \n        return {\n          invalidAttrs: invalidAttrs,\n          isValid: isValid\n        };\n      };\n  \n      // Contains the methods that are mixed in on the model when binding\n      var mixin = function(view, options) {\n        return {\n  \n          // Check whether or not a value, or a hash of values\n          // passes validation without updating the model\n          preValidate: function(attr, value) {\n            var self = this,\n                result = {},\n                error;\n  \n            if(_.isObject(attr)){\n              _.each(attr, function(value, key) {\n                error = self.preValidate(key, value);\n                if(error){\n                  result[key] = error;\n                }\n              });\n  \n              return _.isEmpty(result) ? undefined : result;\n            }\n            else {\n              return validateAttr(this, attr, value, _.extend({}, this.attributes));\n            }\n          },\n  \n          // Check to see if an attribute, an array of attributes or the\n          // entire model is valid. Passing true will force a validation\n          // of the model.\n          isValid: function(option) {\n            var flattened = flatten(this.attributes);\n  \n            if(_.isString(option)){\n              return !validateAttr(this, option, flattened[option], _.extend({}, this.attributes));\n            }\n            if(_.isArray(option)){\n              return _.reduce(option, function(memo, attr) {\n                return memo && !validateAttr(this, attr, flattened[attr], _.extend({}, this.attributes));\n              }, true, this);\n            }\n            if(option === true) {\n              this.validate();\n            }\n            return this.validation ? this._isValid : true;\n          },\n  \n          // This is called by Backbone when it needs to perform validation.\n          // You can call it manually without any parameters to validate the\n          // entire model.\n          validate: function(attrs, setOptions){\n            var model = this,\n                validateAll = !attrs,\n                opt = _.extend({}, options, setOptions),\n                validatedAttrs = getValidatedAttrs(model),\n                allAttrs = _.extend({}, validatedAttrs, model.attributes, attrs),\n                changedAttrs = flatten(attrs || allAttrs),\n  \n                result = validateModel(model, allAttrs);\n  \n            model._isValid = result.isValid;\n  \n            // After validation is performed, loop through all validated attributes\n            // and call the valid callbacks so the view is updated.\n            _.each(validatedAttrs, function(val, attr){\n              var invalid = result.invalidAttrs.hasOwnProperty(attr);\n              if(!invalid){\n                opt.valid(view, attr, opt.selector);\n              }\n            });\n  \n            // After validation is performed, loop through all validated and changed attributes\n            // and call the invalid callback so the view is updated.\n            _.each(validatedAttrs, function(val, attr){\n              var invalid = result.invalidAttrs.hasOwnProperty(attr),\n                  changed = changedAttrs.hasOwnProperty(attr);\n  \n              if(invalid && (changed || validateAll)){\n                opt.invalid(view, attr, result.invalidAttrs[attr], opt.selector);\n              }\n            });\n  \n            // Trigger validated events.\n            // Need to defer this so the model is actually updated before\n            // the event is triggered.\n            _.defer(function() {\n              model.trigger('validated', model._isValid, model, result.invalidAttrs);\n              model.trigger('validated:' + (model._isValid ? 'valid' : 'invalid'), model, result.invalidAttrs);\n            });\n  \n            // Return any error messages to Backbone, unless the forceUpdate flag is set.\n            // Then we do not return anything and fools Backbone to believe the validation was\n            // a success. That way Backbone will update the model regardless.\n            if (!opt.forceUpdate && _.intersection(_.keys(result.invalidAttrs), _.keys(changedAttrs)).length > 0) {\n              return result.invalidAttrs;\n            }\n          }\n        };\n      };\n  \n      // Helper to mix in validation on a model\n      var bindModel = function(view, model, options) {\n        _.extend(model, mixin(view, options));\n      };\n  \n      // Removes the methods added to a model\n      var unbindModel = function(model) {\n        delete model.validate;\n        delete model.preValidate;\n        delete model.isValid;\n      };\n  \n      // Mix in validation on a model whenever a model is\n      // added to a collection\n      var collectionAdd = function(model) {\n        bindModel(this.view, model, this.options);\n      };\n  \n      // Remove validation from a model whenever a model is\n      // removed from a collection\n      var collectionRemove = function(model) {\n        unbindModel(model);\n      };\n  \n      // Returns the public methods on Backbone.Validation\n      return {\n  \n        // Current version of the library\n        version: '0.9.1',\n  \n        // Called to configure the default options\n        configure: function(options) {\n          _.extend(defaultOptions, options);\n        },\n  \n        // Hooks up validation on a view with a model\n        // or collection\n        bind: function(view, options) {\n          options = _.extend({}, defaultOptions, defaultCallbacks, options);\n  \n          var model = options.model || view.model,\n              collection = options.collection || view.collection;\n  \n          if(typeof model === 'undefined' && typeof collection === 'undefined'){\n            throw 'Before you execute the binding your view must have a model or a collection.\\n' +\n                  'See http://thedersen.com/projects/backbone-validation/#using-form-model-validation for more information.';\n          }\n  \n          if(model) {\n            bindModel(view, model, options);\n          }\n          else if(collection) {\n            collection.each(function(model){\n              bindModel(view, model, options);\n            });\n            collection.bind('add', collectionAdd, {view: view, options: options});\n            collection.bind('remove', collectionRemove);\n          }\n        },\n  \n        // Removes validation from a view with a model\n        // or collection\n        unbind: function(view, options) {\n          options = _.extend({}, options);\n          var model = options.model || view.model,\n              collection = options.collection || view.collection;\n  \n          if(model) {\n            unbindModel(model);\n          }\n          else if(collection) {\n            collection.each(function(model){\n              unbindModel(model);\n            });\n            collection.unbind('add', collectionAdd);\n            collection.unbind('remove', collectionRemove);\n          }\n        },\n  \n        // Used to extend the Backbone.Model.prototype\n        // with validation\n        mixin: mixin(null, defaultOptions)\n      };\n    }());\n  \n  \n    // Callbacks\n    // ---------\n  \n    var defaultCallbacks = Validation.callbacks = {\n  \n      // Gets called when a previously invalid field in the\n      // view becomes valid. Removes any error message.\n      // Should be overridden with custom functionality.\n      valid: function(view, attr, selector) {\n        view.$('[' + selector + '~=\"' + attr + '\"]')\n            .removeClass('invalid')\n            .removeAttr('data-error');\n      },\n  \n      // Gets called when a field in the view becomes invalid.\n      // Adds a error message.\n      // Should be overridden with custom functionality.\n      invalid: function(view, attr, error, selector) {\n        view.$('[' + selector + '~=\"' + attr + '\"]')\n            .addClass('invalid')\n            .attr('data-error', error);\n      }\n    };\n  \n  \n    // Patterns\n    // --------\n  \n    var defaultPatterns = Validation.patterns = {\n      // Matches any digit(s) (i.e. 0-9)\n      digits: /^\\d+$/,\n  \n      // Matches any number (e.g. 100.000)\n      number: /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)(?:\\.\\d+)?$/,\n  \n      // Matches a valid email address (e.g. mail@example.com)\n      email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n  \n      // Mathes any valid url (e.g. http://www.xample.com)\n      url: /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i\n    };\n  \n  \n    // Error messages\n    // --------------\n  \n    // Error message for the build in validators.\n    // {x} gets swapped out with arguments form the validator.\n    var defaultMessages = Validation.messages = {\n      required: '{0} is required',\n      acceptance: '{0} must be accepted',\n      min: '{0} must be greater than or equal to {1}',\n      max: '{0} must be less than or equal to {1}',\n      range: '{0} must be between {1} and {2}',\n      length: '{0} must be {1} characters',\n      minLength: '{0} must be at least {1} characters',\n      maxLength: '{0} must be at most {1} characters',\n      rangeLength: '{0} must be between {1} and {2} characters',\n      oneOf: '{0} must be one of: {1}',\n      equalTo: '{0} must be the same as {1}',\n      digits: '{0} must only contain digits',\n      number: '{0} must be a number',\n      email: '{0} must be a valid email',\n      url: '{0} must be a valid url',\n      inlinePattern: '{0} is invalid'\n    };\n  \n    // Label formatters\n    // ----------------\n  \n    // Label formatters are used to convert the attribute name\n    // to a more human friendly label when using the built in\n    // error messages.\n    // Configure which one to use with a call to\n    //\n    //     Backbone.Validation.configure({\n    //       labelFormatter: 'label'\n    //     });\n    var defaultLabelFormatters = Validation.labelFormatters = {\n  \n      // Returns the attribute name with applying any formatting\n      none: function(attrName) {\n        return attrName;\n      },\n  \n      // Converts attributeName or attribute_name to Attribute name\n      sentenceCase: function(attrName) {\n        return attrName.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(match, index) {\n          return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();\n        }).replace(/_/g, ' ');\n      },\n  \n      // Looks for a label configured on the model and returns it\n      //\n      //      var Model = Backbone.Model.extend({\n      //        validation: {\n      //          someAttribute: {\n      //            required: true\n      //          }\n      //        },\n      //\n      //        labels: {\n      //          someAttribute: 'Custom label'\n      //        }\n      //      });\n      label: function(attrName, model) {\n        return (model.labels && model.labels[attrName]) || defaultLabelFormatters.sentenceCase(attrName, model);\n      }\n    };\n  \n  \n    // Built in validators\n    // -------------------\n  \n    var defaultValidators = Validation.validators = (function(){\n      // Use native trim when defined\n      var trim = String.prototype.trim ?\n        function(text) {\n          return text === null ? '' : String.prototype.trim.call(text);\n        } :\n        function(text) {\n          var trimLeft = /^\\s+/,\n              trimRight = /\\s+$/;\n  \n          return text === null ? '' : text.toString().replace(trimLeft, '').replace(trimRight, '');\n        };\n  \n      // Determines whether or not a value is a number\n      var isNumber = function(value){\n        return _.isNumber(value) || (_.isString(value) && value.match(defaultPatterns.number));\n      };\n  \n      // Determines whether or not a value is empty\n      var hasValue = function(value) {\n        return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));\n      };\n  \n      return {\n        // Function validator\n        // Lets you implement a custom function used for validation\n        fn: function(value, attr, fn, model, computed) {\n          if(_.isString(fn)){\n            fn = model[fn];\n          }\n          return fn.call(model, value, attr, computed);\n        },\n  \n        // Required validator\n        // Validates if the attribute is required or not\n        // This can be specified as either a boolean value or a function that returns a boolean value\n        required: function(value, attr, required, model, computed) {\n          var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;\n          if(!isRequired && !hasValue(value)) {\n            return false; // overrides all other validators\n          }\n          if (isRequired && !hasValue(value)) {\n            return this.format(defaultMessages.required, this.formatLabel(attr, model));\n          }\n        },\n  \n        // Acceptance validator\n        // Validates that something has to be accepted, e.g. terms of use\n        // `true` or 'true' are valid\n        acceptance: function(value, attr, accept, model) {\n          if(value !== 'true' && (!_.isBoolean(value) || value === false)) {\n            return this.format(defaultMessages.acceptance, this.formatLabel(attr, model));\n          }\n        },\n  \n        // Min validator\n        // Validates that the value has to be a number and equal to or greater than\n        // the min value specified\n        min: function(value, attr, minValue, model) {\n          if (!isNumber(value) || value < minValue) {\n            return this.format(defaultMessages.min, this.formatLabel(attr, model), minValue);\n          }\n        },\n  \n        // Max validator\n        // Validates that the value has to be a number and equal to or less than\n        // the max value specified\n        max: function(value, attr, maxValue, model) {\n          if (!isNumber(value) || value > maxValue) {\n            return this.format(defaultMessages.max, this.formatLabel(attr, model), maxValue);\n          }\n        },\n  \n        // Range validator\n        // Validates that the value has to be a number and equal to or between\n        // the two numbers specified\n        range: function(value, attr, range, model) {\n          if(!isNumber(value) || value < range[0] || value > range[1]) {\n            return this.format(defaultMessages.range, this.formatLabel(attr, model), range[0], range[1]);\n          }\n        },\n  \n        // Length validator\n        // Validates that the value has to be a string with length equal to\n        // the length value specified\n        length: function(value, attr, length, model) {\n          if (!_.isString(value) || value.length !== length) {\n            return this.format(defaultMessages.length, this.formatLabel(attr, model), length);\n          }\n        },\n  \n        // Min length validator\n        // Validates that the value has to be a string with length equal to or greater than\n        // the min length value specified\n        minLength: function(value, attr, minLength, model) {\n          if (!_.isString(value) || value.length < minLength) {\n            return this.format(defaultMessages.minLength, this.formatLabel(attr, model), minLength);\n          }\n        },\n  \n        // Max length validator\n        // Validates that the value has to be a string with length equal to or less than\n        // the max length value specified\n        maxLength: function(value, attr, maxLength, model) {\n          if (!_.isString(value) || value.length > maxLength) {\n            return this.format(defaultMessages.maxLength, this.formatLabel(attr, model), maxLength);\n          }\n        },\n  \n        // Range length validator\n        // Validates that the value has to be a string and equal to or between\n        // the two numbers specified\n        rangeLength: function(value, attr, range, model) {\n          if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {\n            return this.format(defaultMessages.rangeLength, this.formatLabel(attr, model), range[0], range[1]);\n          }\n        },\n  \n        // One of validator\n        // Validates that the value has to be equal to one of the elements in\n        // the specified array. Case sensitive matching\n        oneOf: function(value, attr, values, model) {\n          if(!_.include(values, value)){\n            return this.format(defaultMessages.oneOf, this.formatLabel(attr, model), values.join(', '));\n          }\n        },\n  \n        // Equal to validator\n        // Validates that the value has to be equal to the value of the attribute\n        // with the name specified\n        equalTo: function(value, attr, equalTo, model, computed) {\n          if(value !== computed[equalTo]) {\n            return this.format(defaultMessages.equalTo, this.formatLabel(attr, model), this.formatLabel(equalTo, model));\n          }\n        },\n  \n        // Pattern validator\n        // Validates that the value has to match the pattern specified.\n        // Can be a regular expression or the name of one of the built in patterns\n        pattern: function(value, attr, pattern, model) {\n          if (!hasValue(value) || !value.toString().match(defaultPatterns[pattern] || pattern)) {\n            return this.format(defaultMessages[pattern] || defaultMessages.inlinePattern, this.formatLabel(attr, model), pattern);\n          }\n        }\n      };\n    }());\n  \n    // Set the correct context for all validators\n    // when used from within a method validator\n    _.each(defaultValidators, function(validator, key){\n      defaultValidators[key] = _.bind(defaultValidators[key], _.extend({}, formatFunctions, defaultValidators));\n    });\n  \n    return Validation;\n  }(_));\n  return Backbone.Validation;\n}));//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLXZhbGlkYXRpb24vZGlzdC9iYWNrYm9uZS12YWxpZGF0aW9uLWFtZC5qcz9iMjgzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1EQUFtRCw2QkFBNkI7QUFDaEY7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLElBQUksT0FBTyxFQUFFOztBQUV6QztBQUNBLG1EQUFtRCxHQUFHLG1GQUFtRixHQUFHOztBQUU1STtBQUNBLHlHQUF5RyxFQUFFLGtCQUFrQixrckJBQWtyQixFQUFFLGtCQUFrQixvRkFBb0YsRUFBRSxrQkFBa0IsMkZBQTJGLEVBQUUsa0JBQWtCLDhHQUE4RyxFQUFFLGtCQUFrQjtBQUM1cEM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEVBQUU7QUFDVjtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCLG9CQUFvQixFQUFFO0FBQ3RCLGFBQWEsRUFBRSxtQ0FBbUMsRUFBRTtBQUNwRCxhQUFhLEVBQUUsZ0NBQWdDLEVBQUU7QUFDakQsZUFBZSxFQUFFLGtCQUFrQixFQUFFLE1BQU0sRUFBRTtBQUM3QyxnQkFBZ0IsRUFBRSxVQUFVLEVBQUU7QUFDOUIsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUU7QUFDMUMsbUJBQW1CLEVBQUUsa0JBQWtCLEVBQUU7QUFDekMscUJBQXFCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxFQUFFO0FBQ25ELGVBQWUsRUFBRSxrQkFBa0IsRUFBRTtBQUNyQyxpQkFBaUIsRUFBRSxzQkFBc0IsRUFBRTtBQUMzQyxnQkFBZ0IsRUFBRTtBQUNsQixnQkFBZ0IsRUFBRTtBQUNsQixlQUFlLEVBQUU7QUFDakIsYUFBYSxFQUFFO0FBQ2YsdUJBQXVCLEVBQUU7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEJhY2tib25lLlZhbGlkYXRpb24gdjAuOS4xXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDExLTIwMTQgVGhvbWFzIFBlZGVyc2VuXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZVxuLy9cbi8vIERvY3VtZW50YXRpb24gYW5kIGZ1bGwgbGljZW5zZSBhdmFpbGFibGUgYXQ6XG4vLyBodHRwOi8vdGhlZGVyc2VuLmNvbS9wcm9qZWN0cy9iYWNrYm9uZS12YWxpZGF0aW9uXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdiYWNrYm9uZScpLCByZXF1aXJlKCd1bmRlcnNjb3JlJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2JhY2tib25lJywgJ3VuZGVyc2NvcmUnXSwgZmFjdG9yeSk7XG4gIH1cbn0oZnVuY3Rpb24gKEJhY2tib25lLCBfKSB7XG4gIEJhY2tib25lLlZhbGlkYXRpb24gPSAoZnVuY3Rpb24oXyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgICAgc2VsZWN0b3I6ICduYW1lJyxcbiAgICAgIGxhYmVsRm9ybWF0dGVyOiAnc2VudGVuY2VDYXNlJyxcbiAgICAgIHZhbGlkOiBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICBpbnZhbGlkOiBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICB9O1xuICBcbiAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgLy8gRm9ybWF0dGluZyBmdW5jdGlvbnMgdXNlZCBmb3IgZm9ybWF0dGluZyBlcnJvciBtZXNzYWdlc1xuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7XG4gICAgICAvLyBVc2VzIHRoZSBjb25maWd1cmVkIGxhYmVsIGZvcm1hdHRlciB0byBmb3JtYXQgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAvLyB0byBtYWtlIGl0IG1vcmUgcmVhZGFibGUgZm9yIHRoZSB1c2VyXG4gICAgICBmb3JtYXRMYWJlbDogZnVuY3Rpb24oYXR0ck5hbWUsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGFiZWxGb3JtYXR0ZXJzW2RlZmF1bHRPcHRpb25zLmxhYmVsRm9ybWF0dGVyXShhdHRyTmFtZSwgbW9kZWwpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBSZXBsYWNlcyBudW1tZXJpYyBwbGFjZWhvbGRlcnMgbGlrZSB7MH0gaW4gYSBzdHJpbmcgd2l0aCBhcmd1bWVudHNcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICAgIGZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHRleHQgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmdzW251bWJlcl0gIT09ICd1bmRlZmluZWQnID8gYXJnc1tudW1iZXJdIDogbWF0Y2g7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIEZsYXR0ZW5zIGFuIG9iamVjdFxuICAgIC8vIGVnOlxuICAgIC8vXG4gICAgLy8gICAgIHZhciBvID0ge1xuICAgIC8vICAgICAgIGFkZHJlc3M6IHtcbiAgICAvLyAgICAgICAgIHN0cmVldDogJ1N0cmVldCcsXG4gICAgLy8gICAgICAgICB6aXA6IDEyMzRcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH07XG4gICAgLy9cbiAgICAvLyBiZWNvbWVzOlxuICAgIC8vXG4gICAgLy8gICAgIHZhciBvID0ge1xuICAgIC8vICAgICAgICdhZGRyZXNzLnN0cmVldCc6ICdTdHJlZXQnLFxuICAgIC8vICAgICAgICdhZGRyZXNzLnppcCc6IDEyMzRcbiAgICAvLyAgICAgfTtcbiAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChvYmosIGludG8sIHByZWZpeCkge1xuICAgICAgaW50byA9IGludG8gfHwge307XG4gICAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gIFxuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICEoXG4gICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCB8fFxuICAgICAgICAgICAgdmFsIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZsYXR0ZW4odmFsLCBpbnRvLCBwcmVmaXggKyBrZXkgKyAnLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludG9bcHJlZml4ICsga2V5XSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICBcbiAgICAgIHJldHVybiBpbnRvO1xuICAgIH07XG4gIFxuICAgIC8vIFZhbGlkYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tXG4gIFxuICAgIHZhciBWYWxpZGF0aW9uID0gKGZ1bmN0aW9uKCl7XG4gIFxuICAgICAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1bmRlZmluZWQgcHJvcGVydGllcyBmb3IgYWxsXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCB0aGF0IGhhcyBkZWZpbmVkIG9uZSBvciBtb3JlXG4gICAgICAvLyB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgICAgdmFyIGdldFZhbGlkYXRlZEF0dHJzID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKF8ua2V5cyhfLnJlc3VsdChtb2RlbCwgJ3ZhbGlkYXRpb24nKSB8fCB7fSksIGZ1bmN0aW9uKG1lbW8sIGtleSkge1xuICAgICAgICAgIG1lbW9ba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwge30pO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBMb29rcyBvbiB0aGUgbW9kZWwgZm9yIHZhbGlkYXRpb25zIGZvciBhIHNwZWNpZmllZFxuICAgICAgLy8gYXR0cmlidXRlLiBSZXR1cm5zIGFuIGFycmF5IG9mIGFueSB2YWxpZGF0b3JzIGRlZmluZWQsXG4gICAgICAvLyBvciBhbiBlbXB0eSBhcnJheSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgICB2YXIgZ2V0VmFsaWRhdG9ycyA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRyKSB7XG4gICAgICAgIHZhciBhdHRyVmFsaWRhdGlvblNldCA9IG1vZGVsLnZhbGlkYXRpb24gPyBfLnJlc3VsdChtb2RlbCwgJ3ZhbGlkYXRpb24nKVthdHRyXSB8fCB7fSA6IHt9O1xuICBcbiAgICAgICAgLy8gSWYgdGhlIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLCB3cmFwIGl0IGluIGEgZnVuY3Rpb24gdmFsaWRhdG9yXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYXR0clZhbGlkYXRpb25TZXQpIHx8IF8uaXNTdHJpbmcoYXR0clZhbGlkYXRpb25TZXQpKSB7XG4gICAgICAgICAgYXR0clZhbGlkYXRpb25TZXQgPSB7XG4gICAgICAgICAgICBmbjogYXR0clZhbGlkYXRpb25TZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBTdGljayB0aGUgdmFsaWRhdG9yIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgIGlmKCFfLmlzQXJyYXkoYXR0clZhbGlkYXRpb25TZXQpKSB7XG4gICAgICAgICAgYXR0clZhbGlkYXRpb25TZXQgPSBbYXR0clZhbGlkYXRpb25TZXRdO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBSZWR1Y2VzIHRoZSBhcnJheSBvZiB2YWxpZGF0b3JzIGludG8gYSBuZXcgYXJyYXkgd2l0aCBvYmplY3RzXG4gICAgICAgIC8vIHdpdGggYSB2YWxpZGF0aW9uIG1ldGhvZCB0byBjYWxsLCB0aGUgdmFsdWUgdG8gdmFsaWRhdGUgYWdhaW5zdFxuICAgICAgICAvLyBhbmQgdGhlIHNwZWNpZmllZCBlcnJvciBtZXNzYWdlLCBpZiBhbnlcbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKGF0dHJWYWxpZGF0aW9uU2V0LCBmdW5jdGlvbihtZW1vLCBhdHRyVmFsaWRhdGlvbikge1xuICAgICAgICAgIF8uZWFjaChfLndpdGhvdXQoXy5rZXlzKGF0dHJWYWxpZGF0aW9uKSwgJ21zZycpLCBmdW5jdGlvbih2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaCh7XG4gICAgICAgICAgICAgIGZuOiBkZWZhdWx0VmFsaWRhdG9yc1t2YWxpZGF0b3JdLFxuICAgICAgICAgICAgICB2YWw6IGF0dHJWYWxpZGF0aW9uW3ZhbGlkYXRvcl0sXG4gICAgICAgICAgICAgIG1zZzogYXR0clZhbGlkYXRpb24ubXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgW10pO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBWYWxpZGF0ZXMgYW4gYXR0cmlidXRlIGFnYWluc3QgYWxsIHZhbGlkYXRvcnMgZGVmaW5lZFxuICAgICAgLy8gZm9yIHRoYXQgYXR0cmlidXRlLiBJZiBvbmUgb3IgbW9yZSBlcnJvcnMgYXJlIGZvdW5kLFxuICAgICAgLy8gdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgaXMgcmV0dXJuZWQuXG4gICAgICAvLyBJZiB0aGUgYXR0cmlidXRlIGlzIHZhbGlkLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gICAgICB2YXIgdmFsaWRhdGVBdHRyID0gZnVuY3Rpb24obW9kZWwsIGF0dHIsIHZhbHVlLCBjb21wdXRlZCkge1xuICAgICAgICAvLyBSZWR1Y2VzIHRoZSBhcnJheSBvZiB2YWxpZGF0b3JzIHRvIGFuIGVycm9yIG1lc3NhZ2UgYnlcbiAgICAgICAgLy8gYXBwbHlpbmcgYWxsIHRoZSB2YWxpZGF0b3JzIGFuZCByZXR1cm5pbmcgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgIC8vIG1lc3NhZ2UsIGlmIGFueS5cbiAgICAgICAgcmV0dXJuIF8ucmVkdWNlKGdldFZhbGlkYXRvcnMobW9kZWwsIGF0dHIpLCBmdW5jdGlvbihtZW1vLCB2YWxpZGF0b3Ipe1xuICAgICAgICAgIC8vIFBhc3MgdGhlIGZvcm1hdCBmdW5jdGlvbnMgcGx1cyB0aGUgZGVmYXVsdFxuICAgICAgICAgIC8vIHZhbGlkYXRvcnMgYXMgdGhlIGNvbnRleHQgdG8gdGhlIHZhbGlkYXRvclxuICAgICAgICAgIHZhciBjdHggPSBfLmV4dGVuZCh7fSwgZm9ybWF0RnVuY3Rpb25zLCBkZWZhdWx0VmFsaWRhdG9ycyksXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbGlkYXRvci5mbi5jYWxsKGN0eCwgdmFsdWUsIGF0dHIsIHZhbGlkYXRvci52YWwsIG1vZGVsLCBjb21wdXRlZCk7XG4gIFxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gZmFsc2UgfHwgbWVtbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiAhbWVtbykge1xuICAgICAgICAgICAgcmV0dXJuIF8ucmVzdWx0KHZhbGlkYXRvciwgJ21zZycpIHx8IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sICcnKTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgbW9kZWwncyBhdHRyaWJ1dGVzIGFuZCB2YWxpZGF0ZXMgdGhlbSBhbGwuXG4gICAgICAvLyBSZXR1cm5zIGFuZCBvYmplY3QgY29udGFpbmluZyBuYW1lcyBvZiBpbnZhbGlkIGF0dHJpYnV0ZXNcbiAgICAgIC8vIGFzIHdlbGwgYXMgZXJyb3IgbWVzc2FnZXMuXG4gICAgICB2YXIgdmFsaWRhdGVNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsLCBhdHRycykge1xuICAgICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgICBpbnZhbGlkQXR0cnMgPSB7fSxcbiAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBfLmNsb25lKGF0dHJzKSxcbiAgICAgICAgICAgIGZsYXR0ZW5lZCA9IGZsYXR0ZW4oYXR0cnMpO1xuICBcbiAgICAgICAgXy5lYWNoKGZsYXR0ZW5lZCwgZnVuY3Rpb24odmFsLCBhdHRyKSB7XG4gICAgICAgICAgZXJyb3IgPSB2YWxpZGF0ZUF0dHIobW9kZWwsIGF0dHIsIHZhbCwgY29tcHV0ZWQpO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaW52YWxpZEF0dHJzW2F0dHJdID0gZXJyb3I7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW52YWxpZEF0dHJzOiBpbnZhbGlkQXR0cnMsXG4gICAgICAgICAgaXNWYWxpZDogaXNWYWxpZFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBDb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IGFyZSBtaXhlZCBpbiBvbiB0aGUgbW9kZWwgd2hlbiBiaW5kaW5nXG4gICAgICB2YXIgbWl4aW4gPSBmdW5jdGlvbih2aWV3LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gIFxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUsIG9yIGEgaGFzaCBvZiB2YWx1ZXNcbiAgICAgICAgICAvLyBwYXNzZXMgdmFsaWRhdGlvbiB3aXRob3V0IHVwZGF0aW5nIHRoZSBtb2RlbFxuICAgICAgICAgIHByZVZhbGlkYXRlOiBmdW5jdGlvbihhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgICAgIGVycm9yO1xuICBcbiAgICAgICAgICAgIGlmKF8uaXNPYmplY3QoYXR0cikpe1xuICAgICAgICAgICAgICBfLmVhY2goYXR0ciwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5wcmVWYWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZihlcnJvcil7XG4gICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICAgICByZXR1cm4gXy5pc0VtcHR5KHJlc3VsdCkgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQXR0cih0aGlzLCBhdHRyLCB2YWx1ZSwgXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gIFxuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbiBhdHRyaWJ1dGUsIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgb3IgdGhlXG4gICAgICAgICAgLy8gZW50aXJlIG1vZGVsIGlzIHZhbGlkLiBQYXNzaW5nIHRydWUgd2lsbCBmb3JjZSBhIHZhbGlkYXRpb25cbiAgICAgICAgICAvLyBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbmVkID0gZmxhdHRlbih0aGlzLmF0dHJpYnV0ZXMpO1xuICBcbiAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcob3B0aW9uKSl7XG4gICAgICAgICAgICAgIHJldHVybiAhdmFsaWRhdGVBdHRyKHRoaXMsIG9wdGlvbiwgZmxhdHRlbmVkW29wdGlvbl0sIF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKF8uaXNBcnJheShvcHRpb24pKXtcbiAgICAgICAgICAgICAgcmV0dXJuIF8ucmVkdWNlKG9wdGlvbiwgZnVuY3Rpb24obWVtbywgYXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vICYmICF2YWxpZGF0ZUF0dHIodGhpcywgYXR0ciwgZmxhdHRlbmVkW2F0dHJdLCBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgIH0sIHRydWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob3B0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb24gPyB0aGlzLl9pc1ZhbGlkIDogdHJ1ZTtcbiAgICAgICAgICB9LFxuICBcbiAgICAgICAgICAvLyBUaGlzIGlzIGNhbGxlZCBieSBCYWNrYm9uZSB3aGVuIGl0IG5lZWRzIHRvIHBlcmZvcm0gdmFsaWRhdGlvbi5cbiAgICAgICAgICAvLyBZb3UgY2FuIGNhbGwgaXQgbWFudWFsbHkgd2l0aG91dCBhbnkgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAvLyBlbnRpcmUgbW9kZWwuXG4gICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBzZXRPcHRpb25zKXtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBbGwgPSAhYXR0cnMsXG4gICAgICAgICAgICAgICAgb3B0ID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZEF0dHJzID0gZ2V0VmFsaWRhdGVkQXR0cnMobW9kZWwpLFxuICAgICAgICAgICAgICAgIGFsbEF0dHJzID0gXy5leHRlbmQoe30sIHZhbGlkYXRlZEF0dHJzLCBtb2RlbC5hdHRyaWJ1dGVzLCBhdHRycyksXG4gICAgICAgICAgICAgICAgY2hhbmdlZEF0dHJzID0gZmxhdHRlbihhdHRycyB8fCBhbGxBdHRycyksXG4gIFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbGlkYXRlTW9kZWwobW9kZWwsIGFsbEF0dHJzKTtcbiAgXG4gICAgICAgICAgICBtb2RlbC5faXNWYWxpZCA9IHJlc3VsdC5pc1ZhbGlkO1xuICBcbiAgICAgICAgICAgIC8vIEFmdGVyIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkLCBsb29wIHRocm91Z2ggYWxsIHZhbGlkYXRlZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBhbmQgY2FsbCB0aGUgdmFsaWQgY2FsbGJhY2tzIHNvIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4gICAgICAgICAgICBfLmVhY2godmFsaWRhdGVkQXR0cnMsIGZ1bmN0aW9uKHZhbCwgYXR0cil7XG4gICAgICAgICAgICAgIHZhciBpbnZhbGlkID0gcmVzdWx0LmludmFsaWRBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbiAgICAgICAgICAgICAgaWYoIWludmFsaWQpe1xuICAgICAgICAgICAgICAgIG9wdC52YWxpZCh2aWV3LCBhdHRyLCBvcHQuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgICAvLyBBZnRlciB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZCwgbG9vcCB0aHJvdWdoIGFsbCB2YWxpZGF0ZWQgYW5kIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gYW5kIGNhbGwgdGhlIGludmFsaWQgY2FsbGJhY2sgc28gdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgIF8uZWFjaCh2YWxpZGF0ZWRBdHRycywgZnVuY3Rpb24odmFsLCBhdHRyKXtcbiAgICAgICAgICAgICAgdmFyIGludmFsaWQgPSByZXN1bHQuaW52YWxpZEF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWRBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbiAgXG4gICAgICAgICAgICAgIGlmKGludmFsaWQgJiYgKGNoYW5nZWQgfHwgdmFsaWRhdGVBbGwpKXtcbiAgICAgICAgICAgICAgICBvcHQuaW52YWxpZCh2aWV3LCBhdHRyLCByZXN1bHQuaW52YWxpZEF0dHJzW2F0dHJdLCBvcHQuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHZhbGlkYXRlZCBldmVudHMuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlZmVyIHRoaXMgc28gdGhlIG1vZGVsIGlzIGFjdHVhbGx5IHVwZGF0ZWQgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcigndmFsaWRhdGVkJywgbW9kZWwuX2lzVmFsaWQsIG1vZGVsLCByZXN1bHQuaW52YWxpZEF0dHJzKTtcbiAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcigndmFsaWRhdGVkOicgKyAobW9kZWwuX2lzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnKSwgbW9kZWwsIHJlc3VsdC5pbnZhbGlkQXR0cnMpO1xuICAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICAgLy8gUmV0dXJuIGFueSBlcnJvciBtZXNzYWdlcyB0byBCYWNrYm9uZSwgdW5sZXNzIHRoZSBmb3JjZVVwZGF0ZSBmbGFnIGlzIHNldC5cbiAgICAgICAgICAgIC8vIFRoZW4gd2UgZG8gbm90IHJldHVybiBhbnl0aGluZyBhbmQgZm9vbHMgQmFja2JvbmUgdG8gYmVsaWV2ZSB0aGUgdmFsaWRhdGlvbiB3YXNcbiAgICAgICAgICAgIC8vIGEgc3VjY2Vzcy4gVGhhdCB3YXkgQmFja2JvbmUgd2lsbCB1cGRhdGUgdGhlIG1vZGVsIHJlZ2FyZGxlc3MuXG4gICAgICAgICAgICBpZiAoIW9wdC5mb3JjZVVwZGF0ZSAmJiBfLmludGVyc2VjdGlvbihfLmtleXMocmVzdWx0LmludmFsaWRBdHRycyksIF8ua2V5cyhjaGFuZ2VkQXR0cnMpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaW52YWxpZEF0dHJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gSGVscGVyIHRvIG1peCBpbiB2YWxpZGF0aW9uIG9uIGEgbW9kZWxcbiAgICAgIHZhciBiaW5kTW9kZWwgPSBmdW5jdGlvbih2aWV3LCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBfLmV4dGVuZChtb2RlbCwgbWl4aW4odmlldywgb3B0aW9ucykpO1xuICAgICAgfTtcbiAgXG4gICAgICAvLyBSZW1vdmVzIHRoZSBtZXRob2RzIGFkZGVkIHRvIGEgbW9kZWxcbiAgICAgIHZhciB1bmJpbmRNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RlbC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIG1vZGVsLnByZVZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgbW9kZWwuaXNWYWxpZDtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gTWl4IGluIHZhbGlkYXRpb24gb24gYSBtb2RlbCB3aGVuZXZlciBhIG1vZGVsIGlzXG4gICAgICAvLyBhZGRlZCB0byBhIGNvbGxlY3Rpb25cbiAgICAgIHZhciBjb2xsZWN0aW9uQWRkID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgYmluZE1vZGVsKHRoaXMudmlldywgbW9kZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9O1xuICBcbiAgICAgIC8vIFJlbW92ZSB2YWxpZGF0aW9uIGZyb20gYSBtb2RlbCB3aGVuZXZlciBhIG1vZGVsIGlzXG4gICAgICAvLyByZW1vdmVkIGZyb20gYSBjb2xsZWN0aW9uXG4gICAgICB2YXIgY29sbGVjdGlvblJlbW92ZSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHVuYmluZE1vZGVsKG1vZGVsKTtcbiAgICAgIH07XG4gIFxuICAgICAgLy8gUmV0dXJucyB0aGUgcHVibGljIG1ldGhvZHMgb24gQmFja2JvbmUuVmFsaWRhdGlvblxuICAgICAgcmV0dXJuIHtcbiAgXG4gICAgICAgIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeVxuICAgICAgICB2ZXJzaW9uOiAnMC45LjEnLFxuICBcbiAgICAgICAgLy8gQ2FsbGVkIHRvIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIF8uZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIEhvb2tzIHVwIHZhbGlkYXRpb24gb24gYSB2aWV3IHdpdGggYSBtb2RlbFxuICAgICAgICAvLyBvciBjb2xsZWN0aW9uXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKHZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBkZWZhdWx0Q2FsbGJhY2tzLCBvcHRpb25zKTtcbiAgXG4gICAgICAgICAgdmFyIG1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCB2aWV3Lm1vZGVsLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uIHx8IHZpZXcuY29sbGVjdGlvbjtcbiAgXG4gICAgICAgICAgaWYodHlwZW9mIG1vZGVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgdGhyb3cgJ0JlZm9yZSB5b3UgZXhlY3V0ZSB0aGUgYmluZGluZyB5b3VyIHZpZXcgbXVzdCBoYXZlIGEgbW9kZWwgb3IgYSBjb2xsZWN0aW9uLlxcbicgK1xuICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vdGhlZGVyc2VuLmNvbS9wcm9qZWN0cy9iYWNrYm9uZS12YWxpZGF0aW9uLyN1c2luZy1mb3JtLW1vZGVsLXZhbGlkYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmKG1vZGVsKSB7XG4gICAgICAgICAgICBiaW5kTW9kZWwodmlldywgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihtb2RlbCl7XG4gICAgICAgICAgICAgIGJpbmRNb2RlbCh2aWV3LCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uYmluZCgnYWRkJywgY29sbGVjdGlvbkFkZCwge3ZpZXc6IHZpZXcsIG9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uYmluZCgncmVtb3ZlJywgY29sbGVjdGlvblJlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gUmVtb3ZlcyB2YWxpZGF0aW9uIGZyb20gYSB2aWV3IHdpdGggYSBtb2RlbFxuICAgICAgICAvLyBvciBjb2xsZWN0aW9uXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24odmlldywgb3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCB2aWV3Lm1vZGVsLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uIHx8IHZpZXcuY29sbGVjdGlvbjtcbiAgXG4gICAgICAgICAgaWYobW9kZWwpIHtcbiAgICAgICAgICAgIHVuYmluZE1vZGVsKG1vZGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICAgICAgICB1bmJpbmRNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24udW5iaW5kKCdhZGQnLCBjb2xsZWN0aW9uQWRkKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24udW5iaW5kKCdyZW1vdmUnLCBjb2xsZWN0aW9uUmVtb3ZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBVc2VkIHRvIGV4dGVuZCB0aGUgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlXG4gICAgICAgIC8vIHdpdGggdmFsaWRhdGlvblxuICAgICAgICBtaXhpbjogbWl4aW4obnVsbCwgZGVmYXVsdE9wdGlvbnMpXG4gICAgICB9O1xuICAgIH0oKSk7XG4gIFxuICBcbiAgICAvLyBDYWxsYmFja3NcbiAgICAvLyAtLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRDYWxsYmFja3MgPSBWYWxpZGF0aW9uLmNhbGxiYWNrcyA9IHtcbiAgXG4gICAgICAvLyBHZXRzIGNhbGxlZCB3aGVuIGEgcHJldmlvdXNseSBpbnZhbGlkIGZpZWxkIGluIHRoZVxuICAgICAgLy8gdmlldyBiZWNvbWVzIHZhbGlkLiBSZW1vdmVzIGFueSBlcnJvciBtZXNzYWdlLlxuICAgICAgLy8gU2hvdWxkIGJlIG92ZXJyaWRkZW4gd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAgICAgIHZhbGlkOiBmdW5jdGlvbih2aWV3LCBhdHRyLCBzZWxlY3Rvcikge1xuICAgICAgICB2aWV3LiQoJ1snICsgc2VsZWN0b3IgKyAnfj1cIicgKyBhdHRyICsgJ1wiXScpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2ludmFsaWQnKVxuICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtZXJyb3InKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gR2V0cyBjYWxsZWQgd2hlbiBhIGZpZWxkIGluIHRoZSB2aWV3IGJlY29tZXMgaW52YWxpZC5cbiAgICAgIC8vIEFkZHMgYSBlcnJvciBtZXNzYWdlLlxuICAgICAgLy8gU2hvdWxkIGJlIG92ZXJyaWRkZW4gd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAgICAgIGludmFsaWQ6IGZ1bmN0aW9uKHZpZXcsIGF0dHIsIGVycm9yLCBzZWxlY3Rvcikge1xuICAgICAgICB2aWV3LiQoJ1snICsgc2VsZWN0b3IgKyAnfj1cIicgKyBhdHRyICsgJ1wiXScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2ludmFsaWQnKVxuICAgICAgICAgICAgLmF0dHIoJ2RhdGEtZXJyb3InLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gIFxuICAgIC8vIFBhdHRlcm5zXG4gICAgLy8gLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRQYXR0ZXJucyA9IFZhbGlkYXRpb24ucGF0dGVybnMgPSB7XG4gICAgICAvLyBNYXRjaGVzIGFueSBkaWdpdChzKSAoaS5lLiAwLTkpXG4gICAgICBkaWdpdHM6IC9eXFxkKyQvLFxuICBcbiAgICAgIC8vIE1hdGNoZXMgYW55IG51bWJlciAoZS5nLiAxMDAuMDAwKVxuICAgICAgbnVtYmVyOiAvXi0/KD86XFxkK3xcXGR7MSwzfSg/OixcXGR7M30pKykoPzpcXC5cXGQrKT8kLyxcbiAgXG4gICAgICAvLyBNYXRjaGVzIGEgdmFsaWQgZW1haWwgYWRkcmVzcyAoZS5nLiBtYWlsQGV4YW1wbGUuY29tKVxuICAgICAgZW1haWw6IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaSxcbiAgXG4gICAgICAvLyBNYXRoZXMgYW55IHZhbGlkIHVybCAoZS5nLiBodHRwOi8vd3d3LnhhbXBsZS5jb20pXG4gICAgICB1cmw6IC9eKGh0dHBzP3xmdHApOlxcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pXG4gICAgfTtcbiAgXG4gIFxuICAgIC8vIEVycm9yIG1lc3NhZ2VzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgdGhlIGJ1aWxkIGluIHZhbGlkYXRvcnMuXG4gICAgLy8ge3h9IGdldHMgc3dhcHBlZCBvdXQgd2l0aCBhcmd1bWVudHMgZm9ybSB0aGUgdmFsaWRhdG9yLlxuICAgIHZhciBkZWZhdWx0TWVzc2FnZXMgPSBWYWxpZGF0aW9uLm1lc3NhZ2VzID0ge1xuICAgICAgcmVxdWlyZWQ6ICd7MH0gaXMgcmVxdWlyZWQnLFxuICAgICAgYWNjZXB0YW5jZTogJ3swfSBtdXN0IGJlIGFjY2VwdGVkJyxcbiAgICAgIG1pbjogJ3swfSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7MX0nLFxuICAgICAgbWF4OiAnezB9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHsxfScsXG4gICAgICByYW5nZTogJ3swfSBtdXN0IGJlIGJldHdlZW4gezF9IGFuZCB7Mn0nLFxuICAgICAgbGVuZ3RoOiAnezB9IG11c3QgYmUgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgbWluTGVuZ3RoOiAnezB9IG11c3QgYmUgYXQgbGVhc3QgezF9IGNoYXJhY3RlcnMnLFxuICAgICAgbWF4TGVuZ3RoOiAnezB9IG11c3QgYmUgYXQgbW9zdCB7MX0gY2hhcmFjdGVycycsXG4gICAgICByYW5nZUxlbmd0aDogJ3swfSBtdXN0IGJlIGJldHdlZW4gezF9IGFuZCB7Mn0gY2hhcmFjdGVycycsXG4gICAgICBvbmVPZjogJ3swfSBtdXN0IGJlIG9uZSBvZjogezF9JyxcbiAgICAgIGVxdWFsVG86ICd7MH0gbXVzdCBiZSB0aGUgc2FtZSBhcyB7MX0nLFxuICAgICAgZGlnaXRzOiAnezB9IG11c3Qgb25seSBjb250YWluIGRpZ2l0cycsXG4gICAgICBudW1iZXI6ICd7MH0gbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICBlbWFpbDogJ3swfSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgdXJsOiAnezB9IG11c3QgYmUgYSB2YWxpZCB1cmwnLFxuICAgICAgaW5saW5lUGF0dGVybjogJ3swfSBpcyBpbnZhbGlkJ1xuICAgIH07XG4gIFxuICAgIC8vIExhYmVsIGZvcm1hdHRlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIC8vIExhYmVsIGZvcm1hdHRlcnMgYXJlIHVzZWQgdG8gY29udmVydCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAvLyB0byBhIG1vcmUgaHVtYW4gZnJpZW5kbHkgbGFiZWwgd2hlbiB1c2luZyB0aGUgYnVpbHQgaW5cbiAgICAvLyBlcnJvciBtZXNzYWdlcy5cbiAgICAvLyBDb25maWd1cmUgd2hpY2ggb25lIHRvIHVzZSB3aXRoIGEgY2FsbCB0b1xuICAgIC8vXG4gICAgLy8gICAgIEJhY2tib25lLlZhbGlkYXRpb24uY29uZmlndXJlKHtcbiAgICAvLyAgICAgICBsYWJlbEZvcm1hdHRlcjogJ2xhYmVsJ1xuICAgIC8vICAgICB9KTtcbiAgICB2YXIgZGVmYXVsdExhYmVsRm9ybWF0dGVycyA9IFZhbGlkYXRpb24ubGFiZWxGb3JtYXR0ZXJzID0ge1xuICBcbiAgICAgIC8vIFJldHVybnMgdGhlIGF0dHJpYnV0ZSBuYW1lIHdpdGggYXBwbHlpbmcgYW55IGZvcm1hdHRpbmdcbiAgICAgIG5vbmU6IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQ29udmVydHMgYXR0cmlidXRlTmFtZSBvciBhdHRyaWJ1dGVfbmFtZSB0byBBdHRyaWJ1dGUgbmFtZVxuICAgICAgc2VudGVuY2VDYXNlOiBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gYXR0ck5hbWUucmVwbGFjZSgvKD86Xlxcd3xbQS1aXXxcXGJcXHcpL2csIGZ1bmN0aW9uKG1hdGNoLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IG1hdGNoLnRvVXBwZXJDYXNlKCkgOiAnICcgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KS5yZXBsYWNlKC9fL2csICcgJyk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIExvb2tzIGZvciBhIGxhYmVsIGNvbmZpZ3VyZWQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5zIGl0XG4gICAgICAvL1xuICAgICAgLy8gICAgICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgICAgLy8gICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgIC8vICAgICAgICAgIHNvbWVBdHRyaWJ1dGU6IHtcbiAgICAgIC8vICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIC8vICAgICAgICAgIH1cbiAgICAgIC8vICAgICAgICB9LFxuICAgICAgLy9cbiAgICAgIC8vICAgICAgICBsYWJlbHM6IHtcbiAgICAgIC8vICAgICAgICAgIHNvbWVBdHRyaWJ1dGU6ICdDdXN0b20gbGFiZWwnXG4gICAgICAvLyAgICAgICAgfVxuICAgICAgLy8gICAgICB9KTtcbiAgICAgIGxhYmVsOiBmdW5jdGlvbihhdHRyTmFtZSwgbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlbC5sYWJlbHMgJiYgbW9kZWwubGFiZWxzW2F0dHJOYW1lXSkgfHwgZGVmYXVsdExhYmVsRm9ybWF0dGVycy5zZW50ZW5jZUNhc2UoYXR0ck5hbWUsIG1vZGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgXG4gICAgLy8gQnVpbHQgaW4gdmFsaWRhdG9yc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgdmFyIGRlZmF1bHRWYWxpZGF0b3JzID0gVmFsaWRhdGlvbi52YWxpZGF0b3JzID0gKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBVc2UgbmF0aXZlIHRyaW0gd2hlbiBkZWZpbmVkXG4gICAgICB2YXIgdHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/XG4gICAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dCA9PT0gbnVsbCA/ICcnIDogU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwodGV4dCk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICAgICAgICAgICAgdHJpbVJpZ2h0ID0gL1xccyskLztcbiAgXG4gICAgICAgICAgcmV0dXJuIHRleHQgPT09IG51bGwgPyAnJyA6IHRleHQudG9TdHJpbmcoKS5yZXBsYWNlKHRyaW1MZWZ0LCAnJykucmVwbGFjZSh0cmltUmlnaHQsICcnKTtcbiAgICAgICAgfTtcbiAgXG4gICAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBudW1iZXJcbiAgICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIF8uaXNOdW1iZXIodmFsdWUpIHx8IChfLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaChkZWZhdWx0UGF0dGVybnMubnVtYmVyKSk7XG4gICAgICB9O1xuICBcbiAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBlbXB0eVxuICAgICAgdmFyIGhhc1ZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEoXy5pc051bGwodmFsdWUpIHx8IF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IChfLmlzU3RyaW5nKHZhbHVlKSAmJiB0cmltKHZhbHVlKSA9PT0gJycpIHx8IChfLmlzQXJyYXkodmFsdWUpICYmIF8uaXNFbXB0eSh2YWx1ZSkpKTtcbiAgICAgIH07XG4gIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gdmFsaWRhdG9yXG4gICAgICAgIC8vIExldHMgeW91IGltcGxlbWVudCBhIGN1c3RvbSBmdW5jdGlvbiB1c2VkIGZvciB2YWxpZGF0aW9uXG4gICAgICAgIGZuOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgZm4sIG1vZGVsLCBjb21wdXRlZCkge1xuICAgICAgICAgIGlmKF8uaXNTdHJpbmcoZm4pKXtcbiAgICAgICAgICAgIGZuID0gbW9kZWxbZm5dO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uY2FsbChtb2RlbCwgdmFsdWUsIGF0dHIsIGNvbXB1dGVkKTtcbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIFJlcXVpcmVkIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgaWYgdGhlIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvciBub3RcbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhIGJvb2xlYW4gdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIHZhbHVlXG4gICAgICAgIHJlcXVpcmVkOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgcmVxdWlyZWQsIG1vZGVsLCBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gXy5pc0Z1bmN0aW9uKHJlcXVpcmVkKSA/IHJlcXVpcmVkLmNhbGwobW9kZWwsIHZhbHVlLCBhdHRyLCBjb21wdXRlZCkgOiByZXF1aXJlZDtcbiAgICAgICAgICBpZighaXNSZXF1aXJlZCAmJiAhaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgdmFsaWRhdG9yc1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZXF1aXJlZCAmJiAhaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLnJlcXVpcmVkLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gQWNjZXB0YW5jZSB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgc29tZXRoaW5nIGhhcyB0byBiZSBhY2NlcHRlZCwgZS5nLiB0ZXJtcyBvZiB1c2VcbiAgICAgICAgLy8gYHRydWVgIG9yICd0cnVlJyBhcmUgdmFsaWRcbiAgICAgICAgYWNjZXB0YW5jZTogZnVuY3Rpb24odmFsdWUsIGF0dHIsIGFjY2VwdCwgbW9kZWwpIHtcbiAgICAgICAgICBpZih2YWx1ZSAhPT0gJ3RydWUnICYmICghXy5pc0Jvb2xlYW4odmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMuYWNjZXB0YW5jZSwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1pbiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIG51bWJlciBhbmQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4gICAgICAgIC8vIHRoZSBtaW4gdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1pbjogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1pblZhbHVlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWluLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWluVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1heCB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIG51bWJlciBhbmQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAgICAgIC8vIHRoZSBtYXggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1heDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1heFZhbHVlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWF4LCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWF4VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIFJhbmdlIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaGFzIHRvIGJlIGEgbnVtYmVyIGFuZCBlcXVhbCB0byBvciBiZXR3ZWVuXG4gICAgICAgIC8vIHRoZSB0d28gbnVtYmVycyBzcGVjaWZpZWRcbiAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCByYW5nZSwgbW9kZWwpIHtcbiAgICAgICAgICBpZighaXNOdW1iZXIodmFsdWUpIHx8IHZhbHVlIDwgcmFuZ2VbMF0gfHwgdmFsdWUgPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5yYW5nZSwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gTGVuZ3RoIHZhbGlkYXRvclxuICAgICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaGFzIHRvIGJlIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGVxdWFsIHRvXG4gICAgICAgIC8vIHRoZSBsZW5ndGggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIGxlbmd0aCwgbW9kZWwpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLmxlbmd0aCwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIGxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gTWluIGxlbmd0aCB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBhIHN0cmluZyB3aXRoIGxlbmd0aCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cbiAgICAgICAgLy8gdGhlIG1pbiBsZW5ndGggdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgIG1pbkxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIG1pbkxlbmd0aCwgbW9kZWwpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5taW5MZW5ndGgsIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCBtaW5MZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE1heCBsZW5ndGggdmFsaWRhdG9yXG4gICAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBoYXMgdG8gYmUgYSBzdHJpbmcgd2l0aCBsZW5ndGggZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAgICAgIC8vIHRoZSBtYXggbGVuZ3RoIHZhbHVlIHNwZWNpZmllZFxuICAgICAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCBtYXhMZW5ndGgsIG1vZGVsKSB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMubWF4TGVuZ3RoLCB0aGlzLmZvcm1hdExhYmVsKGF0dHIsIG1vZGVsKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBSYW5nZSBsZW5ndGggdmFsaWRhdG9yXG4gICAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBoYXMgdG8gYmUgYSBzdHJpbmcgYW5kIGVxdWFsIHRvIG9yIGJldHdlZW5cbiAgICAgICAgLy8gdGhlIHR3byBudW1iZXJzIHNwZWNpZmllZFxuICAgICAgICByYW5nZUxlbmd0aDogZnVuY3Rpb24odmFsdWUsIGF0dHIsIHJhbmdlLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoIDwgcmFuZ2VbMF0gfHwgdmFsdWUubGVuZ3RoID4gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWZhdWx0TWVzc2FnZXMucmFuZ2VMZW5ndGgsIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCByYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgXG4gICAgICAgIC8vIE9uZSBvZiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGVsZW1lbnRzIGluXG4gICAgICAgIC8vIHRoZSBzcGVjaWZpZWQgYXJyYXkuIENhc2Ugc2Vuc2l0aXZlIG1hdGNoaW5nXG4gICAgICAgIG9uZU9mOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgdmFsdWVzLCBtb2RlbCkge1xuICAgICAgICAgIGlmKCFfLmluY2x1ZGUodmFsdWVzLCB2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlcy5vbmVPZiwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHZhbHVlcy5qb2luKCcsICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gIFxuICAgICAgICAvLyBFcXVhbCB0byB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBiZSBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAvLyB3aXRoIHRoZSBuYW1lIHNwZWNpZmllZFxuICAgICAgICBlcXVhbFRvOiBmdW5jdGlvbih2YWx1ZSwgYXR0ciwgZXF1YWxUbywgbW9kZWwsIGNvbXB1dGVkKSB7XG4gICAgICAgICAgaWYodmFsdWUgIT09IGNvbXB1dGVkW2VxdWFsVG9dKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVmYXVsdE1lc3NhZ2VzLmVxdWFsVG8sIHRoaXMuZm9ybWF0TGFiZWwoYXR0ciwgbW9kZWwpLCB0aGlzLmZvcm1hdExhYmVsKGVxdWFsVG8sIG1vZGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICBcbiAgICAgICAgLy8gUGF0dGVybiB2YWxpZGF0b3JcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGhhcyB0byBtYXRjaCB0aGUgcGF0dGVybiBzcGVjaWZpZWQuXG4gICAgICAgIC8vIENhbiBiZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciB0aGUgbmFtZSBvZiBvbmUgb2YgdGhlIGJ1aWx0IGluIHBhdHRlcm5zXG4gICAgICAgIHBhdHRlcm46IGZ1bmN0aW9uKHZhbHVlLCBhdHRyLCBwYXR0ZXJuLCBtb2RlbCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUodmFsdWUpIHx8ICF2YWx1ZS50b1N0cmluZygpLm1hdGNoKGRlZmF1bHRQYXR0ZXJuc1twYXR0ZXJuXSB8fCBwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZmF1bHRNZXNzYWdlc1twYXR0ZXJuXSB8fCBkZWZhdWx0TWVzc2FnZXMuaW5saW5lUGF0dGVybiwgdGhpcy5mb3JtYXRMYWJlbChhdHRyLCBtb2RlbCksIHBhdHRlcm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCkpO1xuICBcbiAgICAvLyBTZXQgdGhlIGNvcnJlY3QgY29udGV4dCBmb3IgYWxsIHZhbGlkYXRvcnNcbiAgICAvLyB3aGVuIHVzZWQgZnJvbSB3aXRoaW4gYSBtZXRob2QgdmFsaWRhdG9yXG4gICAgXy5lYWNoKGRlZmF1bHRWYWxpZGF0b3JzLCBmdW5jdGlvbih2YWxpZGF0b3IsIGtleSl7XG4gICAgICBkZWZhdWx0VmFsaWRhdG9yc1trZXldID0gXy5iaW5kKGRlZmF1bHRWYWxpZGF0b3JzW2tleV0sIF8uZXh0ZW5kKHt9LCBmb3JtYXRGdW5jdGlvbnMsIGRlZmF1bHRWYWxpZGF0b3JzKSk7XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBWYWxpZGF0aW9uO1xuICB9KF8pKTtcbiAgcmV0dXJuIEJhY2tib25lLlZhbGlkYXRpb247XG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja2JvbmUtdmFsaWRhdGlvbi9kaXN0L2JhY2tib25lLXZhbGlkYXRpb24tYW1kLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjIyLmpzIn0=");

/***/ },
/* 23 */
/*!***************************************************************!*\
  !*** ./~/backbone.marionette/lib/core/backbone.marionette.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MarionetteJS (Backbone.Marionette)\n// ----------------------------------\n// v2.3.0\n//\n// Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.\n// Distributed under MIT license\n//\n// http://marionettejs.com\n\n(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ 1), __webpack_require__(/*! underscore */ 2), __webpack_require__(/*! backbone.wreqr */ 65), __webpack_require__(/*! backbone.babysitter */ 68)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {\n      return (root.Marionette = root.Mn = factory(root, Backbone, _));\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== 'undefined') {\n    var Backbone = require('backbone');\n    Backbone.$ = require('jquery');\n    var _ = require('underscore');\n    //var Wreqr = require('backbone.wreqr');\n    var BabySitter = require('backbone.babysitter');\n    module.exports = factory(root, Backbone, _);\n  } else {\n    root.Marionette = root.Mn = factory(root, root.Backbone, root._);\n  }\n\n}(this, function(root, Backbone, _) {\n  'use strict';\n\n  var previousMarionette = root.Marionette;\n  var previousMn = root.Mn;\n\n  var Marionette = Backbone.Marionette = {};\n\n  Marionette.VERSION = '2.3.0';\n\n  Marionette.noConflict = function() {\n    root.Marionette = previousMarionette;\n    root.Mn = previousMn;\n    return this;\n  };\n\n  // Get the Deferred creator for later use\n  Marionette.Deferred = Backbone.$.Deferred;\n\n  /* jshint unused: false *//* global console */\n  \n  // Helpers\n  // -------\n  \n  // Marionette.extend\n  // -----------------\n  \n  // Borrow the Backbone `extend` method so we can use it as needed\n  Marionette.extend = Backbone.Model.extend;\n  \n  // Marionette.isNodeAttached\n  // -------------------------\n  \n  // Determine if `el` is a child of the document\n  Marionette.isNodeAttached = function(el) {\n    return Backbone.$.contains(document.documentElement, el);\n  };\n  \n  \n  // Marionette.getOption\n  // --------------------\n  \n  // Retrieve an object, function or other value from a target\n  // object or its `options`, with `options` taking precedence.\n  Marionette.getOption = function(target, optionName) {\n    if (!target || !optionName) { return; }\n    if (target.options && (target.options[optionName] !== undefined)) {\n      return target.options[optionName];\n    } else {\n      return target[optionName];\n    }\n  };\n  \n  // Proxy `Marionette.getOption`\n  Marionette.proxyGetOption = function(optionName) {\n    return Marionette.getOption(this, optionName);\n  };\n  \n  // Marionette.normalizeMethods\n  // ----------------------\n  \n  // Pass in a mapping of events => functions or function names\n  // and return a mapping of events => functions\n  Marionette.normalizeMethods = function(hash) {\n    return _.reduce(hash, function(normalizedHash, method, name) {\n      if (!_.isFunction(method)) {\n        method = this[method];\n      }\n      if (method) {\n        normalizedHash[name] = method;\n      }\n      return normalizedHash;\n    }, {}, this);\n  };\n  \n  // utility method for parsing @ui. syntax strings\n  // into associated selector\n  Marionette.normalizeUIString = function(uiString, ui) {\n    return uiString.replace(/@ui\\.[a-zA-Z_$0-9]*/g, function(r) {\n      return ui[r.slice(4)];\n    });\n  };\n  \n  // allows for the use of the @ui. syntax within\n  // a given key for triggers and events\n  // swaps the @ui with the associated selector.\n  // Returns a new, non-mutated, parsed events hash.\n  Marionette.normalizeUIKeys = function(hash, ui) {\n    return _.reduce(hash, function(memo, val, key) {\n      var normalizedKey = Marionette.normalizeUIString(key, ui);\n      memo[normalizedKey] = val;\n      return memo;\n    }, {});\n  };\n  \n  // allows for the use of the @ui. syntax within\n  // a given value for regions\n  // swaps the @ui with the associated selector\n  Marionette.normalizeUIValues = function(hash, ui) {\n    _.each(hash, function(val, key) {\n      if (_.isString(val)) {\n        hash[key] = Marionette.normalizeUIString(val, ui);\n      }\n    });\n    return hash;\n  };\n  \n  // Mix in methods from Underscore, for iteration, and other\n  // collection related features.\n  // Borrowing this code from Backbone.Collection:\n  // http://backbonejs.org/docs/backbone.html#section-121\n  Marionette.actAsCollection = function(object, listProperty) {\n    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n      'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n      'last', 'without', 'isEmpty', 'pluck'];\n  \n    _.each(methods, function(method) {\n      object[method] = function() {\n        var list = _.values(_.result(this, listProperty));\n        var args = [list].concat(_.toArray(arguments));\n        return _[method].apply(_, args);\n      };\n    });\n  };\n  \n  var deprecate = Marionette.deprecate = function(message, test) {\n    if (_.isObject(message)) {\n      message = (\n        message.prev + ' is going to be removed in the future. ' +\n        'Please use ' + message.next + ' instead.' +\n        (message.url ? ' See: ' + message.url : '')\n      );\n    }\n  \n    if ((test === undefined || !test) && !deprecate._cache[message]) {\n      deprecate._warn('Deprecation warning: ' + message);\n      deprecate._cache[message] = true;\n    }\n  };\n  \n  deprecate._warn = typeof console !== 'undefined' && (console.warn || console.log) || function() {};\n  deprecate._cache = {};\n  \n  /* jshint maxstatements: 14, maxcomplexity: 7 */\n  \n  // Trigger Method\n  // --------------\n  \n  \n  Marionette._triggerMethod = (function() {\n    // split the event name on the \":\"\n    var splitter = /(^|:)(\\w)/gi;\n  \n    // take the event section (\"section1:section2:section3\")\n    // and turn it in to uppercase name\n    function getEventName(match, prefix, eventName) {\n      return eventName.toUpperCase();\n    }\n  \n    return function(context, event, args) {\n      var noEventArg = arguments.length < 3;\n      if (noEventArg) {\n        args = event;\n        event = args[0];\n      }\n  \n      // get the method name from the event name\n      var methodName = 'on' + event.replace(splitter, getEventName);\n      var method = context[methodName];\n      var result;\n  \n      // call the onMethodName if it exists\n      if (_.isFunction(method)) {\n        // pass all args, except the event name\n        result = method.apply(context, noEventArg ? _.rest(args) : args);\n      }\n  \n      // trigger the event, if a trigger method exists\n      if (_.isFunction(context.trigger)) {\n        if (noEventArg + args.length > 1) {\n          context.trigger.apply(context, noEventArg ? args : [event].concat(_.rest(args, 0)));\n        } else {\n          context.trigger(event);\n        }\n      }\n  \n      return result;\n    };\n  })();\n  \n  // Trigger an event and/or a corresponding method name. Examples:\n  //\n  // `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n  // call the \"onFoo\" method.\n  //\n  // `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n  // call the \"onFooBar\" method.\n  Marionette.triggerMethod = function(event) {\n    return Marionette._triggerMethod(this, arguments);\n  };\n  \n  // triggerMethodOn invokes triggerMethod on a specific context\n  //\n  // e.g. `Marionette.triggerMethodOn(view, 'show')`\n  // will trigger a \"show\" event or invoke onShow the view.\n  Marionette.triggerMethodOn = function(context) {\n    var fnc = _.isFunction(context.triggerMethod) ?\n                  context.triggerMethod :\n                  Marionette.triggerMethod;\n  \n    return fnc.apply(context, _.rest(arguments));\n  };\n  \n  // DOM Refresh\n  // -----------\n  \n  // Monitor a view's state, and after it has been rendered and shown\n  // in the DOM, trigger a \"dom:refresh\" event every time it is\n  // re-rendered.\n  \n  Marionette.MonitorDOMRefresh = function(view) {\n  \n    // track when the view has been shown in the DOM,\n    // using a Marionette.Region (or by other means of triggering \"show\")\n    function handleShow() {\n      view._isShown = true;\n      triggerDOMRefresh();\n    }\n  \n    // track when the view has been rendered\n    function handleRender() {\n      view._isRendered = true;\n      triggerDOMRefresh();\n    }\n  \n    // Trigger the \"dom:refresh\" event and corresponding \"onDomRefresh\" method\n    function triggerDOMRefresh() {\n      if (view._isShown && view._isRendered && Marionette.isNodeAttached(view.el)) {\n        if (_.isFunction(view.triggerMethod)) {\n          view.triggerMethod('dom:refresh');\n        }\n      }\n    }\n  \n    view.on({\n      show: handleShow,\n      render: handleRender\n    });\n  };\n  \n  /* jshint maxparams: 5 */\n  \n  // Bind Entity Events & Unbind Entity Events\n  // -----------------------------------------\n  //\n  // These methods are used to bind/unbind a backbone \"entity\" (collection/model)\n  // to methods on a target object.\n  //\n  // The first parameter, `target`, must have a `listenTo` method from the\n  // EventBinder object.\n  //\n  // The second parameter is the entity (Backbone.Model or Backbone.Collection)\n  // to bind the events from.\n  //\n  // The third parameter is a hash of { \"event:name\": \"eventHandler\" }\n  // configuration. Multiple handlers can be separated by a space. A\n  // function can be supplied instead of a string handler name.\n  \n  (function(Marionette) {\n    'use strict';\n  \n    // Bind the event to handlers specified as a string of\n    // handler names on the target object\n    function bindFromStrings(target, entity, evt, methods) {\n      var methodNames = methods.split(/\\s+/);\n  \n      _.each(methodNames, function(methodName) {\n  \n        var method = target[methodName];\n        if (!method) {\n          throw new Marionette.Error('Method \"' + methodName +\n            '\" was configured as an event handler, but does not exist.');\n        }\n  \n        target.listenTo(entity, evt, method);\n      });\n    }\n  \n    // Bind the event to a supplied callback function\n    function bindToFunction(target, entity, evt, method) {\n      target.listenTo(entity, evt, method);\n    }\n  \n    // Bind the event to handlers specified as a string of\n    // handler names on the target object\n    function unbindFromStrings(target, entity, evt, methods) {\n      var methodNames = methods.split(/\\s+/);\n  \n      _.each(methodNames, function(methodName) {\n        var method = target[methodName];\n        target.stopListening(entity, evt, method);\n      });\n    }\n  \n    // Bind the event to a supplied callback function\n    function unbindToFunction(target, entity, evt, method) {\n      target.stopListening(entity, evt, method);\n    }\n  \n  \n    // generic looping function\n    function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n      if (!entity || !bindings) { return; }\n  \n      // type-check bindings\n      if (!_.isFunction(bindings) && !_.isObject(bindings)) {\n        throw new Marionette.Error({\n          message: 'Bindings must be an object or function.',\n          url: 'marionette.functions.html#marionettebindentityevents'\n        });\n      }\n  \n      // allow the bindings to be a function\n      if (_.isFunction(bindings)) {\n        bindings = bindings.call(target);\n      }\n  \n      // iterate the bindings and bind them\n      _.each(bindings, function(methods, evt) {\n  \n        // allow for a function as the handler,\n        // or a list of event names as a string\n        if (_.isFunction(methods)) {\n          functionCallback(target, entity, evt, methods);\n        } else {\n          stringCallback(target, entity, evt, methods);\n        }\n  \n      });\n    }\n  \n    // Export Public API\n    Marionette.bindEntityEvents = function(target, entity, bindings) {\n      iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);\n    };\n  \n    Marionette.unbindEntityEvents = function(target, entity, bindings) {\n      iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);\n    };\n  \n    // Proxy `bindEntityEvents`\n    Marionette.proxyBindEntityEvents = function(entity, bindings) {\n      return Marionette.bindEntityEvents(this, entity, bindings);\n    };\n  \n    // Proxy `unbindEntityEvents`\n    Marionette.proxyUnbindEntityEvents = function(entity, bindings) {\n      return Marionette.unbindEntityEvents(this, entity, bindings);\n    };\n  })(Marionette);\n  \n\n  // Error\n  // -----\n  \n  var errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];\n  \n  Marionette.Error = Marionette.extend.call(Error, {\n    urlRoot: 'http://marionettejs.com/docs/v' + Marionette.VERSION + '/',\n  \n    constructor: function(message, options) {\n      if (_.isObject(message)) {\n        options = message;\n        message = options.message;\n      } else if (!options) {\n        options = {};\n      }\n  \n      var error = Error.call(this, message);\n      _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));\n  \n      this.captureStackTrace();\n  \n      if (options.url) {\n        this.url = this.urlRoot + options.url;\n      }\n    },\n  \n    captureStackTrace: function() {\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, Marionette.Error);\n      }\n    },\n  \n    toString: function() {\n      return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');\n    }\n  });\n  \n  Marionette.Error.extend = Marionette.extend;\n  \n  // Callbacks\n  // ---------\n  \n  // A simple way of managing a collection of callbacks\n  // and executing them at a later point in time, using jQuery's\n  // `Deferred` object.\n  Marionette.Callbacks = function() {\n    this._deferred = Marionette.Deferred();\n    this._callbacks = [];\n  };\n  \n  _.extend(Marionette.Callbacks.prototype, {\n  \n    // Add a callback to be executed. Callbacks added here are\n    // guaranteed to execute, even if they are added after the\n    // `run` method is called.\n    add: function(callback, contextOverride) {\n      var promise = _.result(this._deferred, 'promise');\n  \n      this._callbacks.push({cb: callback, ctx: contextOverride});\n  \n      promise.then(function(args) {\n        if (contextOverride){ args.context = contextOverride; }\n        callback.call(args.context, args.options);\n      });\n    },\n  \n    // Run all registered callbacks with the context specified.\n    // Additional callbacks can be added after this has been run\n    // and they will still be executed.\n    run: function(options, context) {\n      this._deferred.resolve({\n        options: options,\n        context: context\n      });\n    },\n  \n    // Resets the list of callbacks to be run, allowing the same list\n    // to be run multiple times - whenever the `run` method is called.\n    reset: function() {\n      var callbacks = this._callbacks;\n      this._deferred = Marionette.Deferred();\n      this._callbacks = [];\n  \n      _.each(callbacks, function(cb) {\n        this.add(cb.cb, cb.ctx);\n      }, this);\n    }\n  });\n  \n  // Controller\n  // ----------\n  \n  // A multi-purpose object to use as a controller for\n  // modules and routers, and as a mediator for workflow\n  // and coordination of other objects, views, and more.\n  Marionette.Controller = function(options) {\n    this.options = options || {};\n  \n    if (_.isFunction(this.initialize)) {\n      this.initialize(this.options);\n    }\n  };\n  \n  Marionette.Controller.extend = Marionette.extend;\n  \n  // Controller Methods\n  // --------------\n  \n  // Ensure it can trigger events with Backbone.Events\n  _.extend(Marionette.Controller.prototype, Backbone.Events, {\n    destroy: function() {\n      Marionette._triggerMethod(this, 'before:destroy', arguments);\n      Marionette._triggerMethod(this, 'destroy', arguments);\n  \n      this.stopListening();\n      this.off();\n      return this;\n    },\n  \n    // import the `triggerMethod` to trigger events with corresponding\n    // methods if the method exists\n    triggerMethod: Marionette.triggerMethod,\n  \n    // Proxy `getOption` to enable getting options from this or this.options by name.\n    getOption: Marionette.proxyGetOption\n  \n  });\n  \n  // Object\n  // ------\n  \n  // A Base Class that other Classes should descend from.\n  // Object borrows many conventions and utilities from Backbone.\n  Marionette.Object = function(options) {\n    this.options = _.extend({}, _.result(this, 'options'), options);\n  \n    this.initialize.apply(this, arguments);\n  };\n  \n  Marionette.Object.extend = Marionette.extend;\n  \n  // Object Methods\n  // --------------\n  \n  // Ensure it can trigger events with Backbone.Events\n  _.extend(Marionette.Object.prototype, Backbone.Events, {\n  \n    //this is a noop method intended to be overridden by classes that extend from this base\n    initialize: function() {},\n  \n    destroy: function() {\n      this.triggerMethod('before:destroy');\n      this.triggerMethod('destroy');\n      this.stopListening();\n    },\n  \n    // Import the `triggerMethod` to trigger events with corresponding\n    // methods if the method exists\n    triggerMethod: Marionette.triggerMethod,\n  \n    // Proxy `getOption` to enable getting options from this or this.options by name.\n    getOption: Marionette.proxyGetOption,\n  \n    // Proxy `bindEntityEvents` to enable binding view's events from another entity.\n    bindEntityEvents: Marionette.proxyBindEntityEvents,\n  \n    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.\n    unbindEntityEvents: Marionette.proxyUnbindEntityEvents\n  });\n  \n  /* jshint maxcomplexity: 16, maxstatements: 45, maxlen: 120 */\n  \n  // Region\n  // ------\n  \n  // Manage the visual regions of your composite application. See\n  // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/\n  \n  Marionette.Region = Marionette.Object.extend({\n    constructor: function (options) {\n  \n      // set options temporarily so that we can get `el`.\n      // options will be overriden by Object.constructor\n      this.options = options || {};\n      this.el = this.getOption('el');\n  \n      // Handle when this.el is passed in as a $ wrapped element.\n      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;\n  \n      if (!this.el) {\n        throw new Marionette.Error({\n          name: 'NoElError',\n          message: 'An \"el\" must be specified for a region.'\n        });\n      }\n  \n      this.$el = this.getEl(this.el);\n      Marionette.Object.call(this, options);\n    },\n  \n    // Displays a backbone view instance inside of the region.\n    // Handles calling the `render` method for you. Reads content\n    // directly from the `el` attribute. Also calls an optional\n    // `onShow` and `onDestroy` method on your view, just after showing\n    // or just before destroying the view, respectively.\n    // The `preventDestroy` option can be used to prevent a view from\n    // the old view being destroyed on show.\n    // The `forceShow` option can be used to force a view to be\n    // re-rendered if it's already shown in the region.\n    show: function(view, options){\n      if (!this._ensureElement()) {\n        return;\n      }\n  \n      this._ensureViewIsIntact(view);\n  \n      var showOptions     = options || {};\n      var isDifferentView = view !== this.currentView;\n      var preventDestroy  = !!showOptions.preventDestroy;\n      var forceShow       = !!showOptions.forceShow;\n  \n      // We are only changing the view if there is a current view to change to begin with\n      var isChangingView = !!this.currentView;\n  \n      // Only destroy the current view if we don't want to `preventDestroy` and if\n      // the view given in the first argument is different than `currentView`\n      var _shouldDestroyView = isDifferentView && !preventDestroy;\n  \n      // Only show the view given in the first argument if it is different than\n      // the current view or if we want to re-show the view. Note that if\n      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.\n      var _shouldShowView = isDifferentView || forceShow;\n  \n      if (isChangingView) {\n        this.triggerMethod('before:swapOut', this.currentView, this, options);\n      }\n  \n      if (this.currentView) {\n        delete this.currentView._parent;\n      }\n  \n      if (_shouldDestroyView) {\n        this.empty();\n  \n      // A `destroy` event is attached to the clean up manually removed views.\n      // We need to detach this event when a new view is going to be shown as it\n      // is no longer relevant.\n      } else if (isChangingView && _shouldShowView) {\n        this.currentView.off('destroy', this.empty, this);\n      }\n  \n      if (_shouldShowView) {\n  \n        // We need to listen for if a view is destroyed\n        // in a way other than through the region.\n        // If this happens we need to remove the reference\n        // to the currentView since once a view has been destroyed\n        // we can not reuse it.\n        view.once('destroy', this.empty, this);\n        view.render();\n  \n        view._parent = this;\n  \n        if (isChangingView) {\n          this.triggerMethod('before:swap', view, this, options);\n        }\n  \n        this.triggerMethod('before:show', view, this, options);\n        Marionette.triggerMethodOn(view, 'before:show', view, this, options);\n  \n        if (isChangingView) {\n          this.triggerMethod('swapOut', this.currentView, this, options);\n        }\n  \n        // An array of views that we're about to display\n        var attachedRegion = Marionette.isNodeAttached(this.el);\n  \n        // The views that we're about to attach to the document\n        // It's important that we prevent _getNestedViews from being executed unnecessarily\n        // as it's a potentially-slow method\n        var displayedViews = [];\n  \n        var triggerBeforeAttach = showOptions.triggerBeforeAttach || this.triggerBeforeAttach;\n        var triggerAttach = showOptions.triggerAttach || this.triggerAttach;\n  \n        if (attachedRegion && triggerBeforeAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews, 'before:');\n        }\n  \n        this.attachHtml(view);\n        this.currentView = view;\n  \n        if (attachedRegion && triggerAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews);\n        }\n  \n        if (isChangingView) {\n          this.triggerMethod('swap', view, this, options);\n        }\n  \n        this.triggerMethod('show', view, this, options);\n        Marionette.triggerMethodOn(view, 'show', view, this, options);\n  \n        return this;\n      }\n  \n      return this;\n    },\n  \n    triggerBeforeAttach: true,\n    triggerAttach: true,\n  \n    _triggerAttach: function(views, prefix) {\n      var eventName = (prefix || '') + 'attach';\n      _.each(views, function(view) {\n        Marionette.triggerMethodOn(view, eventName, view, this);\n      }, this);\n    },\n  \n    _displayedViews: function(view) {\n      return _.union([view], _.result(view, '_getNestedViews') || []);\n    },\n  \n    _ensureElement: function(){\n      if (!_.isObject(this.el)) {\n        this.$el = this.getEl(this.el);\n        this.el = this.$el[0];\n      }\n  \n      if (!this.$el || this.$el.length === 0) {\n        if (this.getOption('allowMissingEl')) {\n          return false;\n        } else {\n          throw new Marionette.Error('An \"el\" ' + this.$el.selector + ' must exist in DOM');\n        }\n      }\n      return true;\n    },\n  \n    _ensureViewIsIntact: function(view) {\n      if (!view) {\n        throw new Marionette.Error({\n          name: 'ViewNotValid',\n          message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'\n        });\n      }\n  \n      if (view.isDestroyed) {\n        throw new Marionette.Error({\n          name: 'ViewDestroyedError',\n          message: 'View (cid: \"' + view.cid + '\") has already been destroyed and cannot be used.'\n        });\n      }\n    },\n  \n    // Override this method to change how the region finds the\n    // DOM element that it manages. Return a jQuery selector object.\n    getEl: function(el) {\n      return Backbone.$(el);\n    },\n  \n    // Override this method to change how the new view is\n    // appended to the `$el` that the region is managing\n    attachHtml: function(view) {\n      // empty the node and append new view\n      // We can not use `.innerHTML` due to the fact that IE\n      // will not let us clear the html of tables and selects.\n      // We also do not want to use the more declarative `empty` method\n      // that jquery exposes since `.empty` loops over all of the children DOM\n      // nodes and unsets the listeners on each node. While this seems like\n      // a desirable thing, it comes at quite a high perf cost. For that reason\n      // we are simply clearing the html contents of the node.\n      this.$el.html('');\n      this.el.appendChild(view.el);\n    },\n  \n    // Destroy the current view, if there is one. If there is no\n    // current view, it does nothing and returns immediately.\n    empty: function() {\n      var view = this.currentView;\n  \n      // If there is no view in the region\n      // we should not remove anything\n      if (!view) { return; }\n  \n      view.off('destroy', this.empty, this);\n      this.triggerMethod('before:empty', view);\n      this._destroyView();\n      this.triggerMethod('empty', view);\n  \n      // Remove region pointer to the currentView\n      delete this.currentView;\n      return this;\n    },\n  \n    // call 'destroy' or 'remove', depending on which is found\n    // on the view (if showing a raw Backbone view or a Marionette View)\n    _destroyView: function() {\n      var view = this.currentView;\n  \n      if (view.destroy && !view.isDestroyed) {\n        view.destroy();\n      } else if (view.remove) {\n        view.remove();\n  \n        // appending isDestroyed to raw Backbone View allows regions\n        // to throw a ViewDestroyedError for this view\n        view.isDestroyed = true;\n      }\n    },\n  \n    // Attach an existing view to the region. This\n    // will not call `render` or `onShow` for the new view,\n    // and will not replace the current HTML for the `el`\n    // of the region.\n    attachView: function(view) {\n      this.currentView = view;\n      return this;\n    },\n  \n    // Checks whether a view is currently present within\n    // the region. Returns `true` if there is and `false` if\n    // no view is present.\n    hasView: function() {\n      return !!this.currentView;\n    },\n  \n    // Reset the region by destroying any existing view and\n    // clearing out the cached `$el`. The next time a view\n    // is shown via this region, the region will re-query the\n    // DOM for the region's `el`.\n    reset: function() {\n      this.empty();\n  \n      if (this.$el) {\n        this.el = this.$el.selector;\n      }\n  \n      delete this.$el;\n      return this;\n    }\n  \n  },\n  \n  // Static Methods\n  {\n  \n    // Build an instance of a region by passing in a configuration object\n    // and a default region class to use if none is specified in the config.\n    //\n    // The config object should either be a string as a jQuery DOM selector,\n    // a Region class directly, or an object literal that specifies a selector,\n    // a custom regionClass, and any options to be supplied to the region:\n    //\n    // ```js\n    // {\n    //   selector: \"#foo\",\n    //   regionClass: MyCustomRegion,\n    //   allowMissingEl: false\n    // }\n    // ```\n    //\n    buildRegion: function(regionConfig, DefaultRegionClass) {\n      if (_.isString(regionConfig)) {\n        return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);\n      }\n  \n      if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {\n        return this._buildRegionFromObject(regionConfig, DefaultRegionClass);\n      }\n  \n      if (_.isFunction(regionConfig)) {\n        return this._buildRegionFromRegionClass(regionConfig);\n      }\n  \n      throw new Marionette.Error({\n        message: 'Improper region configuration type.',\n        url: 'marionette.region.html#region-configuration-types'\n      });\n    },\n  \n    // Build the region from a string selector like '#foo-region'\n    _buildRegionFromSelector: function(selector, DefaultRegionClass) {\n      return new DefaultRegionClass({ el: selector });\n    },\n  \n    // Build the region from a configuration object\n    // ```js\n    // { selector: '#foo', regionClass: FooRegion, allowMissingEl: false }\n    // ```\n    _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {\n      var RegionClass = regionConfig.regionClass || DefaultRegionClass;\n      var options = _.omit(regionConfig, 'selector', 'regionClass');\n  \n      if (regionConfig.selector && !options.el) {\n        options.el = regionConfig.selector;\n      }\n  \n      var region = new RegionClass(options);\n  \n      // override the `getEl` function if we have a parentEl\n      // this must be overridden to ensure the selector is found\n      // on the first use of the region. if we try to assign the\n      // region's `el` to `parentEl.find(selector)` in the object\n      // literal to build the region, the element will not be\n      // guaranteed to be in the DOM already, and will cause problems\n      if (regionConfig.parentEl) {\n        region.getEl = function(el) {\n          if (_.isObject(el)) {\n            return Backbone.$(el);\n          }\n          var parentEl = regionConfig.parentEl;\n          if (_.isFunction(parentEl)) {\n            parentEl = parentEl();\n          }\n          return parentEl.find(el);\n        };\n      }\n  \n      return region;\n    },\n  \n    // Build the region directly from a given `RegionClass`\n    _buildRegionFromRegionClass: function(RegionClass) {\n      return new RegionClass();\n    }\n  });\n  \n  // Region Manager\n  // --------------\n  \n  // Manage one or more related `Marionette.Region` objects.\n  Marionette.RegionManager = Marionette.Controller.extend({\n    constructor: function(options) {\n      this._regions = {};\n  \n      Marionette.Controller.call(this, options);\n  \n      this.addRegions(this.getOption('regions'));\n    },\n  \n    // Add multiple regions using an object literal or a\n    // function that returns an object literal, where\n    // each key becomes the region name, and each value is\n    // the region definition.\n    addRegions: function(regionDefinitions, defaults) {\n      if (_.isFunction(regionDefinitions)) {\n        regionDefinitions = regionDefinitions.apply(this, arguments);\n      }\n  \n      var regions = {};\n  \n      _.each(regionDefinitions, function(definition, name) {\n        if (_.isString(definition)) {\n          definition = {selector: definition};\n        }\n  \n        if (definition.selector) {\n          definition = _.defaults({}, definition, defaults);\n        }\n  \n        var region = this.addRegion(name, definition);\n        regions[name] = region;\n      }, this);\n  \n      return regions;\n    },\n  \n    // Add an individual region to the region manager,\n    // and return the region instance\n    addRegion: function(name, definition) {\n      var region;\n  \n      if (definition instanceof Marionette.Region) {\n        region = definition;\n      } else {\n        region = Marionette.Region.buildRegion(definition, Marionette.Region);\n      }\n  \n      this.triggerMethod('before:add:region', name, region);\n  \n      region._parent = this;\n      this._store(name, region);\n  \n      this.triggerMethod('add:region', name, region);\n      return region;\n    },\n  \n    // Get a region by name\n    get: function(name) {\n      return this._regions[name];\n    },\n  \n    // Gets all the regions contained within\n    // the `regionManager` instance.\n    getRegions: function(){\n      return _.clone(this._regions);\n    },\n  \n    // Remove a region by name\n    removeRegion: function(name) {\n      var region = this._regions[name];\n      this._remove(name, region);\n  \n      return region;\n    },\n  \n    // Empty all regions in the region manager, and\n    // remove them\n    removeRegions: function() {\n      var regions = this.getRegions();\n      _.each(this._regions, function(region, name) {\n        this._remove(name, region);\n      }, this);\n  \n      return regions;\n    },\n  \n    // Empty all regions in the region manager, but\n    // leave them attached\n    emptyRegions: function() {\n      var regions = this.getRegions();\n      _.invoke(regions, 'empty');\n      return regions;\n    },\n  \n    // Destroy all regions and shut down the region\n    // manager entirely\n    destroy: function() {\n      this.removeRegions();\n      return Marionette.Controller.prototype.destroy.apply(this, arguments);\n    },\n  \n    // internal method to store regions\n    _store: function(name, region) {\n      this._regions[name] = region;\n      this._setLength();\n    },\n  \n    // internal method to remove a region\n    _remove: function(name, region) {\n      this.triggerMethod('before:remove:region', name, region);\n      region.empty();\n      region.stopListening();\n  \n      delete region._parent;\n      delete this._regions[name];\n      this._setLength();\n      this.triggerMethod('remove:region', name, region);\n    },\n  \n    // set the number of regions current held\n    _setLength: function() {\n      this.length = _.size(this._regions);\n    }\n  });\n  \n  Marionette.actAsCollection(Marionette.RegionManager.prototype, '_regions');\n  \n\n  // Template Cache\n  // --------------\n  \n  // Manage templates stored in `<script>` blocks,\n  // caching them for faster access.\n  Marionette.TemplateCache = function(templateId) {\n    this.templateId = templateId;\n  };\n  \n  // TemplateCache object-level methods. Manage the template\n  // caches from these method calls instead of creating\n  // your own TemplateCache instances\n  _.extend(Marionette.TemplateCache, {\n    templateCaches: {},\n  \n    // Get the specified template by id. Either\n    // retrieves the cached version, or loads it\n    // from the DOM.\n    get: function(templateId) {\n      var cachedTemplate = this.templateCaches[templateId];\n  \n      if (!cachedTemplate) {\n        cachedTemplate = new Marionette.TemplateCache(templateId);\n        this.templateCaches[templateId] = cachedTemplate;\n      }\n  \n      return cachedTemplate.load();\n    },\n  \n    // Clear templates from the cache. If no arguments\n    // are specified, clears all templates:\n    // `clear()`\n    //\n    // If arguments are specified, clears each of the\n    // specified templates from the cache:\n    // `clear(\"#t1\", \"#t2\", \"...\")`\n    clear: function() {\n      var i;\n      var args = _.toArray(arguments);\n      var length = args.length;\n  \n      if (length > 0) {\n        for (i = 0; i < length; i++) {\n          delete this.templateCaches[args[i]];\n        }\n      } else {\n        this.templateCaches = {};\n      }\n    }\n  });\n  \n  // TemplateCache instance methods, allowing each\n  // template cache object to manage its own state\n  // and know whether or not it has been loaded\n  _.extend(Marionette.TemplateCache.prototype, {\n  \n    // Internal method to load the template\n    load: function() {\n      // Guard clause to prevent loading this template more than once\n      if (this.compiledTemplate) {\n        return this.compiledTemplate;\n      }\n  \n      // Load the template and compile it\n      var template = this.loadTemplate(this.templateId);\n      this.compiledTemplate = this.compileTemplate(template);\n  \n      return this.compiledTemplate;\n    },\n  \n    // Load a template from the DOM, by default. Override\n    // this method to provide your own template retrieval\n    // For asynchronous loading with AMD/RequireJS, consider\n    // using a template-loader plugin as described here:\n    // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs\n    loadTemplate: function(templateId) {\n      var template = Backbone.$(templateId).html();\n  \n      if (!template || template.length === 0) {\n        throw new Marionette.Error({\n          name: 'NoTemplateError',\n          message: 'Could not find template: \"' + templateId + '\"'\n        });\n      }\n  \n      return template;\n    },\n  \n    // Pre-compile the template before caching it. Override\n    // this method if you do not need to pre-compile a template\n    // (JST / RequireJS for example) or if you want to change\n    // the template engine used (Handebars, etc).\n    compileTemplate: function(rawTemplate) {\n      return _.template(rawTemplate);\n    }\n  });\n  \n  // Renderer\n  // --------\n  \n  // Render a template with data by passing in the template\n  // selector and the data to render.\n  Marionette.Renderer = {\n  \n    // Render a template with data. The `template` parameter is\n    // passed to the `TemplateCache` object to retrieve the\n    // template function. Override this method to provide your own\n    // custom rendering and template handling for all of Marionette.\n    render: function(template, data) {\n      if (!template) {\n        throw new Marionette.Error({\n          name: 'TemplateNotFoundError',\n          message: 'Cannot render the template since its false, null or undefined.'\n        });\n      }\n  \n      var templateFunc;\n      if (typeof template === 'function') {\n        templateFunc = template;\n      } else {\n        templateFunc = Marionette.TemplateCache.get(template);\n      }\n  \n      return templateFunc(data);\n    }\n  };\n  \n\n  /* jshint maxlen: 114, nonew: false */\n  // View\n  // ----\n  \n  // The core view class that other Marionette views extend from.\n  Marionette.View = Backbone.View.extend({\n  \n    constructor: function(options) {\n      _.bindAll(this, 'render');\n  \n      options = _.isFunction(options) ? options.call(this) : options;\n  \n      // this exposes view options to the view initializer\n      // this is a backfill since backbone removed the assignment\n      // of this.options\n      // at some point however this may be removed\n      this.options = _.extend({}, _.result(this, 'options'), options);\n  \n      this._behaviors = Marionette.Behaviors(this);\n  \n      Backbone.View.apply(this, arguments);\n  \n      Marionette.MonitorDOMRefresh(this);\n      this.on('show', this.onShowCalled);\n    },\n  \n    // Get the template for this view\n    // instance. You can set a `template` attribute in the view\n    // definition or pass a `template: \"whatever\"` parameter in\n    // to the constructor options.\n    getTemplate: function() {\n      return this.getOption('template');\n    },\n  \n    // Serialize a model by returning its attributes. Clones\n    // the attributes to allow modification.\n    serializeModel: function(model){\n      return model.toJSON.apply(model, _.rest(arguments));\n    },\n  \n    // Mix in template helper methods. Looks for a\n    // `templateHelpers` attribute, which can either be an\n    // object literal, or a function that returns an object\n    // literal. All methods and attributes from this object\n    // are copies to the object passed in.\n    mixinTemplateHelpers: function(target) {\n      target = target || {};\n      var templateHelpers = this.getOption('templateHelpers');\n      if (_.isFunction(templateHelpers)) {\n        templateHelpers = templateHelpers.call(this);\n      }\n      return _.extend(target, templateHelpers);\n    },\n  \n    // normalize the keys of passed hash with the views `ui` selectors.\n    // `{\"@ui.foo\": \"bar\"}`\n    normalizeUIKeys: function(hash) {\n      var uiBindings = _.result(this, '_uiBindings');\n      return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, 'ui'));\n    },\n  \n    // normalize the values of passed hash with the views `ui` selectors.\n    // `{foo: \"@ui.bar\"}`\n    normalizeUIValues: function(hash) {\n      var ui = _.result(this, 'ui');\n      var uiBindings = _.result(this, '_uiBindings');\n      return Marionette.normalizeUIValues(hash, uiBindings || ui);\n    },\n  \n    // Configure `triggers` to forward DOM events to view\n    // events. `triggers: {\"click .foo\": \"do:foo\"}`\n    configureTriggers: function() {\n      if (!this.triggers) { return; }\n  \n      // Allow `triggers` to be configured as a function\n      var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));\n  \n      // Configure the triggers, prevent default\n      // action and stop propagation of DOM events\n      return _.reduce(triggers, function(events, value, key) {\n        events[key] = this._buildViewTrigger(value);\n        return events;\n      }, {}, this);\n    },\n  \n    // Overriding Backbone.View's delegateEvents to handle\n    // the `triggers`, `modelEvents`, and `collectionEvents` configuration\n    delegateEvents: function(events) {\n      this._delegateDOMEvents(events);\n      this.bindEntityEvents(this.model, this.getOption('modelEvents'));\n      this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));\n  \n      _.each(this._behaviors, function(behavior) {\n        behavior.bindEntityEvents(this.model, behavior.getOption('modelEvents'));\n        behavior.bindEntityEvents(this.collection, behavior.getOption('collectionEvents'));\n      }, this);\n  \n      return this;\n    },\n  \n    // internal method to delegate DOM events and triggers\n    _delegateDOMEvents: function(eventsArg) {\n      var events = eventsArg || this.events;\n      if (_.isFunction(events)) { events = events.call(this); }\n  \n      // normalize ui keys\n      events = this.normalizeUIKeys(events);\n      if(_.isUndefined(eventsArg)) {this.events = events;}\n  \n      var combinedEvents = {};\n  \n      // look up if this view has behavior events\n      var behaviorEvents = _.result(this, 'behaviorEvents') || {};\n      var triggers = this.configureTriggers();\n      var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};\n  \n      // behavior events will be overriden by view events and or triggers\n      _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);\n  \n      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);\n    },\n  \n    // Overriding Backbone.View's undelegateEvents to handle unbinding\n    // the `triggers`, `modelEvents`, and `collectionEvents` config\n    undelegateEvents: function() {\n      Backbone.View.prototype.undelegateEvents.apply(this, arguments);\n  \n      this.unbindEntityEvents(this.model, this.getOption('modelEvents'));\n      this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));\n  \n      _.each(this._behaviors, function(behavior) {\n        behavior.unbindEntityEvents(this.model, behavior.getOption('modelEvents'));\n        behavior.unbindEntityEvents(this.collection, behavior.getOption('collectionEvents'));\n      }, this);\n  \n      return this;\n    },\n  \n    // Internal method, handles the `show` event.\n    onShowCalled: function() {},\n  \n    // Internal helper method to verify whether the view hasn't been destroyed\n    _ensureViewIsIntact: function() {\n      if (this.isDestroyed) {\n        throw new Marionette.Error({\n          name: 'ViewDestroyedError',\n          message: 'View (cid: \"' + this.cid + '\") has already been destroyed and cannot be used.'\n        });\n      }\n    },\n  \n    // Default `destroy` implementation, for removing a view from the\n    // DOM and unbinding it. Regions will call this method\n    // for you. You can specify an `onDestroy` method in your view to\n    // add custom code that is called after the view is destroyed.\n    destroy: function() {\n      if (this.isDestroyed) { return; }\n  \n      var args = _.toArray(arguments);\n  \n      this.triggerMethod.apply(this, ['before:destroy'].concat(args));\n  \n      // mark as destroyed before doing the actual destroy, to\n      // prevent infinite loops within \"destroy\" event handlers\n      // that are trying to destroy other views\n      this.isDestroyed = true;\n      this.triggerMethod.apply(this, ['destroy'].concat(args));\n  \n      // unbind UI elements\n      this.unbindUIElements();\n  \n      // remove the view from the DOM\n      this.remove();\n  \n      // Call destroy on each behavior after\n      // destroying the view.\n      // This unbinds event listeners\n      // that behaviors have registered for.\n      _.invoke(this._behaviors, 'destroy', args);\n  \n      return this;\n    },\n  \n    bindUIElements: function() {\n      this._bindUIElements();\n      _.invoke(this._behaviors, this._bindUIElements);\n    },\n  \n    // This method binds the elements specified in the \"ui\" hash inside the view's code with\n    // the associated jQuery selectors.\n    _bindUIElements: function() {\n      if (!this.ui) { return; }\n  \n      // store the ui hash in _uiBindings so they can be reset later\n      // and so re-rendering the view will be able to find the bindings\n      if (!this._uiBindings) {\n        this._uiBindings = this.ui;\n      }\n  \n      // get the bindings result, as a function or otherwise\n      var bindings = _.result(this, '_uiBindings');\n  \n      // empty the ui so we don't have anything to start with\n      this.ui = {};\n  \n      // bind each of the selectors\n      _.each(_.keys(bindings), function(key) {\n        var selector = bindings[key];\n        this.ui[key] = this.$(selector);\n      }, this);\n    },\n  \n    // This method unbinds the elements specified in the \"ui\" hash\n    unbindUIElements: function() {\n      this._unbindUIElements();\n      _.invoke(this._behaviors, this._unbindUIElements);\n    },\n  \n    _unbindUIElements: function() {\n      if (!this.ui || !this._uiBindings) { return; }\n  \n      // delete all of the existing ui bindings\n      _.each(this.ui, function($el, name) {\n        delete this.ui[name];\n      }, this);\n  \n      // reset the ui element to the original bindings configuration\n      this.ui = this._uiBindings;\n      delete this._uiBindings;\n    },\n  \n    // Internal method to create an event handler for a given `triggerDef` like\n    // 'click:foo'\n    _buildViewTrigger: function(triggerDef) {\n      var hasOptions = _.isObject(triggerDef);\n  \n      var options = _.defaults({}, (hasOptions ? triggerDef : {}), {\n        preventDefault: true,\n        stopPropagation: true\n      });\n  \n      var eventName = hasOptions ? options.event : triggerDef;\n  \n      return function(e) {\n        if (e) {\n          if (e.preventDefault && options.preventDefault) {\n            e.preventDefault();\n          }\n  \n          if (e.stopPropagation && options.stopPropagation) {\n            e.stopPropagation();\n          }\n        }\n  \n        var args = {\n          view: this,\n          model: this.model,\n          collection: this.collection\n        };\n  \n        this.triggerMethod(eventName, args);\n      };\n    },\n  \n    setElement: function() {\n      var ret = Backbone.View.prototype.setElement.apply(this, arguments);\n  \n      // proxy behavior $el to the view's $el.\n      // This is needed because a view's $el proxy\n      // is not set until after setElement is called.\n      _.invoke(this._behaviors, 'proxyViewProperties', this);\n  \n      return ret;\n    },\n  \n    // import the `triggerMethod` to trigger events with corresponding\n    // methods if the method exists\n    triggerMethod: function() {\n      var triggerMethod = Marionette._triggerMethod;\n      var ret = triggerMethod(this, arguments);\n      var behaviors = this._behaviors;\n      // Use good ol' for as this is a very hot function\n      for (var i = 0, length = behaviors && behaviors.length; i < length; i++) {\n        triggerMethod(behaviors[i], arguments);\n      }\n  \n      return ret;\n    },\n  \n    // This method returns any views that are immediate\n    // children of this view\n    _getImmediateChildren: function() {\n      return [];\n    },\n  \n    // Returns an array of every nested view within this view\n    _getNestedViews: function() {\n      var children = this._getImmediateChildren();\n  \n      if (!children.length) { return children; }\n  \n      return _.reduce(children, function(memo, view) {\n        if (!view._getNestedViews) { return memo; }\n        return memo.concat(view._getNestedViews());\n      }, children);\n    },\n  \n    // Imports the \"normalizeMethods\" to transform hashes of\n    // events=>function references/names to a hash of events=>function references\n    normalizeMethods: Marionette.normalizeMethods,\n  \n    // Proxy `getOption` to enable getting options from this or this.options by name.\n    getOption: Marionette.proxyGetOption,\n  \n    // Proxy `bindEntityEvents` to enable binding view's events from another entity.\n    bindEntityEvents: Marionette.proxyBindEntityEvents,\n  \n    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.\n    unbindEntityEvents: Marionette.proxyUnbindEntityEvents\n  });\n  \n  // Item View\n  // ---------\n  \n  // A single item view implementation that contains code for rendering\n  // with underscore.js templates, serializing the view's model or collection,\n  // and calling several methods on extended views, such as `onRender`.\n  Marionette.ItemView = Marionette.View.extend({\n  \n    // Setting up the inheritance chain which allows changes to\n    // Marionette.View.prototype.constructor which allows overriding\n    constructor: function() {\n      Marionette.View.apply(this, arguments);\n    },\n  \n    // Serialize the model or collection for the view. If a model is\n    // found, the view's `serializeModel` is called. If a collection is found,\n    // each model in the collection is serialized by calling\n    // the view's `serializeCollection` and put into an `items` array in\n    // the resulting data. If both are found, defaults to the model.\n    // You can override the `serializeData` method in your own view definition,\n    // to provide custom serialization for your view's data.\n    serializeData: function(){\n      if (!this.model && !this.collection) {\n        return {};\n      }\n  \n      var args = [this.model || this.collection];\n      if (arguments.length) {\n        args.push.apply(args, arguments);\n      }\n  \n      if (this.model) {\n        return this.serializeModel.apply(this, args);\n      } else {\n        return {\n          items: this.serializeCollection.apply(this, args)\n        };\n      }\n    },\n  \n    // Serialize a collection by serializing each of its models.\n    serializeCollection: function(collection){\n      return collection.toJSON.apply(collection, _.rest(arguments));\n    },\n  \n    // Render the view, defaulting to underscore.js templates.\n    // You can override this in your view definition to provide\n    // a very specific rendering for your view. In general, though,\n    // you should override the `Marionette.Renderer` object to\n    // change how Marionette renders views.\n    render: function() {\n      this._ensureViewIsIntact();\n  \n      this.triggerMethod('before:render', this);\n  \n      this._renderTemplate();\n      this.bindUIElements();\n  \n      this.triggerMethod('render', this);\n  \n      return this;\n    },\n  \n    // Internal method to render the template with the serialized data\n    // and template helpers via the `Marionette.Renderer` object.\n    // Throws an `UndefinedTemplateError` error if the template is\n    // any falsely value but literal `false`.\n    _renderTemplate: function() {\n      var template = this.getTemplate();\n  \n      // Allow template-less item views\n      if (template === false) {\n        return;\n      }\n  \n      if (!template) {\n        throw new Marionette.Error({\n          name: 'UndefinedTemplateError',\n          message: 'Cannot render the template since it is null or undefined.'\n        });\n      }\n  \n      // Add in entity data and template helpers\n      var data = this.serializeData();\n      data = this.mixinTemplateHelpers(data);\n  \n      // Render and add to el\n      var html = Marionette.Renderer.render(template, data, this);\n      this.attachElContent(html);\n  \n      return this;\n    },\n  \n    // Attaches the content of a given view.\n    // This method can be overridden to optimize rendering,\n    // or to render in a non standard way.\n    //\n    // For example, using `innerHTML` instead of `$el.html`\n    //\n    // ```js\n    // attachElContent: function(html) {\n    //   this.el.innerHTML = html;\n    //   return this;\n    // }\n    // ```\n    attachElContent: function(html) {\n      this.$el.html(html);\n  \n      return this;\n    }\n  });\n  \n  /* jshint maxstatements: 14 */\n  \n  // Collection View\n  // ---------------\n  \n  // A view that iterates over a Backbone.Collection\n  // and renders an individual child view for each model.\n  Marionette.CollectionView = Marionette.View.extend({\n  \n    // used as the prefix for child view events\n    // that are forwarded through the collectionview\n    childViewEventPrefix: 'childview',\n  \n    // constructor\n    // option to pass `{sort: false}` to prevent the `CollectionView` from\n    // maintaining the sorted order of the collection.\n    // This will fallback onto appending childView's to the end.\n    constructor: function(options){\n      var initOptions = options || {};\n      if (_.isUndefined(this.sort)){\n        this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;\n      }\n  \n      this.once('render', this._initialEvents);\n      this._initChildViewStorage();\n  \n      Marionette.View.apply(this, arguments);\n  \n      this.initRenderBuffer();\n    },\n  \n    // Instead of inserting elements one by one into the page,\n    // it's much more performant to insert elements into a document\n    // fragment and then insert that document fragment into the page\n    initRenderBuffer: function() {\n      this.elBuffer = document.createDocumentFragment();\n      this._bufferedChildren = [];\n    },\n  \n    startBuffering: function() {\n      this.initRenderBuffer();\n      this.isBuffering = true;\n    },\n  \n    endBuffering: function() {\n      this.isBuffering = false;\n      this._triggerBeforeShowBufferedChildren();\n      this.attachBuffer(this, this.elBuffer);\n      this._triggerShowBufferedChildren();\n      this.initRenderBuffer();\n    },\n  \n    _triggerBeforeShowBufferedChildren: function() {\n      if (this._isShown) {\n        _.each(this._bufferedChildren, _.partial(this._triggerMethodOnChild, 'before:show'));\n      }\n    },\n  \n    _triggerShowBufferedChildren: function() {\n      if (this._isShown) {\n        _.each(this._bufferedChildren, _.partial(this._triggerMethodOnChild, 'show'));\n  \n        this._bufferedChildren = [];\n      }\n    },\n  \n    // Internal method for _.each loops to call `Marionette.triggerMethodOn` on\n    // a child view\n    _triggerMethodOnChild: function(event, childView) {\n      Marionette.triggerMethodOn(childView, event);\n    },\n  \n    // Configured the initial events that the collection view\n    // binds to.\n    _initialEvents: function() {\n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this.render);\n  \n        if (this.sort) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    },\n  \n    // Handle a child added to the collection\n    _onCollectionAdd: function(child) {\n      this.destroyEmptyView();\n      var ChildView = this.getChildView(child);\n      var index = this.collection.indexOf(child);\n      this.addChild(child, ChildView, index);\n    },\n  \n    // get the child view by model it holds, and remove it\n    _onCollectionRemove: function(model) {\n      var view = this.children.findByModel(model);\n      this.removeChildView(view);\n      this.checkEmpty();\n    },\n  \n    // Override from `Marionette.View` to trigger show on child views\n    onShowCalled: function() {\n      this.children.each(_.partial(this._triggerMethodOnChild, 'show'));\n    },\n  \n    // Render children views. Override this method to\n    // provide your own implementation of a render function for\n    // the collection view.\n    render: function() {\n      this._ensureViewIsIntact();\n      this.triggerMethod('before:render', this);\n      this._renderChildren();\n      this.triggerMethod('render', this);\n      return this;\n    },\n  \n    // Render view after sorting. Override this method to\n    // change how the view renders after a `sort` on the collection.\n    // An example of this would be to only `renderChildren` in a `CompositeView`\n    // rather than the full view.\n    resortView: function() {\n      this.render();\n    },\n  \n    // Internal method. This checks for any changes in the order of the collection.\n    // If the index of any view doesn't match, it will render.\n    _sortViews: function() {\n      // check for any changes in sort order of views\n      var orderChanged = this.collection.find(function(item, index){\n        var view = this.children.findByModel(item);\n        return !view || view._index !== index;\n      }, this);\n  \n      if (orderChanged) {\n        this.resortView();\n      }\n    },\n  \n    // Internal reference to what index a `emptyView` is.\n    _emptyViewIndex: -1,\n  \n    // Internal method. Separated so that CompositeView can have\n    // more control over events being triggered, around the rendering\n    // process\n    _renderChildren: function() {\n      this.destroyEmptyView();\n      this.destroyChildren();\n  \n      if (this.isEmpty(this.collection)) {\n        this.showEmptyView();\n      } else {\n        this.triggerMethod('before:render:collection', this);\n        this.startBuffering();\n        this.showCollection();\n        this.endBuffering();\n        this.triggerMethod('render:collection', this);\n      }\n    },\n  \n    // Internal method to loop through collection and show each child view.\n    showCollection: function() {\n      var ChildView;\n      this.collection.each(function(child, index) {\n        ChildView = this.getChildView(child);\n        this.addChild(child, ChildView, index);\n      }, this);\n    },\n  \n    // Internal method to show an empty view in place of\n    // a collection of child views, when the collection is empty\n    showEmptyView: function() {\n      var EmptyView = this.getEmptyView();\n  \n      if (EmptyView && !this._showingEmptyView) {\n        this.triggerMethod('before:render:empty');\n  \n        this._showingEmptyView = true;\n        var model = new Backbone.Model();\n        this.addEmptyView(model, EmptyView);\n  \n        this.triggerMethod('render:empty');\n      }\n    },\n  \n    // Internal method to destroy an existing emptyView instance\n    // if one exists. Called when a collection view has been\n    // rendered empty, and then a child is added to the collection.\n    destroyEmptyView: function() {\n      if (this._showingEmptyView) {\n        this.triggerMethod('before:remove:empty');\n  \n        this.destroyChildren();\n        delete this._showingEmptyView;\n  \n        this.triggerMethod('remove:empty');\n      }\n    },\n  \n    // Retrieve the empty view class\n    getEmptyView: function() {\n      return this.getOption('emptyView');\n    },\n  \n    // Render and show the emptyView. Similar to addChild method\n    // but \"child:added\" events are not fired, and the event from\n    // emptyView are not forwarded\n    addEmptyView: function(child, EmptyView) {\n  \n      // get the emptyViewOptions, falling back to childViewOptions\n      var emptyViewOptions = this.getOption('emptyViewOptions') ||\n                            this.getOption('childViewOptions');\n  \n      if (_.isFunction(emptyViewOptions)){\n        emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex);\n      }\n  \n      // build the empty view\n      var view = this.buildChildView(child, EmptyView, emptyViewOptions);\n  \n      view._parent = this;\n  \n      // Proxy emptyView events\n      this.proxyChildEvents(view);\n  \n      // trigger the 'before:show' event on `view` if the collection view\n      // has already been shown\n      if (this._isShown) {\n        Marionette.triggerMethodOn(view, 'before:show');\n      }\n  \n      // Store the `emptyView` like a `childView` so we can properly\n      // remove and/or close it later\n      this.children.add(view);\n  \n      // Render it and show it\n      this.renderChildView(view, this._emptyViewIndex);\n  \n      // call the 'show' method if the collection view\n      // has already been shown\n      if (this._isShown) {\n        Marionette.triggerMethodOn(view, 'show');\n      }\n    },\n  \n    // Retrieve the `childView` class, either from `this.options.childView`\n    // or from the `childView` in the object definition. The \"options\"\n    // takes precedence.\n    // This method receives the model that will be passed to the instance\n    // created from this `childView`. Overriding methods may use the child\n    // to determine what `childView` class to return.\n    getChildView: function(child) {\n      var childView = this.getOption('childView');\n  \n      if (!childView) {\n        throw new Marionette.Error({\n          name: 'NoChildViewError',\n          message: 'A \"childView\" must be specified'\n        });\n      }\n  \n      return childView;\n    },\n  \n    // Render the child's view and add it to the\n    // HTML for the collection view at a given index.\n    // This will also update the indices of later views in the collection\n    // in order to keep the children in sync with the collection.\n    addChild: function(child, ChildView, index) {\n      var childViewOptions = this.getOption('childViewOptions');\n      if (_.isFunction(childViewOptions)) {\n        childViewOptions = childViewOptions.call(this, child, index);\n      }\n  \n      var view = this.buildChildView(child, ChildView, childViewOptions);\n  \n      // increment indices of views after this one\n      this._updateIndices(view, true, index);\n  \n      this._addChildView(view, index);\n  \n      view._parent = this;\n  \n      return view;\n    },\n  \n    // Internal method. This decrements or increments the indices of views after the\n    // added/removed view to keep in sync with the collection.\n    _updateIndices: function(view, increment, index) {\n      if (!this.sort) {\n        return;\n      }\n  \n      if (increment) {\n        // assign the index to the view\n        view._index = index;\n  \n        // increment the index of views after this one\n        this.children.each(function (laterView) {\n          if (laterView._index >= view._index) {\n            laterView._index++;\n          }\n        });\n      }\n      else {\n        // decrement the index of views after this one\n        this.children.each(function (laterView) {\n          if (laterView._index >= view._index) {\n            laterView._index--;\n          }\n        });\n      }\n    },\n  \n  \n    // Internal Method. Add the view to children and render it at\n    // the given index.\n    _addChildView: function(view, index) {\n      // set up the child view event forwarding\n      this.proxyChildEvents(view);\n  \n      this.triggerMethod('before:add:child', view);\n  \n      // Store the child view itself so we can properly\n      // remove and/or destroy it later\n      this.children.add(view);\n      this.renderChildView(view, index);\n  \n      if (this._isShown && !this.isBuffering) {\n        Marionette.triggerMethodOn(view, 'show');\n      }\n  \n      this.triggerMethod('add:child', view);\n    },\n  \n    // render the child view\n    renderChildView: function(view, index) {\n      view.render();\n      this.attachHtml(this, view, index);\n      return view;\n    },\n  \n    // Build a `childView` for a model in the collection.\n    buildChildView: function(child, ChildViewClass, childViewOptions) {\n      var options = _.extend({model: child}, childViewOptions);\n      return new ChildViewClass(options);\n    },\n  \n    // Remove the child view and destroy it.\n    // This function also updates the indices of\n    // later views in the collection in order to keep\n    // the children in sync with the collection.\n    removeChildView: function(view) {\n  \n      if (view) {\n        this.triggerMethod('before:remove:child', view);\n        // call 'destroy' or 'remove', depending on which is found\n        if (view.destroy) { view.destroy(); }\n        else if (view.remove) { view.remove(); }\n  \n        delete view._parent;\n        this.stopListening(view);\n        this.children.remove(view);\n        this.triggerMethod('remove:child', view);\n  \n        // decrement the index of views after this one\n        this._updateIndices(view, false);\n      }\n  \n      return view;\n    },\n  \n    // check if the collection is empty\n    isEmpty: function() {\n      return !this.collection || this.collection.length === 0;\n    },\n  \n    // If empty, show the empty view\n    checkEmpty: function() {\n      if (this.isEmpty(this.collection)) {\n        this.showEmptyView();\n      }\n    },\n  \n    // You might need to override this if you've overridden attachHtml\n    attachBuffer: function(collectionView, buffer) {\n      collectionView.$el.append(buffer);\n    },\n  \n    // Append the HTML to the collection's `el`.\n    // Override this method to do something other\n    // than `.append`.\n    attachHtml: function(collectionView, childView, index) {\n      if (collectionView.isBuffering) {\n        // buffering happens on reset events and initial renders\n        // in order to reduce the number of inserts into the\n        // document, which are expensive.\n        collectionView.elBuffer.appendChild(childView.el);\n        collectionView._bufferedChildren.push(childView);\n      }\n      else {\n        // If we've already rendered the main collection, append\n        // the new child into the correct order if we need to. Otherwise\n        // append to the end.\n        if (!collectionView._insertBefore(childView, index)){\n          collectionView._insertAfter(childView);\n        }\n      }\n    },\n  \n    // Internal method. Check whether we need to insert the view into\n    // the correct position.\n    _insertBefore: function(childView, index) {\n      var currentView;\n      var findPosition = this.sort && (index < this.children.length - 1);\n      if (findPosition) {\n        // Find the view after this one\n        currentView = this.children.find(function (view) {\n          return view._index === index + 1;\n        });\n      }\n  \n      if (currentView) {\n        currentView.$el.before(childView.el);\n        return true;\n      }\n  \n      return false;\n    },\n  \n    // Internal method. Append a view to the end of the $el\n    _insertAfter: function(childView) {\n      this.$el.append(childView.el);\n    },\n  \n    // Internal method to set up the `children` object for\n    // storing all of the child views\n    _initChildViewStorage: function() {\n      this.children = new Backbone.ChildViewContainer();\n    },\n  \n    // Handle cleanup and other destroying needs for the collection of views\n    destroy: function() {\n      if (this.isDestroyed) { return; }\n  \n      this.triggerMethod('before:destroy:collection');\n      this.destroyChildren();\n      this.triggerMethod('destroy:collection');\n  \n      return Marionette.View.prototype.destroy.apply(this, arguments);\n    },\n  \n    // Destroy the child views that this collection view\n    // is holding on to, if any\n    destroyChildren: function() {\n      var childViews = this.children.map(_.identity);\n      this.children.each(this.removeChildView, this);\n      this.checkEmpty();\n      return childViews;\n    },\n  \n    // Set up the child view event forwarding. Uses a \"childview:\"\n    // prefix in front of all forwarded events.\n    proxyChildEvents: function(view) {\n      var prefix = this.getOption('childViewEventPrefix');\n  \n      // Forward all child view events through the parent,\n      // prepending \"childview:\" to the event name\n      this.listenTo(view, 'all', function() {\n        var args = _.toArray(arguments);\n        var rootEvent = args[0];\n        var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));\n  \n        args[0] = prefix + ':' + rootEvent;\n        args.splice(1, 0, view);\n  \n        // call collectionView childEvent if defined\n        if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {\n          childEvents[rootEvent].apply(this, args.slice(1));\n        }\n  \n        this.triggerMethod.apply(this, args);\n      }, this);\n    },\n  \n    _getImmediateChildren: function() {\n      return _.values(this.children._views);\n    }\n  });\n  \n  /* jshint maxstatements: 17, maxlen: 117 */\n  \n  // Composite View\n  // --------------\n  \n  // Used for rendering a branch-leaf, hierarchical structure.\n  // Extends directly from CollectionView and also renders an\n  // a child view as `modelView`, for the top leaf\n  Marionette.CompositeView = Marionette.CollectionView.extend({\n  \n    // Setting up the inheritance chain which allows changes to\n    // Marionette.CollectionView.prototype.constructor which allows overriding\n    // option to pass '{sort: false}' to prevent the CompositeView from\n    // maintaining the sorted order of the collection.\n    // This will fallback onto appending childView's to the end.\n    constructor: function() {\n      Marionette.CollectionView.apply(this, arguments);\n    },\n  \n    // Configured the initial events that the composite view\n    // binds to. Override this method to prevent the initial\n    // events, or to add your own initial events.\n    _initialEvents: function() {\n  \n      // Bind only after composite view is rendered to avoid adding child views\n      // to nonexistent childViewContainer\n  \n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this._renderChildren);\n  \n        if (this.sort) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    },\n  \n    // Retrieve the `childView` to be used when rendering each of\n    // the items in the collection. The default is to return\n    // `this.childView` or Marionette.CompositeView if no `childView`\n    // has been defined\n    getChildView: function(child) {\n      var childView = this.getOption('childView') || this.constructor;\n  \n      return childView;\n    },\n  \n    // Serialize the model for the view.\n    // You can override the `serializeData` method in your own view\n    // definition, to provide custom serialization for your view's data.\n    serializeData: function() {\n      var data = {};\n  \n      if (this.model){\n        data = _.partial(this.serializeModel, this.model).apply(this, arguments);\n      }\n  \n      return data;\n    },\n  \n    // Renders the model and the collection.\n    render: function() {\n      this._ensureViewIsIntact();\n      this.isRendered = true;\n      this.resetChildViewContainer();\n  \n      this.triggerMethod('before:render', this);\n  \n      this._renderTemplate();\n      this._renderChildren();\n  \n      this.triggerMethod('render', this);\n      return this;\n    },\n  \n    _renderChildren: function() {\n      if (this.isRendered) {\n        Marionette.CollectionView.prototype._renderChildren.call(this);\n      }\n    },\n  \n    // Render the root template that the children\n    // views are appended to\n    _renderTemplate: function() {\n      var data = {};\n      data = this.serializeData();\n      data = this.mixinTemplateHelpers(data);\n  \n      this.triggerMethod('before:render:template');\n  \n      var template = this.getTemplate();\n      var html = Marionette.Renderer.render(template, data, this);\n      this.attachElContent(html);\n  \n      // the ui bindings is done here and not at the end of render since they\n      // will not be available until after the model is rendered, but should be\n      // available before the collection is rendered.\n      this.bindUIElements();\n      this.triggerMethod('render:template');\n    },\n  \n    // Attaches the content of the root.\n    // This method can be overridden to optimize rendering,\n    // or to render in a non standard way.\n    //\n    // For example, using `innerHTML` instead of `$el.html`\n    //\n    // ```js\n    // attachElContent: function(html) {\n    //   this.el.innerHTML = html;\n    //   return this;\n    // }\n    // ```\n    attachElContent: function(html) {\n      this.$el.html(html);\n  \n      return this;\n    },\n  \n    // You might need to override this if you've overridden attachHtml\n    attachBuffer: function(compositeView, buffer) {\n      var $container = this.getChildViewContainer(compositeView);\n      $container.append(buffer);\n    },\n  \n    // Internal method. Append a view to the end of the $el.\n    // Overidden from CollectionView to ensure view is appended to\n    // childViewContainer\n    _insertAfter: function (childView) {\n      var $container = this.getChildViewContainer(this, childView);\n      $container.append(childView.el);\n    },\n  \n    // Internal method to ensure an `$childViewContainer` exists, for the\n    // `attachHtml` method to use.\n    getChildViewContainer: function(containerView, childView) {\n      if ('$childViewContainer' in containerView) {\n        return containerView.$childViewContainer;\n      }\n  \n      var container;\n      var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');\n      if (childViewContainer) {\n  \n        var selector = _.isFunction(childViewContainer) ? childViewContainer.call(containerView) : childViewContainer;\n  \n        if (selector.charAt(0) === '@' && containerView.ui) {\n          container = containerView.ui[selector.substr(4)];\n        } else {\n          container = containerView.$(selector);\n        }\n  \n        if (container.length <= 0) {\n          throw new Marionette.Error({\n            name: 'ChildViewContainerMissingError',\n            message: 'The specified \"childViewContainer\" was not found: ' + containerView.childViewContainer\n          });\n        }\n  \n      } else {\n        container = containerView.$el;\n      }\n  \n      containerView.$childViewContainer = container;\n      return container;\n    },\n  \n    // Internal method to reset the `$childViewContainer` on render\n    resetChildViewContainer: function() {\n      if (this.$childViewContainer) {\n        delete this.$childViewContainer;\n      }\n    }\n  });\n  \n  // Layout View\n  // -----------\n  \n  // Used for managing application layoutViews, nested layoutViews and\n  // multiple regions within an application or sub-application.\n  //\n  // A specialized view class that renders an area of HTML and then\n  // attaches `Region` instances to the specified `regions`.\n  // Used for composite view management and sub-application areas.\n  Marionette.LayoutView = Marionette.ItemView.extend({\n    regionClass: Marionette.Region,\n  \n    // Ensure the regions are available when the `initialize` method\n    // is called.\n    constructor: function(options) {\n      options = options || {};\n  \n      this._firstRender = true;\n      this._initializeRegions(options);\n  \n      Marionette.ItemView.call(this, options);\n    },\n  \n    // LayoutView's render will use the existing region objects the\n    // first time it is called. Subsequent calls will destroy the\n    // views that the regions are showing and then reset the `el`\n    // for the regions to the newly rendered DOM elements.\n    render: function() {\n      this._ensureViewIsIntact();\n  \n      if (this._firstRender) {\n        // if this is the first render, don't do anything to\n        // reset the regions\n        this._firstRender = false;\n      } else {\n        // If this is not the first render call, then we need to\n        // re-initialize the `el` for each region\n        this._reInitializeRegions();\n      }\n  \n      return Marionette.ItemView.prototype.render.apply(this, arguments);\n    },\n  \n    // Handle destroying regions, and then destroy the view itself.\n    destroy: function() {\n      if (this.isDestroyed) { return this; }\n  \n      this.regionManager.destroy();\n      return Marionette.ItemView.prototype.destroy.apply(this, arguments);\n    },\n  \n    // Add a single region, by name, to the layoutView\n    addRegion: function(name, definition) {\n      var regions = {};\n      regions[name] = definition;\n      return this._buildRegions(regions)[name];\n    },\n  \n    // Add multiple regions as a {name: definition, name2: def2} object literal\n    addRegions: function(regions) {\n      this.regions = _.extend({}, this.regions, regions);\n      return this._buildRegions(regions);\n    },\n  \n    // Remove a single region from the LayoutView, by name\n    removeRegion: function(name) {\n      delete this.regions[name];\n      return this.regionManager.removeRegion(name);\n    },\n  \n    // Provides alternative access to regions\n    // Accepts the region name\n    // getRegion('main')\n    getRegion: function(region) {\n      return this.regionManager.get(region);\n    },\n  \n    // Get all regions\n    getRegions: function(){\n      return this.regionManager.getRegions();\n    },\n  \n    // internal method to build regions\n    _buildRegions: function(regions) {\n      var defaults = {\n        regionClass: this.getOption('regionClass'),\n        parentEl: _.partial(_.result, this, '$el')\n      };\n  \n      return this.regionManager.addRegions(regions, defaults);\n    },\n  \n    // Internal method to initialize the regions that have been defined in a\n    // `regions` attribute on this layoutView.\n    _initializeRegions: function(options) {\n      var regions;\n      this._initRegionManager();\n  \n      if (_.isFunction(this.regions)) {\n        regions = this.regions(options);\n      } else {\n        regions = this.regions || {};\n      }\n  \n      // Enable users to define `regions` as instance options.\n      var regionOptions = this.getOption.call(options, 'regions');\n  \n      // enable region options to be a function\n      if (_.isFunction(regionOptions)) {\n        regionOptions = regionOptions.call(this, options);\n      }\n  \n      _.extend(regions, regionOptions);\n  \n      // Normalize region selectors hash to allow\n      // a user to use the @ui. syntax.\n      regions = this.normalizeUIValues(regions);\n  \n      this.addRegions(regions);\n    },\n  \n    // Internal method to re-initialize all of the regions by updating the `el` that\n    // they point to\n    _reInitializeRegions: function() {\n      this.regionManager.invoke('reset');\n    },\n  \n    // Enable easy overriding of the default `RegionManager`\n    // for customized region interactions and business specific\n    // view logic for better control over single regions.\n    getRegionManager: function() {\n      return new Marionette.RegionManager();\n    },\n  \n    // Internal method to initialize the region manager\n    // and all regions in it\n    _initRegionManager: function() {\n      this.regionManager = this.getRegionManager();\n      this.regionManager._parent = this;\n  \n      this.listenTo(this.regionManager, 'before:add:region', function(name) {\n        this.triggerMethod('before:add:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'add:region', function(name, region) {\n        this[name] = region;\n        this.triggerMethod('add:region', name, region);\n      });\n  \n      this.listenTo(this.regionManager, 'before:remove:region', function(name) {\n        this.triggerMethod('before:remove:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'remove:region', function(name, region) {\n        delete this[name];\n        this.triggerMethod('remove:region', name, region);\n      });\n    },\n  \n    _getImmediateChildren: function() {\n      return _.chain(this.regionManager.getRegions())\n        .pluck('currentView')\n        .compact()\n        .value();\n    }\n  });\n  \n\n  // Behavior\n  // --------\n  \n  // A Behavior is an isolated set of DOM /\n  // user interactions that can be mixed into any View.\n  // Behaviors allow you to blackbox View specific interactions\n  // into portable logical chunks, keeping your views simple and your code DRY.\n  \n  Marionette.Behavior = Marionette.Object.extend({\n    constructor: function(options, view) {\n      // Setup reference to the view.\n      // this comes in handle when a behavior\n      // wants to directly talk up the chain\n      // to the view.\n      this.view = view;\n      this.defaults = _.result(this, 'defaults') || {};\n      this.options  = _.extend({}, this.defaults, options);\n  \n      Marionette.Object.apply(this, arguments);\n    },\n  \n    // proxy behavior $ method to the view\n    // this is useful for doing jquery DOM lookups\n    // scoped to behaviors view.\n    $: function() {\n      return this.view.$.apply(this.view, arguments);\n    },\n  \n    // Stops the behavior from listening to events.\n    // Overrides Object#destroy to prevent additional events from being triggered.\n    destroy: function() {\n      this.stopListening();\n    },\n  \n    proxyViewProperties: function (view) {\n      this.$el = view.$el;\n      this.el = view.el;\n    }\n  });\n  \n  /* jshint maxlen: 143 */\n  // Behaviors\n  // ---------\n  \n  // Behaviors is a utility class that takes care of\n  // gluing your behavior instances to their given View.\n  // The most important part of this class is that you\n  // **MUST** override the class level behaviorsLookup\n  // method for things to work properly.\n  \n  Marionette.Behaviors = (function(Marionette, _) {\n  \n    function Behaviors(view, behaviors) {\n  \n      if (!_.isObject(view.behaviors)) {\n        return {};\n      }\n  \n      // Behaviors defined on a view can be a flat object literal\n      // or it can be a function that returns an object.\n      behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));\n  \n      // Wraps several of the view's methods\n      // calling the methods first on each behavior\n      // and then eventually calling the method on the view.\n      Behaviors.wrap(view, behaviors, _.keys(methods));\n      return behaviors;\n    }\n  \n    var methods = {\n      behaviorTriggers: function(behaviorTriggers, behaviors) {\n        var triggerBuilder = new BehaviorTriggersBuilder(this, behaviors);\n        return triggerBuilder.buildBehaviorTriggers();\n      },\n  \n      behaviorEvents: function(behaviorEvents, behaviors) {\n        var _behaviorsEvents = {};\n        var viewUI = _.result(this, 'ui');\n  \n        _.each(behaviors, function(b, i) {\n          var _events = {};\n          var behaviorEvents = _.clone(_.result(b, 'events')) || {};\n          var behaviorUI = _.result(b, 'ui');\n  \n          // Construct an internal UI hash first using\n          // the views UI hash and then the behaviors UI hash.\n          // This allows the user to use UI hash elements\n          // defined in the parent view as well as those\n          // defined in the given behavior.\n          var ui = _.extend({}, viewUI, behaviorUI);\n  \n          // Normalize behavior events hash to allow\n          // a user to use the @ui. syntax.\n          behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);\n  \n          _.each(_.keys(behaviorEvents), function(key) {\n            // Append white-space at the end of each key to prevent behavior key collisions.\n            // This is relying on the fact that backbone events considers \"click .foo\" the same as\n            // \"click .foo \".\n  \n            // +2 is used because new Array(1) or 0 is \"\" and not \" \"\n            var whitespace = (new Array(i + 2)).join(' ');\n            var eventKey   = key + whitespace;\n            var handler    = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];\n  \n            _events[eventKey] = _.bind(handler, b);\n          });\n  \n          _behaviorsEvents = _.extend(_behaviorsEvents, _events);\n        });\n  \n        return _behaviorsEvents;\n      }\n    };\n  \n    _.extend(Behaviors, {\n  \n      // Placeholder method to be extended by the user.\n      // The method should define the object that stores the behaviors.\n      // i.e.\n      //\n      // ```js\n      // Marionette.Behaviors.behaviorsLookup: function() {\n      //   return App.Behaviors\n      // }\n      // ```\n      behaviorsLookup: function() {\n        throw new Marionette.Error({\n          message: 'You must define where your behaviors are stored.',\n          url: 'marionette.behaviors.html#behaviorslookup'\n        });\n      },\n  \n      // Takes care of getting the behavior class\n      // given options and a key.\n      // If a user passes in options.behaviorClass\n      // default to using that. Otherwise delegate\n      // the lookup to the users `behaviorsLookup` implementation.\n      getBehaviorClass: function(options, key) {\n        if (options.behaviorClass) {\n          return options.behaviorClass;\n        }\n  \n        // Get behavior class can be either a flat object or a method\n        return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];\n      },\n  \n      // Iterate over the behaviors object, for each behavior\n      // instantiate it and get its grouped behaviors.\n      parseBehaviors: function(view, behaviors) {\n        return _.chain(behaviors).map(function(options, key) {\n          var BehaviorClass = Behaviors.getBehaviorClass(options, key);\n  \n          var behavior = new BehaviorClass(options, view);\n          var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));\n  \n          return [behavior].concat(nestedBehaviors);\n        }).flatten().value();\n      },\n  \n      // Wrap view internal methods so that they delegate to behaviors. For example,\n      // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.\n      // i.e.\n      //\n      // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`\n      wrap: function(view, behaviors, methodNames) {\n        _.each(methodNames, function(methodName) {\n          view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);\n        });\n      }\n    });\n  \n    // Class to build handlers for `triggers` on behaviors\n    // for views\n    function BehaviorTriggersBuilder(view, behaviors) {\n      this._view      = view;\n      this._viewUI    = _.result(view, 'ui');\n      this._behaviors = behaviors;\n      this._triggers  = {};\n    }\n  \n    _.extend(BehaviorTriggersBuilder.prototype, {\n      // Main method to build the triggers hash with event keys and handlers\n      buildBehaviorTriggers: function() {\n        _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this);\n        return this._triggers;\n      },\n  \n      // Internal method to build all trigger handlers for a given behavior\n      _buildTriggerHandlersForBehavior: function(behavior, i) {\n        var ui = _.extend({}, this._viewUI, _.result(behavior, 'ui'));\n        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};\n  \n        triggersHash = Marionette.normalizeUIKeys(triggersHash, ui);\n  \n        _.each(triggersHash, _.partial(this._setHandlerForBehavior, behavior, i), this);\n      },\n  \n      // Internal method to create and assign the trigger handler for a given\n      // behavior\n      _setHandlerForBehavior: function(behavior, i, eventName, trigger) {\n        // Unique identifier for the `this._triggers` hash\n        var triggerKey = trigger.replace(/^\\S+/, function(triggerName) {\n          return triggerName + '.' + 'behaviortriggers' + i;\n        });\n  \n        this._triggers[triggerKey] = this._view._buildViewTrigger(eventName);\n      }\n    });\n  \n    return Behaviors;\n  \n  })(Marionette, _);\n  \n\n  // App Router\n  // ----------\n  \n  // Reduce the boilerplate code of handling route events\n  // and then calling a single method on another object.\n  // Have your routers configured to call the method on\n  // your object, directly.\n  //\n  // Configure an AppRouter with `appRoutes`.\n  //\n  // App routers can only take one `controller` object.\n  // It is recommended that you divide your controller\n  // objects in to smaller pieces of related functionality\n  // and have multiple routers / controllers, instead of\n  // just one giant router and controller.\n  //\n  // You can also add standard routes to an AppRouter.\n  \n  Marionette.AppRouter = Backbone.Router.extend({\n  \n    constructor: function(options) {\n      this.options = options || {};\n  \n      Backbone.Router.apply(this, arguments);\n  \n      var appRoutes = this.getOption('appRoutes');\n      var controller = this._getController();\n      this.processAppRoutes(controller, appRoutes);\n      this.on('route', this._processOnRoute, this);\n    },\n  \n    // Similar to route method on a Backbone Router but\n    // method is called on the controller\n    appRoute: function(route, methodName) {\n      var controller = this._getController();\n      this._addAppRoute(controller, route, methodName);\n    },\n  \n    // process the route event and trigger the onRoute\n    // method call, if it exists\n    _processOnRoute: function(routeName, routeArgs) {\n      // make sure an onRoute before trying to call it\n      if (_.isFunction(this.onRoute)) {\n        // find the path that matches the current route\n        var routePath = _.invert(this.getOption('appRoutes'))[routeName];\n        this.onRoute(routeName, routePath, routeArgs);\n      }\n    },\n  \n    // Internal method to process the `appRoutes` for the\n    // router, and turn them in to routes that trigger the\n    // specified method on the specified `controller`.\n    processAppRoutes: function(controller, appRoutes) {\n      if (!appRoutes) { return; }\n  \n      var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes\n  \n      _.each(routeNames, function(route) {\n        this._addAppRoute(controller, route, appRoutes[route]);\n      }, this);\n    },\n  \n    _getController: function() {\n      return this.getOption('controller');\n    },\n  \n    _addAppRoute: function(controller, route, methodName) {\n      var method = controller[methodName];\n  \n      if (!method) {\n        throw new Marionette.Error('Method \"' + methodName + '\" was not found on the controller');\n      }\n  \n      this.route(route, methodName, _.bind(method, controller));\n    },\n  \n    // Proxy `getOption` to enable getting options from this or this.options by name.\n    getOption: Marionette.proxyGetOption,\n  \n    triggerMethod: Marionette.triggerMethod,\n  \n    bindEntityEvents: Marionette.proxyBindEntityEvents,\n  \n    unbindEntityEvents: Marionette.proxyUnbindEntityEvents\n  });\n  \n  // Application\n  // -----------\n  \n  // Contain and manage the composite application as a whole.\n  // Stores and starts up `Region` objects, includes an\n  // event aggregator as `app.vent`\n  Marionette.Application = Marionette.Object.extend({\n    constructor: function(options) {\n      this._initializeRegions(options);\n      this._initCallbacks = new Marionette.Callbacks();\n      this.submodules = {};\n      _.extend(this, options);\n      this._initChannel();\n      Marionette.Object.call(this, options);\n    },\n  \n    // Command execution, facilitated by Backbone.Wreqr.Commands\n    execute: function() {\n      this.commands.execute.apply(this.commands, arguments);\n    },\n  \n    // Request/response, facilitated by Backbone.Wreqr.RequestResponse\n    request: function() {\n      return this.reqres.request.apply(this.reqres, arguments);\n    },\n  \n    // Add an initializer that is either run at when the `start`\n    // method is called, or run immediately if added after `start`\n    // has already been called.\n    addInitializer: function(initializer) {\n      this._initCallbacks.add(initializer);\n    },\n  \n    // kick off all of the application's processes.\n    // initializes all of the regions that have been added\n    // to the app, and runs all of the initializer functions\n    start: function(options) {\n      this.triggerMethod('before:start', options);\n      this._initCallbacks.run(options, this);\n      this.triggerMethod('start', options);\n    },\n  \n    // Add regions to your app.\n    // Accepts a hash of named strings or Region objects\n    // addRegions({something: \"#someRegion\"})\n    // addRegions({something: Region.extend({el: \"#someRegion\"}) });\n    addRegions: function(regions) {\n      return this._regionManager.addRegions(regions);\n    },\n  \n    // Empty all regions in the app, without removing them\n    emptyRegions: function() {\n      return this._regionManager.emptyRegions();\n    },\n  \n    // Removes a region from your app, by name\n    // Accepts the regions name\n    // removeRegion('myRegion')\n    removeRegion: function(region) {\n      return this._regionManager.removeRegion(region);\n    },\n  \n    // Provides alternative access to regions\n    // Accepts the region name\n    // getRegion('main')\n    getRegion: function(region) {\n      return this._regionManager.get(region);\n    },\n  \n    // Get all the regions from the region manager\n    getRegions: function(){\n      return this._regionManager.getRegions();\n    },\n  \n    // Create a module, attached to the application\n    module: function(moduleNames, moduleDefinition) {\n  \n      // Overwrite the module class if the user specifies one\n      var ModuleClass = Marionette.Module.getClass(moduleDefinition);\n  \n      var args = _.toArray(arguments);\n      args.unshift(this);\n  \n      // see the Marionette.Module object for more information\n      return ModuleClass.create.apply(ModuleClass, args);\n    },\n  \n    // Enable easy overriding of the default `RegionManager`\n    // for customized region interactions and business-specific\n    // view logic for better control over single regions.\n    getRegionManager: function() {\n      return new Marionette.RegionManager();\n    },\n  \n    // Internal method to initialize the regions that have been defined in a\n    // `regions` attribute on the application instance\n    _initializeRegions: function(options) {\n      var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};\n  \n      this._initRegionManager();\n  \n      // Enable users to define `regions` in instance options.\n      var optionRegions = Marionette.getOption(options, 'regions');\n  \n      // Enable region options to be a function\n      if (_.isFunction(optionRegions)) {\n        optionRegions = optionRegions.call(this, options);\n      }\n  \n      // Overwrite current regions with those passed in options\n      _.extend(regions, optionRegions);\n  \n      this.addRegions(regions);\n  \n      return this;\n    },\n  \n    // Internal method to set up the region manager\n    _initRegionManager: function() {\n      this._regionManager = this.getRegionManager();\n      this._regionManager._parent = this;\n  \n      this.listenTo(this._regionManager, 'before:add:region', function() {\n        Marionette._triggerMethod(this, 'before:add:region', arguments);\n      });\n  \n      this.listenTo(this._regionManager, 'add:region', function(name, region) {\n        this[name] = region;\n        Marionette._triggerMethod(this, 'add:region', arguments);\n      });\n  \n      this.listenTo(this._regionManager, 'before:remove:region', function() {\n        Marionette._triggerMethod(this, 'before:remove:region', arguments);\n      });\n  \n      this.listenTo(this._regionManager, 'remove:region', function(name) {\n        delete this[name];\n        Marionette._triggerMethod(this, 'remove:region', arguments);\n      });\n    },\n  \n    // Internal method to setup the Wreqr.radio channel\n    _initChannel: function() {\n      this.channelName = _.result(this, 'channelName') || 'global';\n      this.channel = _.result(this, 'channel') || Backbone.Wreqr.radio.channel(this.channelName);\n      this.vent = _.result(this, 'vent') || this.channel.vent;\n      this.commands = _.result(this, 'commands') || this.channel.commands;\n      this.reqres = _.result(this, 'reqres') || this.channel.reqres;\n    }\n  });\n  \n  /* jshint maxparams: 9 */\n  \n  // Module\n  // ------\n  \n  // A simple module system, used to create privacy and encapsulation in\n  // Marionette applications\n  Marionette.Module = function(moduleName, app, options) {\n    this.moduleName = moduleName;\n    this.options = _.extend({}, this.options, options);\n    // Allow for a user to overide the initialize\n    // for a given module instance.\n    this.initialize = options.initialize || this.initialize;\n  \n    // Set up an internal store for sub-modules.\n    this.submodules = {};\n  \n    this._setupInitializersAndFinalizers();\n  \n    // Set an internal reference to the app\n    // within a module.\n    this.app = app;\n  \n    if (_.isFunction(this.initialize)) {\n      this.initialize(moduleName, app, this.options);\n    }\n  };\n  \n  Marionette.Module.extend = Marionette.extend;\n  \n  // Extend the Module prototype with events / listenTo, so that the module\n  // can be used as an event aggregator or pub/sub.\n  _.extend(Marionette.Module.prototype, Backbone.Events, {\n  \n    // By default modules start with their parents.\n    startWithParent: true,\n  \n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic when extending Marionette.Module.\n    initialize: function() {},\n  \n    // Initializer for a specific module. Initializers are run when the\n    // module's `start` method is called.\n    addInitializer: function(callback) {\n      this._initializerCallbacks.add(callback);\n    },\n  \n    // Finalizers are run when a module is stopped. They are used to teardown\n    // and finalize any variables, references, events and other code that the\n    // module had set up.\n    addFinalizer: function(callback) {\n      this._finalizerCallbacks.add(callback);\n    },\n  \n    // Start the module, and run all of its initializers\n    start: function(options) {\n      // Prevent re-starting a module that is already started\n      if (this._isInitialized) { return; }\n  \n      // start the sub-modules (depth-first hierarchy)\n      _.each(this.submodules, function(mod) {\n        // check to see if we should start the sub-module with this parent\n        if (mod.startWithParent) {\n          mod.start(options);\n        }\n      });\n  \n      // run the callbacks to \"start\" the current module\n      this.triggerMethod('before:start', options);\n  \n      this._initializerCallbacks.run(options, this);\n      this._isInitialized = true;\n  \n      this.triggerMethod('start', options);\n    },\n  \n    // Stop this module by running its finalizers and then stop all of\n    // the sub-modules for this module\n    stop: function() {\n      // if we are not initialized, don't bother finalizing\n      if (!this._isInitialized) { return; }\n      this._isInitialized = false;\n  \n      this.triggerMethod('before:stop');\n  \n      // stop the sub-modules; depth-first, to make sure the\n      // sub-modules are stopped / finalized before parents\n      _.invoke(this.submodules, 'stop');\n  \n      // run the finalizers\n      this._finalizerCallbacks.run(undefined, this);\n  \n      // reset the initializers and finalizers\n      this._initializerCallbacks.reset();\n      this._finalizerCallbacks.reset();\n  \n      this.triggerMethod('stop');\n    },\n  \n    // Configure the module with a definition function and any custom args\n    // that are to be passed in to the definition function\n    addDefinition: function(moduleDefinition, customArgs) {\n      this._runModuleDefinition(moduleDefinition, customArgs);\n    },\n  \n    // Internal method: run the module definition function with the correct\n    // arguments\n    _runModuleDefinition: function(definition, customArgs) {\n      // If there is no definition short circut the method.\n      if (!definition) { return; }\n  \n      // build the correct list of arguments for the module definition\n      var args = _.flatten([\n        this,\n        this.app,\n        Backbone,\n        Marionette,\n        Backbone.$, _,\n        customArgs\n      ]);\n  \n      definition.apply(this, args);\n    },\n  \n    // Internal method: set up new copies of initializers and finalizers.\n    // Calling this method will wipe out all existing initializers and\n    // finalizers.\n    _setupInitializersAndFinalizers: function() {\n      this._initializerCallbacks = new Marionette.Callbacks();\n      this._finalizerCallbacks = new Marionette.Callbacks();\n    },\n  \n    // import the `triggerMethod` to trigger events with corresponding\n    // methods if the method exists\n    triggerMethod: Marionette.triggerMethod\n  });\n  \n  // Class methods to create modules\n  _.extend(Marionette.Module, {\n  \n    // Create a module, hanging off the app parameter as the parent object.\n    create: function(app, moduleNames, moduleDefinition) {\n      var module = app;\n  \n      // get the custom args passed in after the module definition and\n      // get rid of the module name and definition function\n      var customArgs = _.rest(arguments, 3);\n  \n      // Split the module names and get the number of submodules.\n      // i.e. an example module name of `Doge.Wow.Amaze` would\n      // then have the potential for 3 module definitions.\n      moduleNames = moduleNames.split('.');\n      var length = moduleNames.length;\n  \n      // store the module definition for the last module in the chain\n      var moduleDefinitions = [];\n      moduleDefinitions[length - 1] = moduleDefinition;\n  \n      // Loop through all the parts of the module definition\n      _.each(moduleNames, function(moduleName, i) {\n        var parentModule = module;\n        module = this._getModule(parentModule, moduleName, app, moduleDefinition);\n        this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);\n      }, this);\n  \n      // Return the last module in the definition chain\n      return module;\n    },\n  \n    _getModule: function(parentModule, moduleName, app, def, args) {\n      var options = _.extend({}, def);\n      var ModuleClass = this.getClass(def);\n  \n      // Get an existing module of this name if we have one\n      var module = parentModule[moduleName];\n  \n      if (!module) {\n        // Create a new module if we don't have one\n        module = new ModuleClass(moduleName, app, options);\n        parentModule[moduleName] = module;\n        // store the module on the parent\n        parentModule.submodules[moduleName] = module;\n      }\n  \n      return module;\n    },\n  \n    // ## Module Classes\n    //\n    // Module classes can be used as an alternative to the define pattern.\n    // The extend function of a Module is identical to the extend functions\n    // on other Backbone and Marionette classes.\n    // This allows module lifecyle events like `onStart` and `onStop` to be called directly.\n    getClass: function(moduleDefinition) {\n      var ModuleClass = Marionette.Module;\n  \n      if (!moduleDefinition) {\n        return ModuleClass;\n      }\n  \n      // If all of the module's functionality is defined inside its class,\n      // then the class can be passed in directly. `MyApp.module(\"Foo\", FooModule)`.\n      if (moduleDefinition.prototype instanceof ModuleClass) {\n        return moduleDefinition;\n      }\n  \n      return moduleDefinition.moduleClass || ModuleClass;\n    },\n  \n    // Add the module definition and add a startWithParent initializer function.\n    // This is complicated because module definitions are heavily overloaded\n    // and support an anonymous function, module class, or options object\n    _addModuleDefinition: function(parentModule, module, def, args) {\n      var fn = this._getDefine(def);\n      var startWithParent = this._getStartWithParent(def, module);\n  \n      if (fn) {\n        module.addDefinition(fn, args);\n      }\n  \n      this._addStartWithParent(parentModule, module, startWithParent);\n    },\n  \n    _getStartWithParent: function(def, module) {\n      var swp;\n  \n      if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {\n        swp = module.constructor.prototype.startWithParent;\n        return _.isUndefined(swp) ? true : swp;\n      }\n  \n      if (_.isObject(def)) {\n        swp = def.startWithParent;\n        return _.isUndefined(swp) ? true : swp;\n      }\n  \n      return true;\n    },\n  \n    _getDefine: function(def) {\n      if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {\n        return def;\n      }\n  \n      if (_.isObject(def)) {\n        return def.define;\n      }\n  \n      return null;\n    },\n  \n    _addStartWithParent: function(parentModule, module, startWithParent) {\n      module.startWithParent = module.startWithParent && startWithParent;\n  \n      if (!module.startWithParent || !!module.startWithParentIsConfigured) {\n        return;\n      }\n  \n      module.startWithParentIsConfigured = true;\n  \n      parentModule.addInitializer(function(options) {\n        if (module.startWithParent) {\n          module.start(options);\n        }\n      });\n    }\n  });\n  \n\n  return Marionette;\n}));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLm1hcmlvbmV0dGUvbGliL2NvcmUvYmFja2JvbmUubWFyaW9uZXR0ZS5qcz8wZDI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFROztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUNBQW1DOztBQUUvRDtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQSwyQkFBMkIsUUFBUTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0Qjs7QUFFN0Q7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGlCQUFpQjs7QUFFOUM7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQywrQkFBK0IsZUFBZTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDZCQUE2QixRQUFROztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTs7QUFFMUM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7O0FBRS9CLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLDBCQUEwQixrQkFBa0IsR0FBRztBQUNsRTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFROztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIE1hcmlvbmV0dGVKUyAoQmFja2JvbmUuTWFyaW9uZXR0ZSlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHYyLjMuMFxuLy9cbi8vIENvcHlyaWdodCAoYykyMDE0IERlcmljayBCYWlsZXksIE11dGVkIFNvbHV0aW9ucywgTExDLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2Vcbi8vXG4vLyBodHRwOi8vbWFyaW9uZXR0ZWpzLmNvbVxuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydiYWNrYm9uZScsICd1bmRlcnNjb3JlJywgJ2JhY2tib25lLndyZXFyJywgJ2JhY2tib25lLmJhYnlzaXR0ZXInXSwgZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgICAgIHJldHVybiAocm9vdC5NYXJpb25ldHRlID0gcm9vdC5NbiA9IGZhY3Rvcnkocm9vdCwgQmFja2JvbmUsIF8pKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuICAgIEJhY2tib25lLiQgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbiAgICAvL3ZhciBXcmVxciA9IHJlcXVpcmUoJ2JhY2tib25lLndyZXFyJyk7XG4gICAgdmFyIEJhYnlTaXR0ZXIgPSByZXF1aXJlKCdiYWNrYm9uZS5iYWJ5c2l0dGVyJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QsIEJhY2tib25lLCBfKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk1hcmlvbmV0dGUgPSByb290Lk1uID0gZmFjdG9yeShyb290LCByb290LkJhY2tib25lLCByb290Ll8pO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24ocm9vdCwgQmFja2JvbmUsIF8pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwcmV2aW91c01hcmlvbmV0dGUgPSByb290Lk1hcmlvbmV0dGU7XG4gIHZhciBwcmV2aW91c01uID0gcm9vdC5NbjtcblxuICB2YXIgTWFyaW9uZXR0ZSA9IEJhY2tib25lLk1hcmlvbmV0dGUgPSB7fTtcblxuICBNYXJpb25ldHRlLlZFUlNJT04gPSAnMi4zLjAnO1xuXG4gIE1hcmlvbmV0dGUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuTWFyaW9uZXR0ZSA9IHByZXZpb3VzTWFyaW9uZXR0ZTtcbiAgICByb290Lk1uID0gcHJldmlvdXNNbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBHZXQgdGhlIERlZmVycmVkIGNyZWF0b3IgZm9yIGxhdGVyIHVzZVxuICBNYXJpb25ldHRlLkRlZmVycmVkID0gQmFja2JvbmUuJC5EZWZlcnJlZDtcblxuICAvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqLy8qIGdsb2JhbCBjb25zb2xlICovXG4gIFxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cbiAgXG4gIC8vIE1hcmlvbmV0dGUuZXh0ZW5kXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBCb3Jyb3cgdGhlIEJhY2tib25lIGBleHRlbmRgIG1ldGhvZCBzbyB3ZSBjYW4gdXNlIGl0IGFzIG5lZWRlZFxuICBNYXJpb25ldHRlLmV4dGVuZCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZDtcbiAgXG4gIC8vIE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWRcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gRGV0ZXJtaW5lIGlmIGBlbGAgaXMgYSBjaGlsZCBvZiB0aGUgZG9jdW1lbnRcbiAgTWFyaW9uZXR0ZS5pc05vZGVBdHRhY2hlZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlbCk7XG4gIH07XG4gIFxuICBcbiAgLy8gTWFyaW9uZXR0ZS5nZXRPcHRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIFJldHJpZXZlIGFuIG9iamVjdCwgZnVuY3Rpb24gb3Igb3RoZXIgdmFsdWUgZnJvbSBhIHRhcmdldFxuICAvLyBvYmplY3Qgb3IgaXRzIGBvcHRpb25zYCwgd2l0aCBgb3B0aW9uc2AgdGFraW5nIHByZWNlZGVuY2UuXG4gIE1hcmlvbmV0dGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25OYW1lKSB7XG4gICAgaWYgKCF0YXJnZXQgfHwgIW9wdGlvbk5hbWUpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRhcmdldC5vcHRpb25zICYmICh0YXJnZXQub3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5vcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W29wdGlvbk5hbWVdO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFByb3h5IGBNYXJpb25ldHRlLmdldE9wdGlvbmBcbiAgTWFyaW9uZXR0ZS5wcm94eUdldE9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gTWFyaW9uZXR0ZS5nZXRPcHRpb24odGhpcywgb3B0aW9uTmFtZSk7XG4gIH07XG4gIFxuICAvLyBNYXJpb25ldHRlLm5vcm1hbGl6ZU1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gUGFzcyBpbiBhIG1hcHBpbmcgb2YgZXZlbnRzID0+IGZ1bmN0aW9ucyBvciBmdW5jdGlvbiBuYW1lc1xuICAvLyBhbmQgcmV0dXJuIGEgbWFwcGluZyBvZiBldmVudHMgPT4gZnVuY3Rpb25zXG4gIE1hcmlvbmV0dGUubm9ybWFsaXplTWV0aG9kcyA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoaGFzaCwgZnVuY3Rpb24obm9ybWFsaXplZEhhc2gsIG1ldGhvZCwgbmFtZSkge1xuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkge1xuICAgICAgICBtZXRob2QgPSB0aGlzW21ldGhvZF07XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRIYXNoW25hbWVdID0gbWV0aG9kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRIYXNoO1xuICAgIH0sIHt9LCB0aGlzKTtcbiAgfTtcbiAgXG4gIC8vIHV0aWxpdHkgbWV0aG9kIGZvciBwYXJzaW5nIEB1aS4gc3ludGF4IHN0cmluZ3NcbiAgLy8gaW50byBhc3NvY2lhdGVkIHNlbGVjdG9yXG4gIE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcgPSBmdW5jdGlvbih1aVN0cmluZywgdWkpIHtcbiAgICByZXR1cm4gdWlTdHJpbmcucmVwbGFjZSgvQHVpXFwuW2EtekEtWl8kMC05XSovZywgZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHVpW3Iuc2xpY2UoNCldO1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gYWxsb3dzIGZvciB0aGUgdXNlIG9mIHRoZSBAdWkuIHN5bnRheCB3aXRoaW5cbiAgLy8gYSBnaXZlbiBrZXkgZm9yIHRyaWdnZXJzIGFuZCBldmVudHNcbiAgLy8gc3dhcHMgdGhlIEB1aSB3aXRoIHRoZSBhc3NvY2lhdGVkIHNlbGVjdG9yLlxuICAvLyBSZXR1cm5zIGEgbmV3LCBub24tbXV0YXRlZCwgcGFyc2VkIGV2ZW50cyBoYXNoLlxuICBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJS2V5cyA9IGZ1bmN0aW9uKGhhc2gsIHVpKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGhhc2gsIGZ1bmN0aW9uKG1lbW8sIHZhbCwga2V5KSB7XG4gICAgICB2YXIgbm9ybWFsaXplZEtleSA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcoa2V5LCB1aSk7XG4gICAgICBtZW1vW25vcm1hbGl6ZWRLZXldID0gdmFsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuICB9O1xuICBcbiAgLy8gYWxsb3dzIGZvciB0aGUgdXNlIG9mIHRoZSBAdWkuIHN5bnRheCB3aXRoaW5cbiAgLy8gYSBnaXZlbiB2YWx1ZSBmb3IgcmVnaW9uc1xuICAvLyBzd2FwcyB0aGUgQHVpIHdpdGggdGhlIGFzc29jaWF0ZWQgc2VsZWN0b3JcbiAgTWFyaW9uZXR0ZS5ub3JtYWxpemVVSVZhbHVlcyA9IGZ1bmN0aW9uKGhhc2gsIHVpKSB7XG4gICAgXy5lYWNoKGhhc2gsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICBpZiAoXy5pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgIGhhc2hba2V5XSA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcodmFsLCB1aSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG4gIFxuICAvLyBNaXggaW4gbWV0aG9kcyBmcm9tIFVuZGVyc2NvcmUsIGZvciBpdGVyYXRpb24sIGFuZCBvdGhlclxuICAvLyBjb2xsZWN0aW9uIHJlbGF0ZWQgZmVhdHVyZXMuXG4gIC8vIEJvcnJvd2luZyB0aGlzIGNvZGUgZnJvbSBCYWNrYm9uZS5Db2xsZWN0aW9uOlxuICAvLyBodHRwOi8vYmFja2JvbmVqcy5vcmcvZG9jcy9iYWNrYm9uZS5odG1sI3NlY3Rpb24tMTIxXG4gIE1hcmlvbmV0dGUuYWN0QXNDb2xsZWN0aW9uID0gZnVuY3Rpb24ob2JqZWN0LCBsaXN0UHJvcGVydHkpIHtcbiAgICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLFxuICAgICAgJ3NlbGVjdCcsICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLFxuICAgICAgJ2NvbnRhaW5zJywgJ2ludm9rZScsICd0b0FycmF5JywgJ2ZpcnN0JywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgICAnbGFzdCcsICd3aXRob3V0JywgJ2lzRW1wdHknLCAncGx1Y2snXTtcbiAgXG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgb2JqZWN0W21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBfLnZhbHVlcyhfLnJlc3VsdCh0aGlzLCBsaXN0UHJvcGVydHkpKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbbGlzdF0uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIFxuICB2YXIgZGVwcmVjYXRlID0gTWFyaW9uZXR0ZS5kZXByZWNhdGUgPSBmdW5jdGlvbihtZXNzYWdlLCB0ZXN0KSB7XG4gICAgaWYgKF8uaXNPYmplY3QobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSAoXG4gICAgICAgIG1lc3NhZ2UucHJldiArICcgaXMgZ29pbmcgdG8gYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgJyArIG1lc3NhZ2UubmV4dCArICcgaW5zdGVhZC4nICtcbiAgICAgICAgKG1lc3NhZ2UudXJsID8gJyBTZWU6ICcgKyBtZXNzYWdlLnVybCA6ICcnKVxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIGlmICgodGVzdCA9PT0gdW5kZWZpbmVkIHx8ICF0ZXN0KSAmJiAhZGVwcmVjYXRlLl9jYWNoZVttZXNzYWdlXSkge1xuICAgICAgZGVwcmVjYXRlLl93YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbWVzc2FnZSk7XG4gICAgICBkZXByZWNhdGUuX2NhY2hlW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIFxuICBkZXByZWNhdGUuX3dhcm4gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykgfHwgZnVuY3Rpb24oKSB7fTtcbiAgZGVwcmVjYXRlLl9jYWNoZSA9IHt9O1xuICBcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDE0LCBtYXhjb21wbGV4aXR5OiA3ICovXG4gIFxuICAvLyBUcmlnZ2VyIE1ldGhvZFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBcbiAgXG4gIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gc3BsaXQgdGhlIGV2ZW50IG5hbWUgb24gdGhlIFwiOlwiXG4gICAgdmFyIHNwbGl0dGVyID0gLyhefDopKFxcdykvZ2k7XG4gIFxuICAgIC8vIHRha2UgdGhlIGV2ZW50IHNlY3Rpb24gKFwic2VjdGlvbjE6c2VjdGlvbjI6c2VjdGlvbjNcIilcbiAgICAvLyBhbmQgdHVybiBpdCBpbiB0byB1cHBlcmNhc2UgbmFtZVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50TmFtZShtYXRjaCwgcHJlZml4LCBldmVudE5hbWUpIHtcbiAgICAgIHJldHVybiBldmVudE5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0LCBldmVudCwgYXJncykge1xuICAgICAgdmFyIG5vRXZlbnRBcmcgPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGlmIChub0V2ZW50QXJnKSB7XG4gICAgICAgIGFyZ3MgPSBldmVudDtcbiAgICAgICAgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGdldCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAgICAgdmFyIG1ldGhvZE5hbWUgPSAnb24nICsgZXZlbnQucmVwbGFjZShzcGxpdHRlciwgZ2V0RXZlbnROYW1lKTtcbiAgICAgIHZhciBtZXRob2QgPSBjb250ZXh0W21ldGhvZE5hbWVdO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgXG4gICAgICAvLyBjYWxsIHRoZSBvbk1ldGhvZE5hbWUgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgLy8gcGFzcyBhbGwgYXJncywgZXhjZXB0IHRoZSBldmVudCBuYW1lXG4gICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBub0V2ZW50QXJnID8gXy5yZXN0KGFyZ3MpIDogYXJncyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQsIGlmIGEgdHJpZ2dlciBtZXRob2QgZXhpc3RzXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbnRleHQudHJpZ2dlcikpIHtcbiAgICAgICAgaWYgKG5vRXZlbnRBcmcgKyBhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250ZXh0LnRyaWdnZXIuYXBwbHkoY29udGV4dCwgbm9FdmVudEFyZyA/IGFyZ3MgOiBbZXZlbnRdLmNvbmNhdChfLnJlc3QoYXJncywgMCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnRyaWdnZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KSgpO1xuICBcbiAgLy8gVHJpZ2dlciBhbiBldmVudCBhbmQvb3IgYSBjb3JyZXNwb25kaW5nIG1ldGhvZCBuYW1lLiBFeGFtcGxlczpcbiAgLy9cbiAgLy8gYHRoaXMudHJpZ2dlck1ldGhvZChcImZvb1wiKWAgd2lsbCB0cmlnZ2VyIHRoZSBcImZvb1wiIGV2ZW50IGFuZFxuICAvLyBjYWxsIHRoZSBcIm9uRm9vXCIgbWV0aG9kLlxuICAvL1xuICAvLyBgdGhpcy50cmlnZ2VyTWV0aG9kKFwiZm9vOmJhclwiKWAgd2lsbCB0cmlnZ2VyIHRoZSBcImZvbzpiYXJcIiBldmVudCBhbmRcbiAgLy8gY2FsbCB0aGUgXCJvbkZvb0JhclwiIG1ldGhvZC5cbiAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBcbiAgLy8gdHJpZ2dlck1ldGhvZE9uIGludm9rZXMgdHJpZ2dlck1ldGhvZCBvbiBhIHNwZWNpZmljIGNvbnRleHRcbiAgLy9cbiAgLy8gZS5nLiBgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ3Nob3cnKWBcbiAgLy8gd2lsbCB0cmlnZ2VyIGEgXCJzaG93XCIgZXZlbnQgb3IgaW52b2tlIG9uU2hvdyB0aGUgdmlldy5cbiAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24gPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGZuYyA9IF8uaXNGdW5jdGlvbihjb250ZXh0LnRyaWdnZXJNZXRob2QpID9cbiAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJpZ2dlck1ldGhvZCA6XG4gICAgICAgICAgICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2Q7XG4gIFxuICAgIHJldHVybiBmbmMuYXBwbHkoY29udGV4dCwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICB9O1xuICBcbiAgLy8gRE9NIFJlZnJlc2hcbiAgLy8gLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1vbml0b3IgYSB2aWV3J3Mgc3RhdGUsIGFuZCBhZnRlciBpdCBoYXMgYmVlbiByZW5kZXJlZCBhbmQgc2hvd25cbiAgLy8gaW4gdGhlIERPTSwgdHJpZ2dlciBhIFwiZG9tOnJlZnJlc2hcIiBldmVudCBldmVyeSB0aW1lIGl0IGlzXG4gIC8vIHJlLXJlbmRlcmVkLlxuICBcbiAgTWFyaW9uZXR0ZS5Nb25pdG9yRE9NUmVmcmVzaCA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgXG4gICAgLy8gdHJhY2sgd2hlbiB0aGUgdmlldyBoYXMgYmVlbiBzaG93biBpbiB0aGUgRE9NLFxuICAgIC8vIHVzaW5nIGEgTWFyaW9uZXR0ZS5SZWdpb24gKG9yIGJ5IG90aGVyIG1lYW5zIG9mIHRyaWdnZXJpbmcgXCJzaG93XCIpXG4gICAgZnVuY3Rpb24gaGFuZGxlU2hvdygpIHtcbiAgICAgIHZpZXcuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgdHJpZ2dlckRPTVJlZnJlc2goKTtcbiAgICB9XG4gIFxuICAgIC8vIHRyYWNrIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW4gcmVuZGVyZWRcbiAgICBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoKSB7XG4gICAgICB2aWV3Ll9pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRyaWdnZXJET01SZWZyZXNoKCk7XG4gICAgfVxuICBcbiAgICAvLyBUcmlnZ2VyIHRoZSBcImRvbTpyZWZyZXNoXCIgZXZlbnQgYW5kIGNvcnJlc3BvbmRpbmcgXCJvbkRvbVJlZnJlc2hcIiBtZXRob2RcbiAgICBmdW5jdGlvbiB0cmlnZ2VyRE9NUmVmcmVzaCgpIHtcbiAgICAgIGlmICh2aWV3Ll9pc1Nob3duICYmIHZpZXcuX2lzUmVuZGVyZWQgJiYgTWFyaW9uZXR0ZS5pc05vZGVBdHRhY2hlZCh2aWV3LmVsKSkge1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpZXcudHJpZ2dlck1ldGhvZCkpIHtcbiAgICAgICAgICB2aWV3LnRyaWdnZXJNZXRob2QoJ2RvbTpyZWZyZXNoJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIHZpZXcub24oe1xuICAgICAgc2hvdzogaGFuZGxlU2hvdyxcbiAgICAgIHJlbmRlcjogaGFuZGxlUmVuZGVyXG4gICAgfSk7XG4gIH07XG4gIFxuICAvKiBqc2hpbnQgbWF4cGFyYW1zOiA1ICovXG4gIFxuICAvLyBCaW5kIEVudGl0eSBFdmVudHMgJiBVbmJpbmQgRW50aXR5IEV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBUaGVzZSBtZXRob2RzIGFyZSB1c2VkIHRvIGJpbmQvdW5iaW5kIGEgYmFja2JvbmUgXCJlbnRpdHlcIiAoY29sbGVjdGlvbi9tb2RlbClcbiAgLy8gdG8gbWV0aG9kcyBvbiBhIHRhcmdldCBvYmplY3QuXG4gIC8vXG4gIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIsIGB0YXJnZXRgLCBtdXN0IGhhdmUgYSBgbGlzdGVuVG9gIG1ldGhvZCBmcm9tIHRoZVxuICAvLyBFdmVudEJpbmRlciBvYmplY3QuXG4gIC8vXG4gIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBlbnRpdHkgKEJhY2tib25lLk1vZGVsIG9yIEJhY2tib25lLkNvbGxlY3Rpb24pXG4gIC8vIHRvIGJpbmQgdGhlIGV2ZW50cyBmcm9tLlxuICAvL1xuICAvLyBUaGUgdGhpcmQgcGFyYW1ldGVyIGlzIGEgaGFzaCBvZiB7IFwiZXZlbnQ6bmFtZVwiOiBcImV2ZW50SGFuZGxlclwiIH1cbiAgLy8gY29uZmlndXJhdGlvbi4gTXVsdGlwbGUgaGFuZGxlcnMgY2FuIGJlIHNlcGFyYXRlZCBieSBhIHNwYWNlLiBBXG4gIC8vIGZ1bmN0aW9uIGNhbiBiZSBzdXBwbGllZCBpbnN0ZWFkIG9mIGEgc3RyaW5nIGhhbmRsZXIgbmFtZS5cbiAgXG4gIChmdW5jdGlvbihNYXJpb25ldHRlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgICAvLyBCaW5kIHRoZSBldmVudCB0byBoYW5kbGVycyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgb2ZcbiAgICAvLyBoYW5kbGVyIG5hbWVzIG9uIHRoZSB0YXJnZXQgb2JqZWN0XG4gICAgZnVuY3Rpb24gYmluZEZyb21TdHJpbmdzKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpIHtcbiAgICAgIHZhciBtZXRob2ROYW1lcyA9IG1ldGhvZHMuc3BsaXQoL1xccysvKTtcbiAgXG4gICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgXG4gICAgICAgIHZhciBtZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3IoJ01ldGhvZCBcIicgKyBtZXRob2ROYW1lICtcbiAgICAgICAgICAgICdcIiB3YXMgY29uZmlndXJlZCBhcyBhbiBldmVudCBoYW5kbGVyLCBidXQgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRhcmdldC5saXN0ZW5UbyhlbnRpdHksIGV2dCwgbWV0aG9kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgdG8gYSBzdXBwbGllZCBjYWxsYmFjayBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGJpbmRUb0Z1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZCkge1xuICAgICAgdGFyZ2V0Lmxpc3RlblRvKGVudGl0eSwgZXZ0LCBtZXRob2QpO1xuICAgIH1cbiAgXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgdG8gaGFuZGxlcnMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIG9mXG4gICAgLy8gaGFuZGxlciBuYW1lcyBvbiB0aGUgdGFyZ2V0IG9iamVjdFxuICAgIGZ1bmN0aW9uIHVuYmluZEZyb21TdHJpbmdzKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpIHtcbiAgICAgIHZhciBtZXRob2ROYW1lcyA9IG1ldGhvZHMuc3BsaXQoL1xccysvKTtcbiAgXG4gICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgICAgICAgdGFyZ2V0LnN0b3BMaXN0ZW5pbmcoZW50aXR5LCBldnQsIG1ldGhvZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIC8vIEJpbmQgdGhlIGV2ZW50IHRvIGEgc3VwcGxpZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBmdW5jdGlvbiB1bmJpbmRUb0Z1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZCkge1xuICAgICAgdGFyZ2V0LnN0b3BMaXN0ZW5pbmcoZW50aXR5LCBldnQsIG1ldGhvZCk7XG4gICAgfVxuICBcbiAgXG4gICAgLy8gZ2VuZXJpYyBsb29waW5nIGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUV2ZW50cyh0YXJnZXQsIGVudGl0eSwgYmluZGluZ3MsIGZ1bmN0aW9uQ2FsbGJhY2ssIHN0cmluZ0NhbGxiYWNrKSB7XG4gICAgICBpZiAoIWVudGl0eSB8fCAhYmluZGluZ3MpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gdHlwZS1jaGVjayBiaW5kaW5nc1xuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oYmluZGluZ3MpICYmICFfLmlzT2JqZWN0KGJpbmRpbmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ0JpbmRpbmdzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLicsXG4gICAgICAgICAgdXJsOiAnbWFyaW9uZXR0ZS5mdW5jdGlvbnMuaHRtbCNtYXJpb25ldHRlYmluZGVudGl0eWV2ZW50cydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gYWxsb3cgdGhlIGJpbmRpbmdzIHRvIGJlIGEgZnVuY3Rpb25cbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oYmluZGluZ3MpKSB7XG4gICAgICAgIGJpbmRpbmdzID0gYmluZGluZ3MuY2FsbCh0YXJnZXQpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGl0ZXJhdGUgdGhlIGJpbmRpbmdzIGFuZCBiaW5kIHRoZW1cbiAgICAgIF8uZWFjaChiaW5kaW5ncywgZnVuY3Rpb24obWV0aG9kcywgZXZ0KSB7XG4gIFxuICAgICAgICAvLyBhbGxvdyBmb3IgYSBmdW5jdGlvbiBhcyB0aGUgaGFuZGxlcixcbiAgICAgICAgLy8gb3IgYSBsaXN0IG9mIGV2ZW50IG5hbWVzIGFzIGEgc3RyaW5nXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24obWV0aG9kcykpIHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGxiYWNrKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZ0NhbGxiYWNrKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpO1xuICAgICAgICB9XG4gIFxuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICAvLyBFeHBvcnQgUHVibGljIEFQSVxuICAgIE1hcmlvbmV0dGUuYmluZEVudGl0eUV2ZW50cyA9IGZ1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgaXRlcmF0ZUV2ZW50cyh0YXJnZXQsIGVudGl0eSwgYmluZGluZ3MsIGJpbmRUb0Z1bmN0aW9uLCBiaW5kRnJvbVN0cmluZ3MpO1xuICAgIH07XG4gIFxuICAgIE1hcmlvbmV0dGUudW5iaW5kRW50aXR5RXZlbnRzID0gZnVuY3Rpb24odGFyZ2V0LCBlbnRpdHksIGJpbmRpbmdzKSB7XG4gICAgICBpdGVyYXRlRXZlbnRzKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncywgdW5iaW5kVG9GdW5jdGlvbiwgdW5iaW5kRnJvbVN0cmluZ3MpO1xuICAgIH07XG4gIFxuICAgIC8vIFByb3h5IGBiaW5kRW50aXR5RXZlbnRzYFxuICAgIE1hcmlvbmV0dGUucHJveHlCaW5kRW50aXR5RXZlbnRzID0gZnVuY3Rpb24oZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuYmluZEVudGl0eUV2ZW50cyh0aGlzLCBlbnRpdHksIGJpbmRpbmdzKTtcbiAgICB9O1xuICBcbiAgICAvLyBQcm94eSBgdW5iaW5kRW50aXR5RXZlbnRzYFxuICAgIE1hcmlvbmV0dGUucHJveHlVbmJpbmRFbnRpdHlFdmVudHMgPSBmdW5jdGlvbihlbnRpdHksIGJpbmRpbmdzKSB7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS51bmJpbmRFbnRpdHlFdmVudHModGhpcywgZW50aXR5LCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgfSkoTWFyaW9uZXR0ZSk7XG4gIFxuXG4gIC8vIEVycm9yXG4gIC8vIC0tLS0tXG4gIFxuICB2YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICduYW1lJywgJ21lc3NhZ2UnLCAnbnVtYmVyJ107XG4gIFxuICBNYXJpb25ldHRlLkVycm9yID0gTWFyaW9uZXR0ZS5leHRlbmQuY2FsbChFcnJvciwge1xuICAgIHVybFJvb3Q6ICdodHRwOi8vbWFyaW9uZXR0ZWpzLmNvbS9kb2NzL3YnICsgTWFyaW9uZXR0ZS5WRVJTSU9OICsgJy8nLFxuICBcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKF8uaXNPYmplY3QobWVzc2FnZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgZXJyb3IgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgXy5leHRlbmQodGhpcywgXy5waWNrKGVycm9yLCBlcnJvclByb3BzKSwgXy5waWNrKG9wdGlvbnMsIGVycm9yUHJvcHMpKTtcbiAgXG4gICAgICB0aGlzLmNhcHR1cmVTdGFja1RyYWNlKCk7XG4gIFxuICAgICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmxSb290ICsgb3B0aW9ucy51cmw7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgY2FwdHVyZVN0YWNrVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1hcmlvbmV0dGUuRXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlICsgKHRoaXMudXJsID8gJyBTZWU6ICcgKyB0aGlzLnVybCA6ICcnKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgTWFyaW9uZXR0ZS5FcnJvci5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIENhbGxiYWNrc1xuICAvLyAtLS0tLS0tLS1cbiAgXG4gIC8vIEEgc2ltcGxlIHdheSBvZiBtYW5hZ2luZyBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzXG4gIC8vIGFuZCBleGVjdXRpbmcgdGhlbSBhdCBhIGxhdGVyIHBvaW50IGluIHRpbWUsIHVzaW5nIGpRdWVyeSdzXG4gIC8vIGBEZWZlcnJlZGAgb2JqZWN0LlxuICBNYXJpb25ldHRlLkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlZmVycmVkID0gTWFyaW9uZXR0ZS5EZWZlcnJlZCgpO1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9O1xuICBcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5DYWxsYmFja3MucHJvdG90eXBlLCB7XG4gIFxuICAgIC8vIEFkZCBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkLiBDYWxsYmFja3MgYWRkZWQgaGVyZSBhcmVcbiAgICAvLyBndWFyYW50ZWVkIHRvIGV4ZWN1dGUsIGV2ZW4gaWYgdGhleSBhcmUgYWRkZWQgYWZ0ZXIgdGhlXG4gICAgLy8gYHJ1bmAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICBhZGQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0T3ZlcnJpZGUpIHtcbiAgICAgIHZhciBwcm9taXNlID0gXy5yZXN1bHQodGhpcy5fZGVmZXJyZWQsICdwcm9taXNlJyk7XG4gIFxuICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goe2NiOiBjYWxsYmFjaywgY3R4OiBjb250ZXh0T3ZlcnJpZGV9KTtcbiAgXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoY29udGV4dE92ZXJyaWRlKXsgYXJncy5jb250ZXh0ID0gY29udGV4dE92ZXJyaWRlOyB9XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoYXJncy5jb250ZXh0LCBhcmdzLm9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gUnVuIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aXRoIHRoZSBjb250ZXh0IHNwZWNpZmllZC5cbiAgICAvLyBBZGRpdGlvbmFsIGNhbGxiYWNrcyBjYW4gYmUgYWRkZWQgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBydW5cbiAgICAvLyBhbmQgdGhleSB3aWxsIHN0aWxsIGJlIGV4ZWN1dGVkLlxuICAgIHJ1bjogZnVuY3Rpb24ob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgdGhpcy5fZGVmZXJyZWQucmVzb2x2ZSh7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlc2V0cyB0aGUgbGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgcnVuLCBhbGxvd2luZyB0aGUgc2FtZSBsaXN0XG4gICAgLy8gdG8gYmUgcnVuIG11bHRpcGxlIHRpbWVzIC0gd2hlbmV2ZXIgdGhlIGBydW5gIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICAgIHRoaXMuX2RlZmVycmVkID0gTWFyaW9uZXR0ZS5EZWZlcnJlZCgpO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIFxuICAgICAgXy5lYWNoKGNhbGxiYWNrcywgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdGhpcy5hZGQoY2IuY2IsIGNiLmN0eCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gQ29udHJvbGxlclxuICAvLyAtLS0tLS0tLS0tXG4gIFxuICAvLyBBIG11bHRpLXB1cnBvc2Ugb2JqZWN0IHRvIHVzZSBhcyBhIGNvbnRyb2xsZXIgZm9yXG4gIC8vIG1vZHVsZXMgYW5kIHJvdXRlcnMsIGFuZCBhcyBhIG1lZGlhdG9yIGZvciB3b3JrZmxvd1xuICAvLyBhbmQgY29vcmRpbmF0aW9uIG9mIG90aGVyIG9iamVjdHMsIHZpZXdzLCBhbmQgbW9yZS5cbiAgTWFyaW9uZXR0ZS5Db250cm9sbGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5pbml0aWFsaXplKSkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICBcbiAgTWFyaW9uZXR0ZS5Db250cm9sbGVyLmV4dGVuZCA9IE1hcmlvbmV0dGUuZXh0ZW5kO1xuICBcbiAgLy8gQ29udHJvbGxlciBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBFbnN1cmUgaXQgY2FuIHRyaWdnZXIgZXZlbnRzIHdpdGggQmFja2JvbmUuRXZlbnRzXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuQ29udHJvbGxlci5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCAnYmVmb3JlOmRlc3Ryb3knLCBhcmd1bWVudHMpO1xuICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCAnZGVzdHJveScsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICB0aGlzLm9mZigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gaW1wb3J0IHRoZSBgdHJpZ2dlck1ldGhvZGAgdG8gdHJpZ2dlciBldmVudHMgd2l0aCBjb3JyZXNwb25kaW5nXG4gICAgLy8gbWV0aG9kcyBpZiB0aGUgbWV0aG9kIGV4aXN0c1xuICAgIHRyaWdnZXJNZXRob2Q6IE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZCxcbiAgXG4gICAgLy8gUHJveHkgYGdldE9wdGlvbmAgdG8gZW5hYmxlIGdldHRpbmcgb3B0aW9ucyBmcm9tIHRoaXMgb3IgdGhpcy5vcHRpb25zIGJ5IG5hbWUuXG4gICAgZ2V0T3B0aW9uOiBNYXJpb25ldHRlLnByb3h5R2V0T3B0aW9uXG4gIFxuICB9KTtcbiAgXG4gIC8vIE9iamVjdFxuICAvLyAtLS0tLS1cbiAgXG4gIC8vIEEgQmFzZSBDbGFzcyB0aGF0IG90aGVyIENsYXNzZXMgc2hvdWxkIGRlc2NlbmQgZnJvbS5cbiAgLy8gT2JqZWN0IGJvcnJvd3MgbWFueSBjb252ZW50aW9ucyBhbmQgdXRpbGl0aWVzIGZyb20gQmFja2JvbmUuXG4gIE1hcmlvbmV0dGUuT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBfLnJlc3VsdCh0aGlzLCAnb3B0aW9ucycpLCBvcHRpb25zKTtcbiAgXG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLk9iamVjdC5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIE9iamVjdCBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBFbnN1cmUgaXQgY2FuIHRyaWdnZXIgZXZlbnRzIHdpdGggQmFja2JvbmUuRXZlbnRzXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuT2JqZWN0LnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG4gIFxuICAgIC8vdGhpcyBpcyBhIG5vb3AgbWV0aG9kIGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIHRoaXMgYmFzZVxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG4gIFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6ZGVzdHJveScpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdkZXN0cm95Jyk7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbXBvcnQgdGhlIGB0cmlnZ2VyTWV0aG9kYCB0byB0cmlnZ2VyIGV2ZW50cyB3aXRoIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBtZXRob2RzIGlmIHRoZSBtZXRob2QgZXhpc3RzXG4gICAgdHJpZ2dlck1ldGhvZDogTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kLFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24sXG4gIFxuICAgIC8vIFByb3h5IGBiaW5kRW50aXR5RXZlbnRzYCB0byBlbmFibGUgYmluZGluZyB2aWV3J3MgZXZlbnRzIGZyb20gYW5vdGhlciBlbnRpdHkuXG4gICAgYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eUJpbmRFbnRpdHlFdmVudHMsXG4gIFxuICAgIC8vIFByb3h5IGB1bmJpbmRFbnRpdHlFdmVudHNgIHRvIGVuYWJsZSB1bmJpbmRpbmcgdmlldydzIGV2ZW50cyBmcm9tIGFub3RoZXIgZW50aXR5LlxuICAgIHVuYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eVVuYmluZEVudGl0eUV2ZW50c1xuICB9KTtcbiAgXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxNiwgbWF4c3RhdGVtZW50czogNDUsIG1heGxlbjogMTIwICovXG4gIFxuICAvLyBSZWdpb25cbiAgLy8gLS0tLS0tXG4gIFxuICAvLyBNYW5hZ2UgdGhlIHZpc3VhbCByZWdpb25zIG9mIHlvdXIgY29tcG9zaXRlIGFwcGxpY2F0aW9uLiBTZWVcbiAgLy8gaHR0cDovL2xvc3RlY2hpZXMuY29tL2Rlcmlja2JhaWxleS8yMDExLzEyLzEyL2NvbXBvc2l0ZS1qcy1hcHBzLXJlZ2lvbnMtYW5kLXJlZ2lvbi1tYW5hZ2Vycy9cbiAgXG4gIE1hcmlvbmV0dGUuUmVnaW9uID0gTWFyaW9uZXR0ZS5PYmplY3QuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXG4gICAgICAvLyBzZXQgb3B0aW9ucyB0ZW1wb3JhcmlseSBzbyB0aGF0IHdlIGNhbiBnZXQgYGVsYC5cbiAgICAgIC8vIG9wdGlvbnMgd2lsbCBiZSBvdmVycmlkZW4gYnkgT2JqZWN0LmNvbnN0cnVjdG9yXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMuZ2V0T3B0aW9uKCdlbCcpO1xuICBcbiAgICAgIC8vIEhhbmRsZSB3aGVuIHRoaXMuZWwgaXMgcGFzc2VkIGluIGFzIGEgJCB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICB0aGlzLmVsID0gdGhpcy5lbCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyB0aGlzLmVsWzBdIDogdGhpcy5lbDtcbiAgXG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdOb0VsRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdBbiBcImVsXCIgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGEgcmVnaW9uLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy4kZWwgPSB0aGlzLmdldEVsKHRoaXMuZWwpO1xuICAgICAgTWFyaW9uZXR0ZS5PYmplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBEaXNwbGF5cyBhIGJhY2tib25lIHZpZXcgaW5zdGFuY2UgaW5zaWRlIG9mIHRoZSByZWdpb24uXG4gICAgLy8gSGFuZGxlcyBjYWxsaW5nIHRoZSBgcmVuZGVyYCBtZXRob2QgZm9yIHlvdS4gUmVhZHMgY29udGVudFxuICAgIC8vIGRpcmVjdGx5IGZyb20gdGhlIGBlbGAgYXR0cmlidXRlLiBBbHNvIGNhbGxzIGFuIG9wdGlvbmFsXG4gICAgLy8gYG9uU2hvd2AgYW5kIGBvbkRlc3Ryb3lgIG1ldGhvZCBvbiB5b3VyIHZpZXcsIGp1c3QgYWZ0ZXIgc2hvd2luZ1xuICAgIC8vIG9yIGp1c3QgYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIHZpZXcsIHJlc3BlY3RpdmVseS5cbiAgICAvLyBUaGUgYHByZXZlbnREZXN0cm95YCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcHJldmVudCBhIHZpZXcgZnJvbVxuICAgIC8vIHRoZSBvbGQgdmlldyBiZWluZyBkZXN0cm95ZWQgb24gc2hvdy5cbiAgICAvLyBUaGUgYGZvcmNlU2hvd2Agb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgdmlldyB0byBiZVxuICAgIC8vIHJlLXJlbmRlcmVkIGlmIGl0J3MgYWxyZWFkeSBzaG93biBpbiB0aGUgcmVnaW9uLlxuICAgIHNob3c6IGZ1bmN0aW9uKHZpZXcsIG9wdGlvbnMpe1xuICAgICAgaWYgKCF0aGlzLl9lbnN1cmVFbGVtZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCh2aWV3KTtcbiAgXG4gICAgICB2YXIgc2hvd09wdGlvbnMgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBpc0RpZmZlcmVudFZpZXcgPSB2aWV3ICE9PSB0aGlzLmN1cnJlbnRWaWV3O1xuICAgICAgdmFyIHByZXZlbnREZXN0cm95ICA9ICEhc2hvd09wdGlvbnMucHJldmVudERlc3Ryb3k7XG4gICAgICB2YXIgZm9yY2VTaG93ICAgICAgID0gISFzaG93T3B0aW9ucy5mb3JjZVNob3c7XG4gIFxuICAgICAgLy8gV2UgYXJlIG9ubHkgY2hhbmdpbmcgdGhlIHZpZXcgaWYgdGhlcmUgaXMgYSBjdXJyZW50IHZpZXcgdG8gY2hhbmdlIHRvIGJlZ2luIHdpdGhcbiAgICAgIHZhciBpc0NoYW5naW5nVmlldyA9ICEhdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICAvLyBPbmx5IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdmlldyBpZiB3ZSBkb24ndCB3YW50IHRvIGBwcmV2ZW50RGVzdHJveWAgYW5kIGlmXG4gICAgICAvLyB0aGUgdmlldyBnaXZlbiBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZGlmZmVyZW50IHRoYW4gYGN1cnJlbnRWaWV3YFxuICAgICAgdmFyIF9zaG91bGREZXN0cm95VmlldyA9IGlzRGlmZmVyZW50VmlldyAmJiAhcHJldmVudERlc3Ryb3k7XG4gIFxuICAgICAgLy8gT25seSBzaG93IHRoZSB2aWV3IGdpdmVuIGluIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCBpcyBkaWZmZXJlbnQgdGhhblxuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBvciBpZiB3ZSB3YW50IHRvIHJlLXNob3cgdGhlIHZpZXcuIE5vdGUgdGhhdCBpZlxuICAgICAgLy8gYF9zaG91bGREZXN0cm95Vmlld2AgaXMgdHJ1ZSwgdGhlbiBgX3Nob3VsZFNob3dWaWV3YCBpcyBhbHNvIG5lY2Vzc2FyaWx5IHRydWUuXG4gICAgICB2YXIgX3Nob3VsZFNob3dWaWV3ID0gaXNEaWZmZXJlbnRWaWV3IHx8IGZvcmNlU2hvdztcbiAgXG4gICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3dhcE91dCcsIHRoaXMuY3VycmVudFZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICBcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaWV3Ll9wYXJlbnQ7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF9zaG91bGREZXN0cm95Vmlldykge1xuICAgICAgICB0aGlzLmVtcHR5KCk7XG4gIFxuICAgICAgLy8gQSBgZGVzdHJveWAgZXZlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIGNsZWFuIHVwIG1hbnVhbGx5IHJlbW92ZWQgdmlld3MuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRldGFjaCB0aGlzIGV2ZW50IHdoZW4gYSBuZXcgdmlldyBpcyBnb2luZyB0byBiZSBzaG93biBhcyBpdFxuICAgICAgLy8gaXMgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgICAgfSBlbHNlIGlmIChpc0NoYW5naW5nVmlldyAmJiBfc2hvdWxkU2hvd1ZpZXcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlldy5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmVtcHR5LCB0aGlzKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoX3Nob3VsZFNob3dWaWV3KSB7XG4gIFxuICAgICAgICAvLyBXZSBuZWVkIHRvIGxpc3RlbiBmb3IgaWYgYSB2aWV3IGlzIGRlc3Ryb3llZFxuICAgICAgICAvLyBpbiBhIHdheSBvdGhlciB0aGFuIHRocm91Z2ggdGhlIHJlZ2lvbi5cbiAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnRWaWV3IHNpbmNlIG9uY2UgYSB2aWV3IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAvLyB3ZSBjYW4gbm90IHJldXNlIGl0LlxuICAgICAgICB2aWV3Lm9uY2UoJ2Rlc3Ryb3knLCB0aGlzLmVtcHR5LCB0aGlzKTtcbiAgICAgICAgdmlldy5yZW5kZXIoKTtcbiAgXG4gICAgICAgIHZpZXcuX3BhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzd2FwJywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnNob3cnLCB2aWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ2JlZm9yZTpzaG93JywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gIFxuICAgICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N3YXBPdXQnLCB0aGlzLmN1cnJlbnRWaWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gQW4gYXJyYXkgb2Ygdmlld3MgdGhhdCB3ZSdyZSBhYm91dCB0byBkaXNwbGF5XG4gICAgICAgIHZhciBhdHRhY2hlZFJlZ2lvbiA9IE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQodGhpcy5lbCk7XG4gIFxuICAgICAgICAvLyBUaGUgdmlld3MgdGhhdCB3ZSdyZSBhYm91dCB0byBhdHRhY2ggdG8gdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgcHJldmVudCBfZ2V0TmVzdGVkVmlld3MgZnJvbSBiZWluZyBleGVjdXRlZCB1bm5lY2Vzc2FyaWx5XG4gICAgICAgIC8vIGFzIGl0J3MgYSBwb3RlbnRpYWxseS1zbG93IG1ldGhvZFxuICAgICAgICB2YXIgZGlzcGxheWVkVmlld3MgPSBbXTtcbiAgXG4gICAgICAgIHZhciB0cmlnZ2VyQmVmb3JlQXR0YWNoID0gc2hvd09wdGlvbnMudHJpZ2dlckJlZm9yZUF0dGFjaCB8fCB0aGlzLnRyaWdnZXJCZWZvcmVBdHRhY2g7XG4gICAgICAgIHZhciB0cmlnZ2VyQXR0YWNoID0gc2hvd09wdGlvbnMudHJpZ2dlckF0dGFjaCB8fCB0aGlzLnRyaWdnZXJBdHRhY2g7XG4gIFxuICAgICAgICBpZiAoYXR0YWNoZWRSZWdpb24gJiYgdHJpZ2dlckJlZm9yZUF0dGFjaCkge1xuICAgICAgICAgIGRpc3BsYXllZFZpZXdzID0gdGhpcy5fZGlzcGxheWVkVmlld3Modmlldyk7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckF0dGFjaChkaXNwbGF5ZWRWaWV3cywgJ2JlZm9yZTonKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhpcy5hdHRhY2hIdG1sKHZpZXcpO1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdmlldztcbiAgXG4gICAgICAgIGlmIChhdHRhY2hlZFJlZ2lvbiAmJiB0cmlnZ2VyQXR0YWNoKSB7XG4gICAgICAgICAgZGlzcGxheWVkVmlld3MgPSB0aGlzLl9kaXNwbGF5ZWRWaWV3cyh2aWV3KTtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXR0YWNoKGRpc3BsYXllZFZpZXdzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGlzQ2hhbmdpbmdWaWV3KSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzd2FwJywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnc2hvdycsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCAnc2hvdycsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgdHJpZ2dlckJlZm9yZUF0dGFjaDogdHJ1ZSxcbiAgICB0cmlnZ2VyQXR0YWNoOiB0cnVlLFxuICBcbiAgICBfdHJpZ2dlckF0dGFjaDogZnVuY3Rpb24odmlld3MsIHByZWZpeCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IChwcmVmaXggfHwgJycpICsgJ2F0dGFjaCc7XG4gICAgICBfLmVhY2godmlld3MsIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgZXZlbnROYW1lLCB2aWV3LCB0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIF9kaXNwbGF5ZWRWaWV3czogZnVuY3Rpb24odmlldykge1xuICAgICAgcmV0dXJuIF8udW5pb24oW3ZpZXddLCBfLnJlc3VsdCh2aWV3LCAnX2dldE5lc3RlZFZpZXdzJykgfHwgW10pO1xuICAgIH0sXG4gIFxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHRoaXMuZWwpKSB7XG4gICAgICAgIHRoaXMuJGVsID0gdGhpcy5nZXRFbCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgICAgfVxuICBcbiAgICAgIGlmICghdGhpcy4kZWwgfHwgdGhpcy4kZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbignYWxsb3dNaXNzaW5nRWwnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcignQW4gXCJlbFwiICcgKyB0aGlzLiRlbC5zZWxlY3RvciArICcgbXVzdCBleGlzdCBpbiBET00nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgXG4gICAgX2Vuc3VyZVZpZXdJc0ludGFjdDogZnVuY3Rpb24odmlldykge1xuICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnVmlld05vdFZhbGlkJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIHZpZXcgcGFzc2VkIGlzIHVuZGVmaW5lZCBhbmQgdGhlcmVmb3JlIGludmFsaWQuIFlvdSBtdXN0IHBhc3MgYSB2aWV3IGluc3RhbmNlIHRvIHNob3cuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdEZXN0cm95ZWRFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ1ZpZXcgKGNpZDogXCInICsgdmlldy5jaWQgKyAnXCIpIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSBob3cgdGhlIHJlZ2lvbiBmaW5kcyB0aGVcbiAgICAvLyBET00gZWxlbWVudCB0aGF0IGl0IG1hbmFnZXMuIFJldHVybiBhIGpRdWVyeSBzZWxlY3RvciBvYmplY3QuXG4gICAgZ2V0RWw6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuJChlbCk7XG4gICAgfSxcbiAgXG4gICAgLy8gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIGhvdyB0aGUgbmV3IHZpZXcgaXNcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgYCRlbGAgdGhhdCB0aGUgcmVnaW9uIGlzIG1hbmFnaW5nXG4gICAgYXR0YWNoSHRtbDogZnVuY3Rpb24odmlldykge1xuICAgICAgLy8gZW1wdHkgdGhlIG5vZGUgYW5kIGFwcGVuZCBuZXcgdmlld1xuICAgICAgLy8gV2UgY2FuIG5vdCB1c2UgYC5pbm5lckhUTUxgIGR1ZSB0byB0aGUgZmFjdCB0aGF0IElFXG4gICAgICAvLyB3aWxsIG5vdCBsZXQgdXMgY2xlYXIgdGhlIGh0bWwgb2YgdGFibGVzIGFuZCBzZWxlY3RzLlxuICAgICAgLy8gV2UgYWxzbyBkbyBub3Qgd2FudCB0byB1c2UgdGhlIG1vcmUgZGVjbGFyYXRpdmUgYGVtcHR5YCBtZXRob2RcbiAgICAgIC8vIHRoYXQganF1ZXJ5IGV4cG9zZXMgc2luY2UgYC5lbXB0eWAgbG9vcHMgb3ZlciBhbGwgb2YgdGhlIGNoaWxkcmVuIERPTVxuICAgICAgLy8gbm9kZXMgYW5kIHVuc2V0cyB0aGUgbGlzdGVuZXJzIG9uIGVhY2ggbm9kZS4gV2hpbGUgdGhpcyBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlc2lyYWJsZSB0aGluZywgaXQgY29tZXMgYXQgcXVpdGUgYSBoaWdoIHBlcmYgY29zdC4gRm9yIHRoYXQgcmVhc29uXG4gICAgICAvLyB3ZSBhcmUgc2ltcGx5IGNsZWFyaW5nIHRoZSBodG1sIGNvbnRlbnRzIG9mIHRoZSBub2RlLlxuICAgICAgdGhpcy4kZWwuaHRtbCgnJyk7XG4gICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHZpZXcuZWwpO1xuICAgIH0sXG4gIFxuICAgIC8vIERlc3Ryb3kgdGhlIGN1cnJlbnQgdmlldywgaWYgdGhlcmUgaXMgb25lLiBJZiB0aGVyZSBpcyBub1xuICAgIC8vIGN1cnJlbnQgdmlldywgaXQgZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zIGltbWVkaWF0ZWx5LlxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyB2aWV3IGluIHRoZSByZWdpb25cbiAgICAgIC8vIHdlIHNob3VsZCBub3QgcmVtb3ZlIGFueXRoaW5nXG4gICAgICBpZiAoIXZpZXcpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgdmlldy5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmVtcHR5LCB0aGlzKTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOmVtcHR5Jywgdmlldyk7XG4gICAgICB0aGlzLl9kZXN0cm95VmlldygpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdlbXB0eScsIHZpZXcpO1xuICBcbiAgICAgIC8vIFJlbW92ZSByZWdpb24gcG9pbnRlciB0byB0aGUgY3VycmVudFZpZXdcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaWV3O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gY2FsbCAnZGVzdHJveScgb3IgJ3JlbW92ZScsIGRlcGVuZGluZyBvbiB3aGljaCBpcyBmb3VuZFxuICAgIC8vIG9uIHRoZSB2aWV3IChpZiBzaG93aW5nIGEgcmF3IEJhY2tib25lIHZpZXcgb3IgYSBNYXJpb25ldHRlIFZpZXcpXG4gICAgX2Rlc3Ryb3lWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICBpZiAodmlldy5kZXN0cm95ICYmICF2aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIGlmICh2aWV3LnJlbW92ZSkge1xuICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICBcbiAgICAgICAgLy8gYXBwZW5kaW5nIGlzRGVzdHJveWVkIHRvIHJhdyBCYWNrYm9uZSBWaWV3IGFsbG93cyByZWdpb25zXG4gICAgICAgIC8vIHRvIHRocm93IGEgVmlld0Rlc3Ryb3llZEVycm9yIGZvciB0aGlzIHZpZXdcbiAgICAgICAgdmlldy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gQXR0YWNoIGFuIGV4aXN0aW5nIHZpZXcgdG8gdGhlIHJlZ2lvbi4gVGhpc1xuICAgIC8vIHdpbGwgbm90IGNhbGwgYHJlbmRlcmAgb3IgYG9uU2hvd2AgZm9yIHRoZSBuZXcgdmlldyxcbiAgICAvLyBhbmQgd2lsbCBub3QgcmVwbGFjZSB0aGUgY3VycmVudCBIVE1MIGZvciB0aGUgYGVsYFxuICAgIC8vIG9mIHRoZSByZWdpb24uXG4gICAgYXR0YWNoVmlldzogZnVuY3Rpb24odmlldykge1xuICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZpZXc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBDaGVja3Mgd2hldGhlciBhIHZpZXcgaXMgY3VycmVudGx5IHByZXNlbnQgd2l0aGluXG4gICAgLy8gdGhlIHJlZ2lvbi4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgYW5kIGBmYWxzZWAgaWZcbiAgICAvLyBubyB2aWV3IGlzIHByZXNlbnQuXG4gICAgaGFzVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmN1cnJlbnRWaWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIFJlc2V0IHRoZSByZWdpb24gYnkgZGVzdHJveWluZyBhbnkgZXhpc3RpbmcgdmlldyBhbmRcbiAgICAvLyBjbGVhcmluZyBvdXQgdGhlIGNhY2hlZCBgJGVsYC4gVGhlIG5leHQgdGltZSBhIHZpZXdcbiAgICAvLyBpcyBzaG93biB2aWEgdGhpcyByZWdpb24sIHRoZSByZWdpb24gd2lsbCByZS1xdWVyeSB0aGVcbiAgICAvLyBET00gZm9yIHRoZSByZWdpb24ncyBgZWxgLlxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1wdHkoKTtcbiAgXG4gICAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsLnNlbGVjdG9yO1xuICAgICAgfVxuICBcbiAgICAgIGRlbGV0ZSB0aGlzLiRlbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgXG4gIH0sXG4gIFxuICAvLyBTdGF0aWMgTWV0aG9kc1xuICB7XG4gIFxuICAgIC8vIEJ1aWxkIGFuIGluc3RhbmNlIG9mIGEgcmVnaW9uIGJ5IHBhc3NpbmcgaW4gYSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgIC8vIGFuZCBhIGRlZmF1bHQgcmVnaW9uIGNsYXNzIHRvIHVzZSBpZiBub25lIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnLlxuICAgIC8vXG4gICAgLy8gVGhlIGNvbmZpZyBvYmplY3Qgc2hvdWxkIGVpdGhlciBiZSBhIHN0cmluZyBhcyBhIGpRdWVyeSBET00gc2VsZWN0b3IsXG4gICAgLy8gYSBSZWdpb24gY2xhc3MgZGlyZWN0bHksIG9yIGFuIG9iamVjdCBsaXRlcmFsIHRoYXQgc3BlY2lmaWVzIGEgc2VsZWN0b3IsXG4gICAgLy8gYSBjdXN0b20gcmVnaW9uQ2xhc3MsIGFuZCBhbnkgb3B0aW9ucyB0byBiZSBzdXBwbGllZCB0byB0aGUgcmVnaW9uOlxuICAgIC8vXG4gICAgLy8gYGBganNcbiAgICAvLyB7XG4gICAgLy8gICBzZWxlY3RvcjogXCIjZm9vXCIsXG4gICAgLy8gICByZWdpb25DbGFzczogTXlDdXN0b21SZWdpb24sXG4gICAgLy8gICBhbGxvd01pc3NpbmdFbDogZmFsc2VcbiAgICAvLyB9XG4gICAgLy8gYGBgXG4gICAgLy9cbiAgICBidWlsZFJlZ2lvbjogZnVuY3Rpb24ocmVnaW9uQ29uZmlnLCBEZWZhdWx0UmVnaW9uQ2xhc3MpIHtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHJlZ2lvbkNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9uRnJvbVNlbGVjdG9yKHJlZ2lvbkNvbmZpZywgRGVmYXVsdFJlZ2lvbkNsYXNzKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAocmVnaW9uQ29uZmlnLnNlbGVjdG9yIHx8IHJlZ2lvbkNvbmZpZy5lbCB8fCByZWdpb25Db25maWcucmVnaW9uQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9uRnJvbU9iamVjdChyZWdpb25Db25maWcsIERlZmF1bHRSZWdpb25DbGFzcyk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihyZWdpb25Db25maWcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFJlZ2lvbkZyb21SZWdpb25DbGFzcyhyZWdpb25Db25maWcpO1xuICAgICAgfVxuICBcbiAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ0ltcHJvcGVyIHJlZ2lvbiBjb25maWd1cmF0aW9uIHR5cGUuJyxcbiAgICAgICAgdXJsOiAnbWFyaW9uZXR0ZS5yZWdpb24uaHRtbCNyZWdpb24tY29uZmlndXJhdGlvbi10eXBlcydcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIEJ1aWxkIHRoZSByZWdpb24gZnJvbSBhIHN0cmluZyBzZWxlY3RvciBsaWtlICcjZm9vLXJlZ2lvbidcbiAgICBfYnVpbGRSZWdpb25Gcm9tU2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yLCBEZWZhdWx0UmVnaW9uQ2xhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFJlZ2lvbkNsYXNzKHsgZWw6IHNlbGVjdG9yIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIEJ1aWxkIHRoZSByZWdpb24gZnJvbSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgLy8gYGBganNcbiAgICAvLyB7IHNlbGVjdG9yOiAnI2ZvbycsIHJlZ2lvbkNsYXNzOiBGb29SZWdpb24sIGFsbG93TWlzc2luZ0VsOiBmYWxzZSB9XG4gICAgLy8gYGBgXG4gICAgX2J1aWxkUmVnaW9uRnJvbU9iamVjdDogZnVuY3Rpb24ocmVnaW9uQ29uZmlnLCBEZWZhdWx0UmVnaW9uQ2xhc3MpIHtcbiAgICAgIHZhciBSZWdpb25DbGFzcyA9IHJlZ2lvbkNvbmZpZy5yZWdpb25DbGFzcyB8fCBEZWZhdWx0UmVnaW9uQ2xhc3M7XG4gICAgICB2YXIgb3B0aW9ucyA9IF8ub21pdChyZWdpb25Db25maWcsICdzZWxlY3RvcicsICdyZWdpb25DbGFzcycpO1xuICBcbiAgICAgIGlmIChyZWdpb25Db25maWcuc2VsZWN0b3IgJiYgIW9wdGlvbnMuZWwpIHtcbiAgICAgICAgb3B0aW9ucy5lbCA9IHJlZ2lvbkNvbmZpZy5zZWxlY3RvcjtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgcmVnaW9uID0gbmV3IFJlZ2lvbkNsYXNzKG9wdGlvbnMpO1xuICBcbiAgICAgIC8vIG92ZXJyaWRlIHRoZSBgZ2V0RWxgIGZ1bmN0aW9uIGlmIHdlIGhhdmUgYSBwYXJlbnRFbFxuICAgICAgLy8gdGhpcyBtdXN0IGJlIG92ZXJyaWRkZW4gdG8gZW5zdXJlIHRoZSBzZWxlY3RvciBpcyBmb3VuZFxuICAgICAgLy8gb24gdGhlIGZpcnN0IHVzZSBvZiB0aGUgcmVnaW9uLiBpZiB3ZSB0cnkgdG8gYXNzaWduIHRoZVxuICAgICAgLy8gcmVnaW9uJ3MgYGVsYCB0byBgcGFyZW50RWwuZmluZChzZWxlY3RvcilgIGluIHRoZSBvYmplY3RcbiAgICAgIC8vIGxpdGVyYWwgdG8gYnVpbGQgdGhlIHJlZ2lvbiwgdGhlIGVsZW1lbnQgd2lsbCBub3QgYmVcbiAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIERPTSBhbHJlYWR5LCBhbmQgd2lsbCBjYXVzZSBwcm9ibGVtc1xuICAgICAgaWYgKHJlZ2lvbkNvbmZpZy5wYXJlbnRFbCkge1xuICAgICAgICByZWdpb24uZ2V0RWwgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJhY2tib25lLiQoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFyZW50RWwgPSByZWdpb25Db25maWcucGFyZW50RWw7XG4gICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihwYXJlbnRFbCkpIHtcbiAgICAgICAgICAgIHBhcmVudEVsID0gcGFyZW50RWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmVudEVsLmZpbmQoZWwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiByZWdpb247XG4gICAgfSxcbiAgXG4gICAgLy8gQnVpbGQgdGhlIHJlZ2lvbiBkaXJlY3RseSBmcm9tIGEgZ2l2ZW4gYFJlZ2lvbkNsYXNzYFxuICAgIF9idWlsZFJlZ2lvbkZyb21SZWdpb25DbGFzczogZnVuY3Rpb24oUmVnaW9uQ2xhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnaW9uQ2xhc3MoKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gUmVnaW9uIE1hbmFnZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1hbmFnZSBvbmUgb3IgbW9yZSByZWxhdGVkIGBNYXJpb25ldHRlLlJlZ2lvbmAgb2JqZWN0cy5cbiAgTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyID0gTWFyaW9uZXR0ZS5Db250cm9sbGVyLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3JlZ2lvbnMgPSB7fTtcbiAgXG4gICAgICBNYXJpb25ldHRlLkNvbnRyb2xsZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXG4gICAgICB0aGlzLmFkZFJlZ2lvbnModGhpcy5nZXRPcHRpb24oJ3JlZ2lvbnMnKSk7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIG11bHRpcGxlIHJlZ2lvbnMgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYVxuICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgbGl0ZXJhbCwgd2hlcmVcbiAgICAvLyBlYWNoIGtleSBiZWNvbWVzIHRoZSByZWdpb24gbmFtZSwgYW5kIGVhY2ggdmFsdWUgaXNcbiAgICAvLyB0aGUgcmVnaW9uIGRlZmluaXRpb24uXG4gICAgYWRkUmVnaW9uczogZnVuY3Rpb24ocmVnaW9uRGVmaW5pdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHJlZ2lvbkRlZmluaXRpb25zKSkge1xuICAgICAgICByZWdpb25EZWZpbml0aW9ucyA9IHJlZ2lvbkRlZmluaXRpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHJlZ2lvbnMgPSB7fTtcbiAgXG4gICAgICBfLmVhY2gocmVnaW9uRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0ge3NlbGVjdG9yOiBkZWZpbml0aW9ufTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGRlZmluaXRpb24uc2VsZWN0b3IpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0gXy5kZWZhdWx0cyh7fSwgZGVmaW5pdGlvbiwgZGVmYXVsdHMpO1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hZGRSZWdpb24obmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIHJlZ2lvbnNbbmFtZV0gPSByZWdpb247XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gcmVnaW9ucztcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgYW4gaW5kaXZpZHVhbCByZWdpb24gdG8gdGhlIHJlZ2lvbiBtYW5hZ2VyLFxuICAgIC8vIGFuZCByZXR1cm4gdGhlIHJlZ2lvbiBpbnN0YW5jZVxuICAgIGFkZFJlZ2lvbjogZnVuY3Rpb24obmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgdmFyIHJlZ2lvbjtcbiAgXG4gICAgICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIE1hcmlvbmV0dGUuUmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IGRlZmluaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpb24gPSBNYXJpb25ldHRlLlJlZ2lvbi5idWlsZFJlZ2lvbihkZWZpbml0aW9uLCBNYXJpb25ldHRlLlJlZ2lvbik7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6YWRkOnJlZ2lvbicsIG5hbWUsIHJlZ2lvbik7XG4gIFxuICAgICAgcmVnaW9uLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgdGhpcy5fc3RvcmUobmFtZSwgcmVnaW9uKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2FkZDpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYSByZWdpb24gYnkgbmFtZVxuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbnNbbmFtZV07XG4gICAgfSxcbiAgXG4gICAgLy8gR2V0cyBhbGwgdGhlIHJlZ2lvbnMgY29udGFpbmVkIHdpdGhpblxuICAgIC8vIHRoZSBgcmVnaW9uTWFuYWdlcmAgaW5zdGFuY2UuXG4gICAgZ2V0UmVnaW9uczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX3JlZ2lvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbW92ZSBhIHJlZ2lvbiBieSBuYW1lXG4gICAgcmVtb3ZlUmVnaW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcmVnaW9uID0gdGhpcy5fcmVnaW9uc1tuYW1lXTtcbiAgICAgIHRoaXMuX3JlbW92ZShuYW1lLCByZWdpb24pO1xuICBcbiAgICAgIHJldHVybiByZWdpb247XG4gICAgfSxcbiAgXG4gICAgLy8gRW1wdHkgYWxsIHJlZ2lvbnMgaW4gdGhlIHJlZ2lvbiBtYW5hZ2VyLCBhbmRcbiAgICAvLyByZW1vdmUgdGhlbVxuICAgIHJlbW92ZVJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZ2lvbnMgPSB0aGlzLmdldFJlZ2lvbnMoKTtcbiAgICAgIF8uZWFjaCh0aGlzLl9yZWdpb25zLCBmdW5jdGlvbihyZWdpb24sIG5hbWUpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5hbWUsIHJlZ2lvbik7XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gcmVnaW9ucztcbiAgICB9LFxuICBcbiAgICAvLyBFbXB0eSBhbGwgcmVnaW9ucyBpbiB0aGUgcmVnaW9uIG1hbmFnZXIsIGJ1dFxuICAgIC8vIGxlYXZlIHRoZW0gYXR0YWNoZWRcbiAgICBlbXB0eVJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZ2lvbnMgPSB0aGlzLmdldFJlZ2lvbnMoKTtcbiAgICAgIF8uaW52b2tlKHJlZ2lvbnMsICdlbXB0eScpO1xuICAgICAgcmV0dXJuIHJlZ2lvbnM7XG4gICAgfSxcbiAgXG4gICAgLy8gRGVzdHJveSBhbGwgcmVnaW9ucyBhbmQgc2h1dCBkb3duIHRoZSByZWdpb25cbiAgICAvLyBtYW5hZ2VyIGVudGlyZWx5XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbW92ZVJlZ2lvbnMoKTtcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLkNvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gc3RvcmUgcmVnaW9uc1xuICAgIF9zdG9yZTogZnVuY3Rpb24obmFtZSwgcmVnaW9uKSB7XG4gICAgICB0aGlzLl9yZWdpb25zW25hbWVdID0gcmVnaW9uO1xuICAgICAgdGhpcy5fc2V0TGVuZ3RoKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIHJlbW92ZSBhIHJlZ2lvblxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVtb3ZlOnJlZ2lvbicsIG5hbWUsIHJlZ2lvbik7XG4gICAgICByZWdpb24uZW1wdHkoKTtcbiAgICAgIHJlZ2lvbi5zdG9wTGlzdGVuaW5nKCk7XG4gIFxuICAgICAgZGVsZXRlIHJlZ2lvbi5fcGFyZW50O1xuICAgICAgZGVsZXRlIHRoaXMuX3JlZ2lvbnNbbmFtZV07XG4gICAgICB0aGlzLl9zZXRMZW5ndGgoKTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVtb3ZlOnJlZ2lvbicsIG5hbWUsIHJlZ2lvbik7XG4gICAgfSxcbiAgXG4gICAgLy8gc2V0IHRoZSBudW1iZXIgb2YgcmVnaW9ucyBjdXJyZW50IGhlbGRcbiAgICBfc2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gXy5zaXplKHRoaXMuX3JlZ2lvbnMpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBNYXJpb25ldHRlLmFjdEFzQ29sbGVjdGlvbihNYXJpb25ldHRlLlJlZ2lvbk1hbmFnZXIucHJvdG90eXBlLCAnX3JlZ2lvbnMnKTtcbiAgXG5cbiAgLy8gVGVtcGxhdGUgQ2FjaGVcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1hbmFnZSB0ZW1wbGF0ZXMgc3RvcmVkIGluIGA8c2NyaXB0PmAgYmxvY2tzLFxuICAvLyBjYWNoaW5nIHRoZW0gZm9yIGZhc3RlciBhY2Nlc3MuXG4gIE1hcmlvbmV0dGUuVGVtcGxhdGVDYWNoZSA9IGZ1bmN0aW9uKHRlbXBsYXRlSWQpIHtcbiAgICB0aGlzLnRlbXBsYXRlSWQgPSB0ZW1wbGF0ZUlkO1xuICB9O1xuICBcbiAgLy8gVGVtcGxhdGVDYWNoZSBvYmplY3QtbGV2ZWwgbWV0aG9kcy4gTWFuYWdlIHRoZSB0ZW1wbGF0ZVxuICAvLyBjYWNoZXMgZnJvbSB0aGVzZSBtZXRob2QgY2FsbHMgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAvLyB5b3VyIG93biBUZW1wbGF0ZUNhY2hlIGluc3RhbmNlc1xuICBfLmV4dGVuZChNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUsIHtcbiAgICB0ZW1wbGF0ZUNhY2hlczoge30sXG4gIFxuICAgIC8vIEdldCB0aGUgc3BlY2lmaWVkIHRlbXBsYXRlIGJ5IGlkLiBFaXRoZXJcbiAgICAvLyByZXRyaWV2ZXMgdGhlIGNhY2hlZCB2ZXJzaW9uLCBvciBsb2FkcyBpdFxuICAgIC8vIGZyb20gdGhlIERPTS5cbiAgICBnZXQ6IGZ1bmN0aW9uKHRlbXBsYXRlSWQpIHtcbiAgICAgIHZhciBjYWNoZWRUZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVDYWNoZXNbdGVtcGxhdGVJZF07XG4gIFxuICAgICAgaWYgKCFjYWNoZWRUZW1wbGF0ZSkge1xuICAgICAgICBjYWNoZWRUZW1wbGF0ZSA9IG5ldyBNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUodGVtcGxhdGVJZCk7XG4gICAgICAgIHRoaXMudGVtcGxhdGVDYWNoZXNbdGVtcGxhdGVJZF0gPSBjYWNoZWRUZW1wbGF0ZTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gY2FjaGVkVGVtcGxhdGUubG9hZCgpO1xuICAgIH0sXG4gIFxuICAgIC8vIENsZWFyIHRlbXBsYXRlcyBmcm9tIHRoZSBjYWNoZS4gSWYgbm8gYXJndW1lbnRzXG4gICAgLy8gYXJlIHNwZWNpZmllZCwgY2xlYXJzIGFsbCB0ZW1wbGF0ZXM6XG4gICAgLy8gYGNsZWFyKClgXG4gICAgLy9cbiAgICAvLyBJZiBhcmd1bWVudHMgYXJlIHNwZWNpZmllZCwgY2xlYXJzIGVhY2ggb2YgdGhlXG4gICAgLy8gc3BlY2lmaWVkIHRlbXBsYXRlcyBmcm9tIHRoZSBjYWNoZTpcbiAgICAvLyBgY2xlYXIoXCIjdDFcIiwgXCIjdDJcIiwgXCIuLi5cIilgXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICBcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBsYXRlQ2FjaGVzW2FyZ3NbaV1dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ2FjaGVzID0ge307XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIFRlbXBsYXRlQ2FjaGUgaW5zdGFuY2UgbWV0aG9kcywgYWxsb3dpbmcgZWFjaFxuICAvLyB0ZW1wbGF0ZSBjYWNoZSBvYmplY3QgdG8gbWFuYWdlIGl0cyBvd24gc3RhdGVcbiAgLy8gYW5kIGtub3cgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gbG9hZGVkXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuVGVtcGxhdGVDYWNoZS5wcm90b3R5cGUsIHtcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGxvYWQgdGhlIHRlbXBsYXRlXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBHdWFyZCBjbGF1c2UgdG8gcHJldmVudCBsb2FkaW5nIHRoaXMgdGVtcGxhdGUgbW9yZSB0aGFuIG9uY2VcbiAgICAgIGlmICh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBMb2FkIHRoZSB0ZW1wbGF0ZSBhbmQgY29tcGlsZSBpdFxuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5sb2FkVGVtcGxhdGUodGhpcy50ZW1wbGF0ZUlkKTtcbiAgICAgIHRoaXMuY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZFRlbXBsYXRlO1xuICAgIH0sXG4gIFxuICAgIC8vIExvYWQgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBET00sIGJ5IGRlZmF1bHQuIE92ZXJyaWRlXG4gICAgLy8gdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB5b3VyIG93biB0ZW1wbGF0ZSByZXRyaWV2YWxcbiAgICAvLyBGb3IgYXN5bmNocm9ub3VzIGxvYWRpbmcgd2l0aCBBTUQvUmVxdWlyZUpTLCBjb25zaWRlclxuICAgIC8vIHVzaW5nIGEgdGVtcGxhdGUtbG9hZGVyIHBsdWdpbiBhcyBkZXNjcmliZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLm1hcmlvbmV0dGUvd2lraS9Vc2luZy1tYXJpb25ldHRlLXdpdGgtcmVxdWlyZWpzXG4gICAgbG9hZFRlbXBsYXRlOiBmdW5jdGlvbih0ZW1wbGF0ZUlkKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBCYWNrYm9uZS4kKHRlbXBsYXRlSWQpLmh0bWwoKTtcbiAgXG4gICAgICBpZiAoIXRlbXBsYXRlIHx8IHRlbXBsYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ05vVGVtcGxhdGVFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlOiBcIicgKyB0ZW1wbGF0ZUlkICsgJ1wiJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfSxcbiAgXG4gICAgLy8gUHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlIGJlZm9yZSBjYWNoaW5nIGl0LiBPdmVycmlkZVxuICAgIC8vIHRoaXMgbWV0aG9kIGlmIHlvdSBkbyBub3QgbmVlZCB0byBwcmUtY29tcGlsZSBhIHRlbXBsYXRlXG4gICAgLy8gKEpTVCAvIFJlcXVpcmVKUyBmb3IgZXhhbXBsZSkgb3IgaWYgeW91IHdhbnQgdG8gY2hhbmdlXG4gICAgLy8gdGhlIHRlbXBsYXRlIGVuZ2luZSB1c2VkIChIYW5kZWJhcnMsIGV0YykuXG4gICAgY29tcGlsZVRlbXBsYXRlOiBmdW5jdGlvbihyYXdUZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIF8udGVtcGxhdGUocmF3VGVtcGxhdGUpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBSZW5kZXJlclxuICAvLyAtLS0tLS0tLVxuICBcbiAgLy8gUmVuZGVyIGEgdGVtcGxhdGUgd2l0aCBkYXRhIGJ5IHBhc3NpbmcgaW4gdGhlIHRlbXBsYXRlXG4gIC8vIHNlbGVjdG9yIGFuZCB0aGUgZGF0YSB0byByZW5kZXIuXG4gIE1hcmlvbmV0dGUuUmVuZGVyZXIgPSB7XG4gIFxuICAgIC8vIFJlbmRlciBhIHRlbXBsYXRlIHdpdGggZGF0YS4gVGhlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIGlzXG4gICAgLy8gcGFzc2VkIHRvIHRoZSBgVGVtcGxhdGVDYWNoZWAgb2JqZWN0IHRvIHJldHJpZXZlIHRoZVxuICAgIC8vIHRlbXBsYXRlIGZ1bmN0aW9uLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHlvdXIgb3duXG4gICAgLy8gY3VzdG9tIHJlbmRlcmluZyBhbmQgdGVtcGxhdGUgaGFuZGxpbmcgZm9yIGFsbCBvZiBNYXJpb25ldHRlLlxuICAgIHJlbmRlcjogZnVuY3Rpb24odGVtcGxhdGUsIGRhdGEpIHtcbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdUZW1wbGF0ZU5vdEZvdW5kRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgcmVuZGVyIHRoZSB0ZW1wbGF0ZSBzaW5jZSBpdHMgZmFsc2UsIG51bGwgb3IgdW5kZWZpbmVkLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHRlbXBsYXRlRnVuYztcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGVtcGxhdGVGdW5jID0gdGVtcGxhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZUZ1bmMgPSBNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUuZ2V0KHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGVtcGxhdGVGdW5jKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgXG5cbiAgLyoganNoaW50IG1heGxlbjogMTE0LCBub25ldzogZmFsc2UgKi9cbiAgLy8gVmlld1xuICAvLyAtLS0tXG4gIFxuICAvLyBUaGUgY29yZSB2aWV3IGNsYXNzIHRoYXQgb3RoZXIgTWFyaW9uZXR0ZSB2aWV3cyBleHRlbmQgZnJvbS5cbiAgTWFyaW9uZXR0ZS5WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgXy5iaW5kQWxsKHRoaXMsICdyZW5kZXInKTtcbiAgXG4gICAgICBvcHRpb25zID0gXy5pc0Z1bmN0aW9uKG9wdGlvbnMpID8gb3B0aW9ucy5jYWxsKHRoaXMpIDogb3B0aW9ucztcbiAgXG4gICAgICAvLyB0aGlzIGV4cG9zZXMgdmlldyBvcHRpb25zIHRvIHRoZSB2aWV3IGluaXRpYWxpemVyXG4gICAgICAvLyB0aGlzIGlzIGEgYmFja2ZpbGwgc2luY2UgYmFja2JvbmUgcmVtb3ZlZCB0aGUgYXNzaWdubWVudFxuICAgICAgLy8gb2YgdGhpcy5vcHRpb25zXG4gICAgICAvLyBhdCBzb21lIHBvaW50IGhvd2V2ZXIgdGhpcyBtYXkgYmUgcmVtb3ZlZFxuICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdvcHRpb25zJyksIG9wdGlvbnMpO1xuICBcbiAgICAgIHRoaXMuX2JlaGF2aW9ycyA9IE1hcmlvbmV0dGUuQmVoYXZpb3JzKHRoaXMpO1xuICBcbiAgICAgIEJhY2tib25lLlZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICBNYXJpb25ldHRlLk1vbml0b3JET01SZWZyZXNoKHRoaXMpO1xuICAgICAgdGhpcy5vbignc2hvdycsIHRoaXMub25TaG93Q2FsbGVkKTtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgdGhlIHRlbXBsYXRlIGZvciB0aGlzIHZpZXdcbiAgICAvLyBpbnN0YW5jZS4gWW91IGNhbiBzZXQgYSBgdGVtcGxhdGVgIGF0dHJpYnV0ZSBpbiB0aGUgdmlld1xuICAgIC8vIGRlZmluaXRpb24gb3IgcGFzcyBhIGB0ZW1wbGF0ZTogXCJ3aGF0ZXZlclwiYCBwYXJhbWV0ZXIgaW5cbiAgICAvLyB0byB0aGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICBnZXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oJ3RlbXBsYXRlJyk7XG4gICAgfSxcbiAgXG4gICAgLy8gU2VyaWFsaXplIGEgbW9kZWwgYnkgcmV0dXJuaW5nIGl0cyBhdHRyaWJ1dGVzLiBDbG9uZXNcbiAgICAvLyB0aGUgYXR0cmlidXRlcyB0byBhbGxvdyBtb2RpZmljYXRpb24uXG4gICAgc2VyaWFsaXplTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKXtcbiAgICAgIHJldHVybiBtb2RlbC50b0pTT04uYXBwbHkobW9kZWwsIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgICB9LFxuICBcbiAgICAvLyBNaXggaW4gdGVtcGxhdGUgaGVscGVyIG1ldGhvZHMuIExvb2tzIGZvciBhXG4gICAgLy8gYHRlbXBsYXRlSGVscGVyc2AgYXR0cmlidXRlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGFuXG4gICAgLy8gb2JqZWN0IGxpdGVyYWwsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdFxuICAgIC8vIGxpdGVyYWwuIEFsbCBtZXRob2RzIGFuZCBhdHRyaWJ1dGVzIGZyb20gdGhpcyBvYmplY3RcbiAgICAvLyBhcmUgY29waWVzIHRvIHRoZSBvYmplY3QgcGFzc2VkIGluLlxuICAgIG1peGluVGVtcGxhdGVIZWxwZXJzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICAgIHZhciB0ZW1wbGF0ZUhlbHBlcnMgPSB0aGlzLmdldE9wdGlvbigndGVtcGxhdGVIZWxwZXJzJyk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRlbXBsYXRlSGVscGVycykpIHtcbiAgICAgICAgdGVtcGxhdGVIZWxwZXJzID0gdGVtcGxhdGVIZWxwZXJzLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXy5leHRlbmQodGFyZ2V0LCB0ZW1wbGF0ZUhlbHBlcnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIG5vcm1hbGl6ZSB0aGUga2V5cyBvZiBwYXNzZWQgaGFzaCB3aXRoIHRoZSB2aWV3cyBgdWlgIHNlbGVjdG9ycy5cbiAgICAvLyBge1wiQHVpLmZvb1wiOiBcImJhclwifWBcbiAgICBub3JtYWxpemVVSUtleXM6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIHZhciB1aUJpbmRpbmdzID0gXy5yZXN1bHQodGhpcywgJ191aUJpbmRpbmdzJyk7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXMoaGFzaCwgdWlCaW5kaW5ncyB8fCBfLnJlc3VsdCh0aGlzLCAndWknKSk7XG4gICAgfSxcbiAgXG4gICAgLy8gbm9ybWFsaXplIHRoZSB2YWx1ZXMgb2YgcGFzc2VkIGhhc2ggd2l0aCB0aGUgdmlld3MgYHVpYCBzZWxlY3RvcnMuXG4gICAgLy8gYHtmb286IFwiQHVpLmJhclwifWBcbiAgICBub3JtYWxpemVVSVZhbHVlczogZnVuY3Rpb24oaGFzaCkge1xuICAgICAgdmFyIHVpID0gXy5yZXN1bHQodGhpcywgJ3VpJyk7XG4gICAgICB2YXIgdWlCaW5kaW5ncyA9IF8ucmVzdWx0KHRoaXMsICdfdWlCaW5kaW5ncycpO1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUubm9ybWFsaXplVUlWYWx1ZXMoaGFzaCwgdWlCaW5kaW5ncyB8fCB1aSk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29uZmlndXJlIGB0cmlnZ2Vyc2AgdG8gZm9yd2FyZCBET00gZXZlbnRzIHRvIHZpZXdcbiAgICAvLyBldmVudHMuIGB0cmlnZ2Vyczoge1wiY2xpY2sgLmZvb1wiOiBcImRvOmZvb1wifWBcbiAgICBjb25maWd1cmVUcmlnZ2VyczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudHJpZ2dlcnMpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gQWxsb3cgYHRyaWdnZXJzYCB0byBiZSBjb25maWd1cmVkIGFzIGEgZnVuY3Rpb25cbiAgICAgIHZhciB0cmlnZ2VycyA9IHRoaXMubm9ybWFsaXplVUlLZXlzKF8ucmVzdWx0KHRoaXMsICd0cmlnZ2VycycpKTtcbiAgXG4gICAgICAvLyBDb25maWd1cmUgdGhlIHRyaWdnZXJzLCBwcmV2ZW50IGRlZmF1bHRcbiAgICAgIC8vIGFjdGlvbiBhbmQgc3RvcCBwcm9wYWdhdGlvbiBvZiBET00gZXZlbnRzXG4gICAgICByZXR1cm4gXy5yZWR1Y2UodHJpZ2dlcnMsIGZ1bmN0aW9uKGV2ZW50cywgdmFsdWUsIGtleSkge1xuICAgICAgICBldmVudHNba2V5XSA9IHRoaXMuX2J1aWxkVmlld1RyaWdnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgfSwge30sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRpbmcgQmFja2JvbmUuVmlldydzIGRlbGVnYXRlRXZlbnRzIHRvIGhhbmRsZVxuICAgIC8vIHRoZSBgdHJpZ2dlcnNgLCBgbW9kZWxFdmVudHNgLCBhbmQgYGNvbGxlY3Rpb25FdmVudHNgIGNvbmZpZ3VyYXRpb25cbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZURPTUV2ZW50cyhldmVudHMpO1xuICAgICAgdGhpcy5iaW5kRW50aXR5RXZlbnRzKHRoaXMubW9kZWwsIHRoaXMuZ2V0T3B0aW9uKCdtb2RlbEV2ZW50cycpKTtcbiAgICAgIHRoaXMuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIHRoaXMuZ2V0T3B0aW9uKCdjb2xsZWN0aW9uRXZlbnRzJykpO1xuICBcbiAgICAgIF8uZWFjaCh0aGlzLl9iZWhhdmlvcnMsIGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgIGJlaGF2aW9yLmJpbmRFbnRpdHlFdmVudHModGhpcy5tb2RlbCwgYmVoYXZpb3IuZ2V0T3B0aW9uKCdtb2RlbEV2ZW50cycpKTtcbiAgICAgICAgYmVoYXZpb3IuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIGJlaGF2aW9yLmdldE9wdGlvbignY29sbGVjdGlvbkV2ZW50cycpKTtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBkZWxlZ2F0ZSBET00gZXZlbnRzIGFuZCB0cmlnZ2Vyc1xuICAgIF9kZWxlZ2F0ZURPTUV2ZW50czogZnVuY3Rpb24oZXZlbnRzQXJnKSB7XG4gICAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXJnIHx8IHRoaXMuZXZlbnRzO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihldmVudHMpKSB7IGV2ZW50cyA9IGV2ZW50cy5jYWxsKHRoaXMpOyB9XG4gIFxuICAgICAgLy8gbm9ybWFsaXplIHVpIGtleXNcbiAgICAgIGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVUlLZXlzKGV2ZW50cyk7XG4gICAgICBpZihfLmlzVW5kZWZpbmVkKGV2ZW50c0FyZykpIHt0aGlzLmV2ZW50cyA9IGV2ZW50czt9XG4gIFxuICAgICAgdmFyIGNvbWJpbmVkRXZlbnRzID0ge307XG4gIFxuICAgICAgLy8gbG9vayB1cCBpZiB0aGlzIHZpZXcgaGFzIGJlaGF2aW9yIGV2ZW50c1xuICAgICAgdmFyIGJlaGF2aW9yRXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2JlaGF2aW9yRXZlbnRzJykgfHwge307XG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZ3VyZVRyaWdnZXJzKCk7XG4gICAgICB2YXIgYmVoYXZpb3JUcmlnZ2VycyA9IF8ucmVzdWx0KHRoaXMsICdiZWhhdmlvclRyaWdnZXJzJykgfHwge307XG4gIFxuICAgICAgLy8gYmVoYXZpb3IgZXZlbnRzIHdpbGwgYmUgb3ZlcnJpZGVuIGJ5IHZpZXcgZXZlbnRzIGFuZCBvciB0cmlnZ2Vyc1xuICAgICAgXy5leHRlbmQoY29tYmluZWRFdmVudHMsIGJlaGF2aW9yRXZlbnRzLCBldmVudHMsIHRyaWdnZXJzLCBiZWhhdmlvclRyaWdnZXJzKTtcbiAgXG4gICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5kZWxlZ2F0ZUV2ZW50cy5jYWxsKHRoaXMsIGNvbWJpbmVkRXZlbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBPdmVycmlkaW5nIEJhY2tib25lLlZpZXcncyB1bmRlbGVnYXRlRXZlbnRzIHRvIGhhbmRsZSB1bmJpbmRpbmdcbiAgICAvLyB0aGUgYHRyaWdnZXJzYCwgYG1vZGVsRXZlbnRzYCwgYW5kIGBjb2xsZWN0aW9uRXZlbnRzYCBjb25maWdcbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnVuZGVsZWdhdGVFdmVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLm1vZGVsLCB0aGlzLmdldE9wdGlvbignbW9kZWxFdmVudHMnKSk7XG4gICAgICB0aGlzLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIHRoaXMuZ2V0T3B0aW9uKCdjb2xsZWN0aW9uRXZlbnRzJykpO1xuICBcbiAgICAgIF8uZWFjaCh0aGlzLl9iZWhhdmlvcnMsIGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgIGJlaGF2aW9yLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLm1vZGVsLCBiZWhhdmlvci5nZXRPcHRpb24oJ21vZGVsRXZlbnRzJykpO1xuICAgICAgICBiZWhhdmlvci51bmJpbmRFbnRpdHlFdmVudHModGhpcy5jb2xsZWN0aW9uLCBiZWhhdmlvci5nZXRPcHRpb24oJ2NvbGxlY3Rpb25FdmVudHMnKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QsIGhhbmRsZXMgdGhlIGBzaG93YCBldmVudC5cbiAgICBvblNob3dDYWxsZWQ6IGZ1bmN0aW9uKCkge30sXG4gIFxuICAgIC8vIEludGVybmFsIGhlbHBlciBtZXRob2QgdG8gdmVyaWZ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzbid0IGJlZW4gZGVzdHJveWVkXG4gICAgX2Vuc3VyZVZpZXdJc0ludGFjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdEZXN0cm95ZWRFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ1ZpZXcgKGNpZDogXCInICsgdGhpcy5jaWQgKyAnXCIpIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIERlZmF1bHQgYGRlc3Ryb3lgIGltcGxlbWVudGF0aW9uLCBmb3IgcmVtb3ZpbmcgYSB2aWV3IGZyb20gdGhlXG4gICAgLy8gRE9NIGFuZCB1bmJpbmRpbmcgaXQuIFJlZ2lvbnMgd2lsbCBjYWxsIHRoaXMgbWV0aG9kXG4gICAgLy8gZm9yIHlvdS4gWW91IGNhbiBzcGVjaWZ5IGFuIGBvbkRlc3Ryb3lgIG1ldGhvZCBpbiB5b3VyIHZpZXcgdG9cbiAgICAvLyBhZGQgY3VzdG9tIGNvZGUgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHZpZXcgaXMgZGVzdHJveWVkLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QuYXBwbHkodGhpcywgWydiZWZvcmU6ZGVzdHJveSddLmNvbmNhdChhcmdzKSk7XG4gIFxuICAgICAgLy8gbWFyayBhcyBkZXN0cm95ZWQgYmVmb3JlIGRvaW5nIHRoZSBhY3R1YWwgZGVzdHJveSwgdG9cbiAgICAgIC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgd2l0aGluIFwiZGVzdHJveVwiIGV2ZW50IGhhbmRsZXJzXG4gICAgICAvLyB0aGF0IGFyZSB0cnlpbmcgdG8gZGVzdHJveSBvdGhlciB2aWV3c1xuICAgICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QuYXBwbHkodGhpcywgWydkZXN0cm95J10uY29uY2F0KGFyZ3MpKTtcbiAgXG4gICAgICAvLyB1bmJpbmQgVUkgZWxlbWVudHNcbiAgICAgIHRoaXMudW5iaW5kVUlFbGVtZW50cygpO1xuICBcbiAgICAgIC8vIHJlbW92ZSB0aGUgdmlldyBmcm9tIHRoZSBET01cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gIFxuICAgICAgLy8gQ2FsbCBkZXN0cm95IG9uIGVhY2ggYmVoYXZpb3IgYWZ0ZXJcbiAgICAgIC8vIGRlc3Ryb3lpbmcgdGhlIHZpZXcuXG4gICAgICAvLyBUaGlzIHVuYmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAvLyB0aGF0IGJlaGF2aW9ycyBoYXZlIHJlZ2lzdGVyZWQgZm9yLlxuICAgICAgXy5pbnZva2UodGhpcy5fYmVoYXZpb3JzLCAnZGVzdHJveScsIGFyZ3MpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIGJpbmRVSUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2JpbmRVSUVsZW1lbnRzKCk7XG4gICAgICBfLmludm9rZSh0aGlzLl9iZWhhdmlvcnMsIHRoaXMuX2JpbmRVSUVsZW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgZWxlbWVudHMgc3BlY2lmaWVkIGluIHRoZSBcInVpXCIgaGFzaCBpbnNpZGUgdGhlIHZpZXcncyBjb2RlIHdpdGhcbiAgICAvLyB0aGUgYXNzb2NpYXRlZCBqUXVlcnkgc2VsZWN0b3JzLlxuICAgIF9iaW5kVUlFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudWkpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gc3RvcmUgdGhlIHVpIGhhc2ggaW4gX3VpQmluZGluZ3Mgc28gdGhleSBjYW4gYmUgcmVzZXQgbGF0ZXJcbiAgICAgIC8vIGFuZCBzbyByZS1yZW5kZXJpbmcgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIGZpbmQgdGhlIGJpbmRpbmdzXG4gICAgICBpZiAoIXRoaXMuX3VpQmluZGluZ3MpIHtcbiAgICAgICAgdGhpcy5fdWlCaW5kaW5ncyA9IHRoaXMudWk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBiaW5kaW5ncyByZXN1bHQsIGFzIGEgZnVuY3Rpb24gb3Igb3RoZXJ3aXNlXG4gICAgICB2YXIgYmluZGluZ3MgPSBfLnJlc3VsdCh0aGlzLCAnX3VpQmluZGluZ3MnKTtcbiAgXG4gICAgICAvLyBlbXB0eSB0aGUgdWkgc28gd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzdGFydCB3aXRoXG4gICAgICB0aGlzLnVpID0ge307XG4gIFxuICAgICAgLy8gYmluZCBlYWNoIG9mIHRoZSBzZWxlY3RvcnNcbiAgICAgIF8uZWFjaChfLmtleXMoYmluZGluZ3MpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gYmluZGluZ3Nba2V5XTtcbiAgICAgICAgdGhpcy51aVtrZXldID0gdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFRoaXMgbWV0aG9kIHVuYmluZHMgdGhlIGVsZW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgXCJ1aVwiIGhhc2hcbiAgICB1bmJpbmRVSUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3VuYmluZFVJRWxlbWVudHMoKTtcbiAgICAgIF8uaW52b2tlKHRoaXMuX2JlaGF2aW9ycywgdGhpcy5fdW5iaW5kVUlFbGVtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgX3VuYmluZFVJRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnVpIHx8ICF0aGlzLl91aUJpbmRpbmdzKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIGRlbGV0ZSBhbGwgb2YgdGhlIGV4aXN0aW5nIHVpIGJpbmRpbmdzXG4gICAgICBfLmVhY2godGhpcy51aSwgZnVuY3Rpb24oJGVsLCBuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVpW25hbWVdO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgLy8gcmVzZXQgdGhlIHVpIGVsZW1lbnQgdG8gdGhlIG9yaWdpbmFsIGJpbmRpbmdzIGNvbmZpZ3VyYXRpb25cbiAgICAgIHRoaXMudWkgPSB0aGlzLl91aUJpbmRpbmdzO1xuICAgICAgZGVsZXRlIHRoaXMuX3VpQmluZGluZ3M7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdpdmVuIGB0cmlnZ2VyRGVmYCBsaWtlXG4gICAgLy8gJ2NsaWNrOmZvbydcbiAgICBfYnVpbGRWaWV3VHJpZ2dlcjogZnVuY3Rpb24odHJpZ2dlckRlZikge1xuICAgICAgdmFyIGhhc09wdGlvbnMgPSBfLmlzT2JqZWN0KHRyaWdnZXJEZWYpO1xuICBcbiAgICAgIHZhciBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgKGhhc09wdGlvbnMgPyB0cmlnZ2VyRGVmIDoge30pLCB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IHRydWVcbiAgICAgIH0pO1xuICBcbiAgICAgIHZhciBldmVudE5hbWUgPSBoYXNPcHRpb25zID8gb3B0aW9ucy5ldmVudCA6IHRyaWdnZXJEZWY7XG4gIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCAmJiBvcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24gJiYgb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICB2aWV3OiB0aGlzLFxuICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMuY29sbGVjdGlvblxuICAgICAgICB9O1xuICBcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKGV2ZW50TmFtZSwgYXJncyk7XG4gICAgICB9O1xuICAgIH0sXG4gIFxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJldCA9IEJhY2tib25lLlZpZXcucHJvdG90eXBlLnNldEVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICAvLyBwcm94eSBiZWhhdmlvciAkZWwgdG8gdGhlIHZpZXcncyAkZWwuXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGEgdmlldydzICRlbCBwcm94eVxuICAgICAgLy8gaXMgbm90IHNldCB1bnRpbCBhZnRlciBzZXRFbGVtZW50IGlzIGNhbGxlZC5cbiAgICAgIF8uaW52b2tlKHRoaXMuX2JlaGF2aW9ycywgJ3Byb3h5Vmlld1Byb3BlcnRpZXMnLCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gIFxuICAgIC8vIGltcG9ydCB0aGUgYHRyaWdnZXJNZXRob2RgIHRvIHRyaWdnZXIgZXZlbnRzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgIC8vIG1ldGhvZHMgaWYgdGhlIG1ldGhvZCBleGlzdHNcbiAgICB0cmlnZ2VyTWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmlnZ2VyTWV0aG9kID0gTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZDtcbiAgICAgIHZhciByZXQgPSB0cmlnZ2VyTWV0aG9kKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYmVoYXZpb3JzID0gdGhpcy5fYmVoYXZpb3JzO1xuICAgICAgLy8gVXNlIGdvb2Qgb2wnIGZvciBhcyB0aGlzIGlzIGEgdmVyeSBob3QgZnVuY3Rpb25cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiZWhhdmlvcnMgJiYgYmVoYXZpb3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyaWdnZXJNZXRob2QoYmVoYXZpb3JzW2ldLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhbnkgdmlld3MgdGhhdCBhcmUgaW1tZWRpYXRlXG4gICAgLy8gY2hpbGRyZW4gb2YgdGhpcyB2aWV3XG4gICAgX2dldEltbWVkaWF0ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICBcbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGV2ZXJ5IG5lc3RlZCB2aWV3IHdpdGhpbiB0aGlzIHZpZXdcbiAgICBfZ2V0TmVzdGVkVmlld3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fZ2V0SW1tZWRpYXRlQ2hpbGRyZW4oKTtcbiAgXG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkgeyByZXR1cm4gY2hpbGRyZW47IH1cbiAgXG4gICAgICByZXR1cm4gXy5yZWR1Y2UoY2hpbGRyZW4sIGZ1bmN0aW9uKG1lbW8sIHZpZXcpIHtcbiAgICAgICAgaWYgKCF2aWV3Ll9nZXROZXN0ZWRWaWV3cykgeyByZXR1cm4gbWVtbzsgfVxuICAgICAgICByZXR1cm4gbWVtby5jb25jYXQodmlldy5fZ2V0TmVzdGVkVmlld3MoKSk7XG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfSxcbiAgXG4gICAgLy8gSW1wb3J0cyB0aGUgXCJub3JtYWxpemVNZXRob2RzXCIgdG8gdHJhbnNmb3JtIGhhc2hlcyBvZlxuICAgIC8vIGV2ZW50cz0+ZnVuY3Rpb24gcmVmZXJlbmNlcy9uYW1lcyB0byBhIGhhc2ggb2YgZXZlbnRzPT5mdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgbm9ybWFsaXplTWV0aG9kczogTWFyaW9uZXR0ZS5ub3JtYWxpemVNZXRob2RzLFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24sXG4gIFxuICAgIC8vIFByb3h5IGBiaW5kRW50aXR5RXZlbnRzYCB0byBlbmFibGUgYmluZGluZyB2aWV3J3MgZXZlbnRzIGZyb20gYW5vdGhlciBlbnRpdHkuXG4gICAgYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eUJpbmRFbnRpdHlFdmVudHMsXG4gIFxuICAgIC8vIFByb3h5IGB1bmJpbmRFbnRpdHlFdmVudHNgIHRvIGVuYWJsZSB1bmJpbmRpbmcgdmlldydzIGV2ZW50cyBmcm9tIGFub3RoZXIgZW50aXR5LlxuICAgIHVuYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eVVuYmluZEVudGl0eUV2ZW50c1xuICB9KTtcbiAgXG4gIC8vIEl0ZW0gVmlld1xuICAvLyAtLS0tLS0tLS1cbiAgXG4gIC8vIEEgc2luZ2xlIGl0ZW0gdmlldyBpbXBsZW1lbnRhdGlvbiB0aGF0IGNvbnRhaW5zIGNvZGUgZm9yIHJlbmRlcmluZ1xuICAvLyB3aXRoIHVuZGVyc2NvcmUuanMgdGVtcGxhdGVzLCBzZXJpYWxpemluZyB0aGUgdmlldydzIG1vZGVsIG9yIGNvbGxlY3Rpb24sXG4gIC8vIGFuZCBjYWxsaW5nIHNldmVyYWwgbWV0aG9kcyBvbiBleHRlbmRlZCB2aWV3cywgc3VjaCBhcyBgb25SZW5kZXJgLlxuICBNYXJpb25ldHRlLkl0ZW1WaWV3ID0gTWFyaW9uZXR0ZS5WaWV3LmV4dGVuZCh7XG4gIFxuICAgIC8vIFNldHRpbmcgdXAgdGhlIGluaGVyaXRhbmNlIGNoYWluIHdoaWNoIGFsbG93cyBjaGFuZ2VzIHRvXG4gICAgLy8gTWFyaW9uZXR0ZS5WaWV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvciB3aGljaCBhbGxvd3Mgb3ZlcnJpZGluZ1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIE1hcmlvbmV0dGUuVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFNlcmlhbGl6ZSB0aGUgbW9kZWwgb3IgY29sbGVjdGlvbiBmb3IgdGhlIHZpZXcuIElmIGEgbW9kZWwgaXNcbiAgICAvLyBmb3VuZCwgdGhlIHZpZXcncyBgc2VyaWFsaXplTW9kZWxgIGlzIGNhbGxlZC4gSWYgYSBjb2xsZWN0aW9uIGlzIGZvdW5kLFxuICAgIC8vIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24gaXMgc2VyaWFsaXplZCBieSBjYWxsaW5nXG4gICAgLy8gdGhlIHZpZXcncyBgc2VyaWFsaXplQ29sbGVjdGlvbmAgYW5kIHB1dCBpbnRvIGFuIGBpdGVtc2AgYXJyYXkgaW5cbiAgICAvLyB0aGUgcmVzdWx0aW5nIGRhdGEuIElmIGJvdGggYXJlIGZvdW5kLCBkZWZhdWx0cyB0byB0aGUgbW9kZWwuXG4gICAgLy8gWW91IGNhbiBvdmVycmlkZSB0aGUgYHNlcmlhbGl6ZURhdGFgIG1ldGhvZCBpbiB5b3VyIG93biB2aWV3IGRlZmluaXRpb24sXG4gICAgLy8gdG8gcHJvdmlkZSBjdXN0b20gc2VyaWFsaXphdGlvbiBmb3IgeW91ciB2aWV3J3MgZGF0YS5cbiAgICBzZXJpYWxpemVEYXRhOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKCF0aGlzLm1vZGVsICYmICF0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICBcbiAgICAgIHZhciBhcmdzID0gW3RoaXMubW9kZWwgfHwgdGhpcy5jb2xsZWN0aW9uXTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICBcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZU1vZGVsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtczogdGhpcy5zZXJpYWxpemVDb2xsZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gU2VyaWFsaXplIGEgY29sbGVjdGlvbiBieSBzZXJpYWxpemluZyBlYWNoIG9mIGl0cyBtb2RlbHMuXG4gICAgc2VyaWFsaXplQ29sbGVjdGlvbjogZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi50b0pTT04uYXBwbHkoY29sbGVjdGlvbiwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB0aGUgdmlldywgZGVmYXVsdGluZyB0byB1bmRlcnNjb3JlLmpzIHRlbXBsYXRlcy5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgaW4geW91ciB2aWV3IGRlZmluaXRpb24gdG8gcHJvdmlkZVxuICAgIC8vIGEgdmVyeSBzcGVjaWZpYyByZW5kZXJpbmcgZm9yIHlvdXIgdmlldy4gSW4gZ2VuZXJhbCwgdGhvdWdoLFxuICAgIC8vIHlvdSBzaG91bGQgb3ZlcnJpZGUgdGhlIGBNYXJpb25ldHRlLlJlbmRlcmVyYCBvYmplY3QgdG9cbiAgICAvLyBjaGFuZ2UgaG93IE1hcmlvbmV0dGUgcmVuZGVycyB2aWV3cy5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZW5zdXJlVmlld0lzSW50YWN0KCk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyJywgdGhpcyk7XG4gIFxuICAgICAgdGhpcy5fcmVuZGVyVGVtcGxhdGUoKTtcbiAgICAgIHRoaXMuYmluZFVJRWxlbWVudHMoKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcicsIHRoaXMpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byByZW5kZXIgdGhlIHRlbXBsYXRlIHdpdGggdGhlIHNlcmlhbGl6ZWQgZGF0YVxuICAgIC8vIGFuZCB0ZW1wbGF0ZSBoZWxwZXJzIHZpYSB0aGUgYE1hcmlvbmV0dGUuUmVuZGVyZXJgIG9iamVjdC5cbiAgICAvLyBUaHJvd3MgYW4gYFVuZGVmaW5lZFRlbXBsYXRlRXJyb3JgIGVycm9yIGlmIHRoZSB0ZW1wbGF0ZSBpc1xuICAgIC8vIGFueSBmYWxzZWx5IHZhbHVlIGJ1dCBsaXRlcmFsIGBmYWxzZWAuXG4gICAgX3JlbmRlclRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuZ2V0VGVtcGxhdGUoKTtcbiAgXG4gICAgICAvLyBBbGxvdyB0ZW1wbGF0ZS1sZXNzIGl0ZW0gdmlld3NcbiAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdVbmRlZmluZWRUZW1wbGF0ZUVycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IHJlbmRlciB0aGUgdGVtcGxhdGUgc2luY2UgaXQgaXMgbnVsbCBvciB1bmRlZmluZWQuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBBZGQgaW4gZW50aXR5IGRhdGEgYW5kIHRlbXBsYXRlIGhlbHBlcnNcbiAgICAgIHZhciBkYXRhID0gdGhpcy5zZXJpYWxpemVEYXRhKCk7XG4gICAgICBkYXRhID0gdGhpcy5taXhpblRlbXBsYXRlSGVscGVycyhkYXRhKTtcbiAgXG4gICAgICAvLyBSZW5kZXIgYW5kIGFkZCB0byBlbFxuICAgICAgdmFyIGh0bWwgPSBNYXJpb25ldHRlLlJlbmRlcmVyLnJlbmRlcih0ZW1wbGF0ZSwgZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLmF0dGFjaEVsQ29udGVudChodG1sKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBBdHRhY2hlcyB0aGUgY29udGVudCBvZiBhIGdpdmVuIHZpZXcuXG4gICAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gb3B0aW1pemUgcmVuZGVyaW5nLFxuICAgIC8vIG9yIHRvIHJlbmRlciBpbiBhIG5vbiBzdGFuZGFyZCB3YXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgdXNpbmcgYGlubmVySFRNTGAgaW5zdGVhZCBvZiBgJGVsLmh0bWxgXG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgIC8vICAgdGhpcy5lbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIC8vICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8vIGBgYFxuICAgIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdGhpcy4kZWwuaHRtbChodG1sKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDE0ICovXG4gIFxuICAvLyBDb2xsZWN0aW9uIFZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBBIHZpZXcgdGhhdCBpdGVyYXRlcyBvdmVyIGEgQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyBhbmQgcmVuZGVycyBhbiBpbmRpdmlkdWFsIGNoaWxkIHZpZXcgZm9yIGVhY2ggbW9kZWwuXG4gIE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcgPSBNYXJpb25ldHRlLlZpZXcuZXh0ZW5kKHtcbiAgXG4gICAgLy8gdXNlZCBhcyB0aGUgcHJlZml4IGZvciBjaGlsZCB2aWV3IGV2ZW50c1xuICAgIC8vIHRoYXQgYXJlIGZvcndhcmRlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aW9udmlld1xuICAgIGNoaWxkVmlld0V2ZW50UHJlZml4OiAnY2hpbGR2aWV3JyxcbiAgXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvLyBvcHRpb24gdG8gcGFzcyBge3NvcnQ6IGZhbHNlfWAgdG8gcHJldmVudCB0aGUgYENvbGxlY3Rpb25WaWV3YCBmcm9tXG4gICAgLy8gbWFpbnRhaW5pbmcgdGhlIHNvcnRlZCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAvLyBUaGlzIHdpbGwgZmFsbGJhY2sgb250byBhcHBlbmRpbmcgY2hpbGRWaWV3J3MgdG8gdGhlIGVuZC5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICB2YXIgaW5pdE9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5zb3J0KSl7XG4gICAgICAgIHRoaXMuc29ydCA9IF8uaXNVbmRlZmluZWQoaW5pdE9wdGlvbnMuc29ydCkgPyB0cnVlIDogaW5pdE9wdGlvbnMuc29ydDtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLm9uY2UoJ3JlbmRlcicsIHRoaXMuX2luaXRpYWxFdmVudHMpO1xuICAgICAgdGhpcy5faW5pdENoaWxkVmlld1N0b3JhZ2UoKTtcbiAgXG4gICAgICBNYXJpb25ldHRlLlZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLmluaXRSZW5kZXJCdWZmZXIoKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnN0ZWFkIG9mIGluc2VydGluZyBlbGVtZW50cyBvbmUgYnkgb25lIGludG8gdGhlIHBhZ2UsXG4gICAgLy8gaXQncyBtdWNoIG1vcmUgcGVyZm9ybWFudCB0byBpbnNlcnQgZWxlbWVudHMgaW50byBhIGRvY3VtZW50XG4gICAgLy8gZnJhZ21lbnQgYW5kIHRoZW4gaW5zZXJ0IHRoYXQgZG9jdW1lbnQgZnJhZ21lbnQgaW50byB0aGUgcGFnZVxuICAgIGluaXRSZW5kZXJCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbEJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQ2hpbGRyZW4gPSBbXTtcbiAgICB9LFxuICBcbiAgICBzdGFydEJ1ZmZlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRSZW5kZXJCdWZmZXIoKTtcbiAgICAgIHRoaXMuaXNCdWZmZXJpbmcgPSB0cnVlO1xuICAgIH0sXG4gIFxuICAgIGVuZEJ1ZmZlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzQnVmZmVyaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90cmlnZ2VyQmVmb3JlU2hvd0J1ZmZlcmVkQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuYXR0YWNoQnVmZmVyKHRoaXMsIHRoaXMuZWxCdWZmZXIpO1xuICAgICAgdGhpcy5fdHJpZ2dlclNob3dCdWZmZXJlZENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmluaXRSZW5kZXJCdWZmZXIoKTtcbiAgICB9LFxuICBcbiAgICBfdHJpZ2dlckJlZm9yZVNob3dCdWZmZXJlZENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLl9idWZmZXJlZENoaWxkcmVuLCBfLnBhcnRpYWwodGhpcy5fdHJpZ2dlck1ldGhvZE9uQ2hpbGQsICdiZWZvcmU6c2hvdycpKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICBfdHJpZ2dlclNob3dCdWZmZXJlZENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLl9idWZmZXJlZENoaWxkcmVuLCBfLnBhcnRpYWwodGhpcy5fdHJpZ2dlck1ldGhvZE9uQ2hpbGQsICdzaG93JykpO1xuICBcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRDaGlsZHJlbiA9IFtdO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCBmb3IgXy5lYWNoIGxvb3BzIHRvIGNhbGwgYE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uYCBvblxuICAgIC8vIGEgY2hpbGQgdmlld1xuICAgIF90cmlnZ2VyTWV0aG9kT25DaGlsZDogZnVuY3Rpb24oZXZlbnQsIGNoaWxkVmlldykge1xuICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24oY2hpbGRWaWV3LCBldmVudCk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29uZmlndXJlZCB0aGUgaW5pdGlhbCBldmVudHMgdGhhdCB0aGUgY29sbGVjdGlvbiB2aWV3XG4gICAgLy8gYmluZHMgdG8uXG4gICAgX2luaXRpYWxFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2FkZCcsIHRoaXMuX29uQ29sbGVjdGlvbkFkZCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAncmVtb3ZlJywgdGhpcy5fb25Db2xsZWN0aW9uUmVtb3ZlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdyZXNldCcsIHRoaXMucmVuZGVyKTtcbiAgXG4gICAgICAgIGlmICh0aGlzLnNvcnQpIHtcbiAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3NvcnQnLCB0aGlzLl9zb3J0Vmlld3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSGFuZGxlIGEgY2hpbGQgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICBfb25Db2xsZWN0aW9uQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdGhpcy5kZXN0cm95RW1wdHlWaWV3KCk7XG4gICAgICB2YXIgQ2hpbGRWaWV3ID0gdGhpcy5nZXRDaGlsZFZpZXcoY2hpbGQpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb2xsZWN0aW9uLmluZGV4T2YoY2hpbGQpO1xuICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCwgQ2hpbGRWaWV3LCBpbmRleCk7XG4gICAgfSxcbiAgXG4gICAgLy8gZ2V0IHRoZSBjaGlsZCB2aWV3IGJ5IG1vZGVsIGl0IGhvbGRzLCBhbmQgcmVtb3ZlIGl0XG4gICAgX29uQ29sbGVjdGlvblJlbW92ZTogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jaGlsZHJlbi5maW5kQnlNb2RlbChtb2RlbCk7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkVmlldyh2aWV3KTtcbiAgICAgIHRoaXMuY2hlY2tFbXB0eSgpO1xuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRlIGZyb20gYE1hcmlvbmV0dGUuVmlld2AgdG8gdHJpZ2dlciBzaG93IG9uIGNoaWxkIHZpZXdzXG4gICAgb25TaG93Q2FsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChfLnBhcnRpYWwodGhpcy5fdHJpZ2dlck1ldGhvZE9uQ2hpbGQsICdzaG93JykpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciBjaGlsZHJlbiB2aWV3cy4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG9cbiAgICAvLyBwcm92aWRlIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIG9mIGEgcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyJywgdGhpcyk7XG4gICAgICB0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXInLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB2aWV3IGFmdGVyIHNvcnRpbmcuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvXG4gICAgLy8gY2hhbmdlIGhvdyB0aGUgdmlldyByZW5kZXJzIGFmdGVyIGEgYHNvcnRgIG9uIHRoZSBjb2xsZWN0aW9uLlxuICAgIC8vIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSB0byBvbmx5IGByZW5kZXJDaGlsZHJlbmAgaW4gYSBgQ29tcG9zaXRlVmlld2BcbiAgICAvLyByYXRoZXIgdGhhbiB0aGUgZnVsbCB2aWV3LlxuICAgIHJlc29ydFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIFRoaXMgY2hlY2tzIGZvciBhbnkgY2hhbmdlcyBpbiB0aGUgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgLy8gSWYgdGhlIGluZGV4IG9mIGFueSB2aWV3IGRvZXNuJ3QgbWF0Y2gsIGl0IHdpbGwgcmVuZGVyLlxuICAgIF9zb3J0Vmlld3M6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY2hlY2sgZm9yIGFueSBjaGFuZ2VzIGluIHNvcnQgb3JkZXIgb2Ygdmlld3NcbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSB0aGlzLmNvbGxlY3Rpb24uZmluZChmdW5jdGlvbihpdGVtLCBpbmRleCl7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5jaGlsZHJlbi5maW5kQnlNb2RlbChpdGVtKTtcbiAgICAgICAgcmV0dXJuICF2aWV3IHx8IHZpZXcuX2luZGV4ICE9PSBpbmRleDtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIGlmIChvcmRlckNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZXNvcnRWaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHdoYXQgaW5kZXggYSBgZW1wdHlWaWV3YCBpcy5cbiAgICBfZW1wdHlWaWV3SW5kZXg6IC0xLFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIFNlcGFyYXRlZCBzbyB0aGF0IENvbXBvc2l0ZVZpZXcgY2FuIGhhdmVcbiAgICAvLyBtb3JlIGNvbnRyb2wgb3ZlciBldmVudHMgYmVpbmcgdHJpZ2dlcmVkLCBhcm91bmQgdGhlIHJlbmRlcmluZ1xuICAgIC8vIHByb2Nlc3NcbiAgICBfcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95RW1wdHlWaWV3KCk7XG4gICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbigpO1xuICBcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkodGhpcy5jb2xsZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnNob3dFbXB0eVZpZXcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcjpjb2xsZWN0aW9uJywgdGhpcyk7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmcoKTtcbiAgICAgICAgdGhpcy5zaG93Q29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmVuZEJ1ZmZlcmluZygpO1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcjpjb2xsZWN0aW9uJywgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGxvb3AgdGhyb3VnaCBjb2xsZWN0aW9uIGFuZCBzaG93IGVhY2ggY2hpbGQgdmlldy5cbiAgICBzaG93Q29sbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgQ2hpbGRWaWV3O1xuICAgICAgdGhpcy5jb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIENoaWxkVmlldyA9IHRoaXMuZ2V0Q2hpbGRWaWV3KGNoaWxkKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCwgQ2hpbGRWaWV3LCBpbmRleCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2hvdyBhbiBlbXB0eSB2aWV3IGluIHBsYWNlIG9mXG4gICAgLy8gYSBjb2xsZWN0aW9uIG9mIGNoaWxkIHZpZXdzLCB3aGVuIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAgc2hvd0VtcHR5VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgRW1wdHlWaWV3ID0gdGhpcy5nZXRFbXB0eVZpZXcoKTtcbiAgXG4gICAgICBpZiAoRW1wdHlWaWV3ICYmICF0aGlzLl9zaG93aW5nRW1wdHlWaWV3KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcjplbXB0eScpO1xuICBcbiAgICAgICAgdGhpcy5fc2hvd2luZ0VtcHR5VmlldyA9IHRydWU7XG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBCYWNrYm9uZS5Nb2RlbCgpO1xuICAgICAgICB0aGlzLmFkZEVtcHR5Vmlldyhtb2RlbCwgRW1wdHlWaWV3KTtcbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVuZGVyOmVtcHR5Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGRlc3Ryb3kgYW4gZXhpc3RpbmcgZW1wdHlWaWV3IGluc3RhbmNlXG4gICAgLy8gaWYgb25lIGV4aXN0cy4gQ2FsbGVkIHdoZW4gYSBjb2xsZWN0aW9uIHZpZXcgaGFzIGJlZW5cbiAgICAvLyByZW5kZXJlZCBlbXB0eSwgYW5kIHRoZW4gYSBjaGlsZCBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBkZXN0cm95RW1wdHlWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9zaG93aW5nRW1wdHlWaWV3KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbW92ZTplbXB0eScpO1xuICBcbiAgICAgICAgdGhpcy5kZXN0cm95Q2hpbGRyZW4oKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3dpbmdFbXB0eVZpZXc7XG4gIFxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbW92ZTplbXB0eScpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFJldHJpZXZlIHRoZSBlbXB0eSB2aWV3IGNsYXNzXG4gICAgZ2V0RW1wdHlWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbignZW1wdHlWaWV3Jyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVuZGVyIGFuZCBzaG93IHRoZSBlbXB0eVZpZXcuIFNpbWlsYXIgdG8gYWRkQ2hpbGQgbWV0aG9kXG4gICAgLy8gYnV0IFwiY2hpbGQ6YWRkZWRcIiBldmVudHMgYXJlIG5vdCBmaXJlZCwgYW5kIHRoZSBldmVudCBmcm9tXG4gICAgLy8gZW1wdHlWaWV3IGFyZSBub3QgZm9yd2FyZGVkXG4gICAgYWRkRW1wdHlWaWV3OiBmdW5jdGlvbihjaGlsZCwgRW1wdHlWaWV3KSB7XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBlbXB0eVZpZXdPcHRpb25zLCBmYWxsaW5nIGJhY2sgdG8gY2hpbGRWaWV3T3B0aW9uc1xuICAgICAgdmFyIGVtcHR5Vmlld09wdGlvbnMgPSB0aGlzLmdldE9wdGlvbignZW1wdHlWaWV3T3B0aW9ucycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlld09wdGlvbnMnKTtcbiAgXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGVtcHR5Vmlld09wdGlvbnMpKXtcbiAgICAgICAgZW1wdHlWaWV3T3B0aW9ucyA9IGVtcHR5Vmlld09wdGlvbnMuY2FsbCh0aGlzLCBjaGlsZCwgdGhpcy5fZW1wdHlWaWV3SW5kZXgpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGJ1aWxkIHRoZSBlbXB0eSB2aWV3XG4gICAgICB2YXIgdmlldyA9IHRoaXMuYnVpbGRDaGlsZFZpZXcoY2hpbGQsIEVtcHR5VmlldywgZW1wdHlWaWV3T3B0aW9ucyk7XG4gIFxuICAgICAgdmlldy5fcGFyZW50ID0gdGhpcztcbiAgXG4gICAgICAvLyBQcm94eSBlbXB0eVZpZXcgZXZlbnRzXG4gICAgICB0aGlzLnByb3h5Q2hpbGRFdmVudHModmlldyk7XG4gIFxuICAgICAgLy8gdHJpZ2dlciB0aGUgJ2JlZm9yZTpzaG93JyBldmVudCBvbiBgdmlld2AgaWYgdGhlIGNvbGxlY3Rpb24gdmlld1xuICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzaG93blxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ2JlZm9yZTpzaG93Jyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU3RvcmUgdGhlIGBlbXB0eVZpZXdgIGxpa2UgYSBgY2hpbGRWaWV3YCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAgIC8vIHJlbW92ZSBhbmQvb3IgY2xvc2UgaXQgbGF0ZXJcbiAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKHZpZXcpO1xuICBcbiAgICAgIC8vIFJlbmRlciBpdCBhbmQgc2hvdyBpdFxuICAgICAgdGhpcy5yZW5kZXJDaGlsZFZpZXcodmlldywgdGhpcy5fZW1wdHlWaWV3SW5kZXgpO1xuICBcbiAgICAgIC8vIGNhbGwgdGhlICdzaG93JyBtZXRob2QgaWYgdGhlIGNvbGxlY3Rpb24gdmlld1xuICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzaG93blxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ3Nob3cnKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZXRyaWV2ZSB0aGUgYGNoaWxkVmlld2AgY2xhc3MsIGVpdGhlciBmcm9tIGB0aGlzLm9wdGlvbnMuY2hpbGRWaWV3YFxuICAgIC8vIG9yIGZyb20gdGhlIGBjaGlsZFZpZXdgIGluIHRoZSBvYmplY3QgZGVmaW5pdGlvbi4gVGhlIFwib3B0aW9uc1wiXG4gICAgLy8gdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAvLyBUaGlzIG1ldGhvZCByZWNlaXZlcyB0aGUgbW9kZWwgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgaW5zdGFuY2VcbiAgICAvLyBjcmVhdGVkIGZyb20gdGhpcyBgY2hpbGRWaWV3YC4gT3ZlcnJpZGluZyBtZXRob2RzIG1heSB1c2UgdGhlIGNoaWxkXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgYGNoaWxkVmlld2AgY2xhc3MgdG8gcmV0dXJuLlxuICAgIGdldENoaWxkVmlldzogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZFZpZXcgPSB0aGlzLmdldE9wdGlvbignY2hpbGRWaWV3Jyk7XG4gIFxuICAgICAgaWYgKCFjaGlsZFZpZXcpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdOb0NoaWxkVmlld0Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQSBcImNoaWxkVmlld1wiIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gY2hpbGRWaWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB0aGUgY2hpbGQncyB2aWV3IGFuZCBhZGQgaXQgdG8gdGhlXG4gICAgLy8gSFRNTCBmb3IgdGhlIGNvbGxlY3Rpb24gdmlldyBhdCBhIGdpdmVuIGluZGV4LlxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgaW5kaWNlcyBvZiBsYXRlciB2aWV3cyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGNoaWxkcmVuIGluIHN5bmMgd2l0aCB0aGUgY29sbGVjdGlvbi5cbiAgICBhZGRDaGlsZDogZnVuY3Rpb24oY2hpbGQsIENoaWxkVmlldywgaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZFZpZXdPcHRpb25zID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlld09wdGlvbnMnKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY2hpbGRWaWV3T3B0aW9ucykpIHtcbiAgICAgICAgY2hpbGRWaWV3T3B0aW9ucyA9IGNoaWxkVmlld09wdGlvbnMuY2FsbCh0aGlzLCBjaGlsZCwgaW5kZXgpO1xuICAgICAgfVxuICBcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5idWlsZENoaWxkVmlldyhjaGlsZCwgQ2hpbGRWaWV3LCBjaGlsZFZpZXdPcHRpb25zKTtcbiAgXG4gICAgICAvLyBpbmNyZW1lbnQgaW5kaWNlcyBvZiB2aWV3cyBhZnRlciB0aGlzIG9uZVxuICAgICAgdGhpcy5fdXBkYXRlSW5kaWNlcyh2aWV3LCB0cnVlLCBpbmRleCk7XG4gIFxuICAgICAgdGhpcy5fYWRkQ2hpbGRWaWV3KHZpZXcsIGluZGV4KTtcbiAgXG4gICAgICB2aWV3Ll9wYXJlbnQgPSB0aGlzO1xuICBcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gVGhpcyBkZWNyZW1lbnRzIG9yIGluY3JlbWVudHMgdGhlIGluZGljZXMgb2Ygdmlld3MgYWZ0ZXIgdGhlXG4gICAgLy8gYWRkZWQvcmVtb3ZlZCB2aWV3IHRvIGtlZXAgaW4gc3luYyB3aXRoIHRoZSBjb2xsZWN0aW9uLlxuICAgIF91cGRhdGVJbmRpY2VzOiBmdW5jdGlvbih2aWV3LCBpbmNyZW1lbnQsIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc29ydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGluY3JlbWVudCkge1xuICAgICAgICAvLyBhc3NpZ24gdGhlIGluZGV4IHRvIHRoZSB2aWV3XG4gICAgICAgIHZpZXcuX2luZGV4ID0gaW5kZXg7XG4gIFxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGluZGV4IG9mIHZpZXdzIGFmdGVyIHRoaXMgb25lXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbiAobGF0ZXJWaWV3KSB7XG4gICAgICAgICAgaWYgKGxhdGVyVmlldy5faW5kZXggPj0gdmlldy5faW5kZXgpIHtcbiAgICAgICAgICAgIGxhdGVyVmlldy5faW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRlY3JlbWVudCB0aGUgaW5kZXggb2Ygdmlld3MgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uIChsYXRlclZpZXcpIHtcbiAgICAgICAgICBpZiAobGF0ZXJWaWV3Ll9pbmRleCA+PSB2aWV3Ll9pbmRleCkge1xuICAgICAgICAgICAgbGF0ZXJWaWV3Ll9pbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gIFxuICAgIC8vIEludGVybmFsIE1ldGhvZC4gQWRkIHRoZSB2aWV3IHRvIGNoaWxkcmVuIGFuZCByZW5kZXIgaXQgYXRcbiAgICAvLyB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgX2FkZENoaWxkVmlldzogZnVuY3Rpb24odmlldywgaW5kZXgpIHtcbiAgICAgIC8vIHNldCB1cCB0aGUgY2hpbGQgdmlldyBldmVudCBmb3J3YXJkaW5nXG4gICAgICB0aGlzLnByb3h5Q2hpbGRFdmVudHModmlldyk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6YWRkOmNoaWxkJywgdmlldyk7XG4gIFxuICAgICAgLy8gU3RvcmUgdGhlIGNoaWxkIHZpZXcgaXRzZWxmIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgICAgLy8gcmVtb3ZlIGFuZC9vciBkZXN0cm95IGl0IGxhdGVyXG4gICAgICB0aGlzLmNoaWxkcmVuLmFkZCh2aWV3KTtcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRWaWV3KHZpZXcsIGluZGV4KTtcbiAgXG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiAhdGhpcy5pc0J1ZmZlcmluZykge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCAnc2hvdycpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYWRkOmNoaWxkJywgdmlldyk7XG4gICAgfSxcbiAgXG4gICAgLy8gcmVuZGVyIHRoZSBjaGlsZCB2aWV3XG4gICAgcmVuZGVyQ2hpbGRWaWV3OiBmdW5jdGlvbih2aWV3LCBpbmRleCkge1xuICAgICAgdmlldy5yZW5kZXIoKTtcbiAgICAgIHRoaXMuYXR0YWNoSHRtbCh0aGlzLCB2aWV3LCBpbmRleCk7XG4gICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuICBcbiAgICAvLyBCdWlsZCBhIGBjaGlsZFZpZXdgIGZvciBhIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIGJ1aWxkQ2hpbGRWaWV3OiBmdW5jdGlvbihjaGlsZCwgQ2hpbGRWaWV3Q2xhc3MsIGNoaWxkVmlld09wdGlvbnMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gXy5leHRlbmQoe21vZGVsOiBjaGlsZH0sIGNoaWxkVmlld09wdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBDaGlsZFZpZXdDbGFzcyhvcHRpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgdGhlIGNoaWxkIHZpZXcgYW5kIGRlc3Ryb3kgaXQuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbHNvIHVwZGF0ZXMgdGhlIGluZGljZXMgb2ZcbiAgICAvLyBsYXRlciB2aWV3cyBpbiB0aGUgY29sbGVjdGlvbiBpbiBvcmRlciB0byBrZWVwXG4gICAgLy8gdGhlIGNoaWxkcmVuIGluIHN5bmMgd2l0aCB0aGUgY29sbGVjdGlvbi5cbiAgICByZW1vdmVDaGlsZFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgXG4gICAgICBpZiAodmlldykge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW1vdmU6Y2hpbGQnLCB2aWV3KTtcbiAgICAgICAgLy8gY2FsbCAnZGVzdHJveScgb3IgJ3JlbW92ZScsIGRlcGVuZGluZyBvbiB3aGljaCBpcyBmb3VuZFxuICAgICAgICBpZiAodmlldy5kZXN0cm95KSB7IHZpZXcuZGVzdHJveSgpOyB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcucmVtb3ZlKSB7IHZpZXcucmVtb3ZlKCk7IH1cbiAgXG4gICAgICAgIGRlbGV0ZSB2aWV3Ll9wYXJlbnQ7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZyh2aWV3KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZW1vdmUodmlldyk7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVtb3ZlOmNoaWxkJywgdmlldyk7XG4gIFxuICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGluZGV4IG9mIHZpZXdzIGFmdGVyIHRoaXMgb25lXG4gICAgICAgIHRoaXMuX3VwZGF0ZUluZGljZXModmlldywgZmFsc2UpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIGNoZWNrIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29sbGVjdGlvbiB8fCB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgIH0sXG4gIFxuICAgIC8vIElmIGVtcHR5LCBzaG93IHRoZSBlbXB0eSB2aWV3XG4gICAgY2hlY2tFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KHRoaXMuY29sbGVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5zaG93RW1wdHlWaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gWW91IG1pZ2h0IG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBpZiB5b3UndmUgb3ZlcnJpZGRlbiBhdHRhY2hIdG1sXG4gICAgYXR0YWNoQnVmZmVyOiBmdW5jdGlvbihjb2xsZWN0aW9uVmlldywgYnVmZmVyKSB7XG4gICAgICBjb2xsZWN0aW9uVmlldy4kZWwuYXBwZW5kKGJ1ZmZlcik7XG4gICAgfSxcbiAgXG4gICAgLy8gQXBwZW5kIHRoZSBIVE1MIHRvIHRoZSBjb2xsZWN0aW9uJ3MgYGVsYC5cbiAgICAvLyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkbyBzb21ldGhpbmcgb3RoZXJcbiAgICAvLyB0aGFuIGAuYXBwZW5kYC5cbiAgICBhdHRhY2hIdG1sOiBmdW5jdGlvbihjb2xsZWN0aW9uVmlldywgY2hpbGRWaWV3LCBpbmRleCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb25WaWV3LmlzQnVmZmVyaW5nKSB7XG4gICAgICAgIC8vIGJ1ZmZlcmluZyBoYXBwZW5zIG9uIHJlc2V0IGV2ZW50cyBhbmQgaW5pdGlhbCByZW5kZXJzXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGluc2VydHMgaW50byB0aGVcbiAgICAgICAgLy8gZG9jdW1lbnQsIHdoaWNoIGFyZSBleHBlbnNpdmUuXG4gICAgICAgIGNvbGxlY3Rpb25WaWV3LmVsQnVmZmVyLmFwcGVuZENoaWxkKGNoaWxkVmlldy5lbCk7XG4gICAgICAgIGNvbGxlY3Rpb25WaWV3Ll9idWZmZXJlZENoaWxkcmVuLnB1c2goY2hpbGRWaWV3KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkIHRoZSBtYWluIGNvbGxlY3Rpb24sIGFwcGVuZFxuICAgICAgICAvLyB0aGUgbmV3IGNoaWxkIGludG8gdGhlIGNvcnJlY3Qgb3JkZXIgaWYgd2UgbmVlZCB0by4gT3RoZXJ3aXNlXG4gICAgICAgIC8vIGFwcGVuZCB0byB0aGUgZW5kLlxuICAgICAgICBpZiAoIWNvbGxlY3Rpb25WaWV3Ll9pbnNlcnRCZWZvcmUoY2hpbGRWaWV3LCBpbmRleCkpe1xuICAgICAgICAgIGNvbGxlY3Rpb25WaWV3Ll9pbnNlcnRBZnRlcihjaGlsZFZpZXcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBDaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSB2aWV3IGludG9cbiAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbi5cbiAgICBfaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZFZpZXcsIGluZGV4KSB7XG4gICAgICB2YXIgY3VycmVudFZpZXc7XG4gICAgICB2YXIgZmluZFBvc2l0aW9uID0gdGhpcy5zb3J0ICYmIChpbmRleCA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoZmluZFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHZpZXcgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgICAgY3VycmVudFZpZXcgPSB0aGlzLmNoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5faW5kZXggPT09IGluZGV4ICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGN1cnJlbnRWaWV3KSB7XG4gICAgICAgIGN1cnJlbnRWaWV3LiRlbC5iZWZvcmUoY2hpbGRWaWV3LmVsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gQXBwZW5kIGEgdmlldyB0byB0aGUgZW5kIG9mIHRoZSAkZWxcbiAgICBfaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKGNoaWxkVmlldy5lbCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldCB1cCB0aGUgYGNoaWxkcmVuYCBvYmplY3QgZm9yXG4gICAgLy8gc3RvcmluZyBhbGwgb2YgdGhlIGNoaWxkIHZpZXdzXG4gICAgX2luaXRDaGlsZFZpZXdTdG9yYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSGFuZGxlIGNsZWFudXAgYW5kIG90aGVyIGRlc3Ryb3lpbmcgbmVlZHMgZm9yIHRoZSBjb2xsZWN0aW9uIG9mIHZpZXdzXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgeyByZXR1cm47IH1cbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpkZXN0cm95OmNvbGxlY3Rpb24nKTtcbiAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKCk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2Rlc3Ryb3k6Y29sbGVjdGlvbicpO1xuICBcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLlZpZXcucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBEZXN0cm95IHRoZSBjaGlsZCB2aWV3cyB0aGF0IHRoaXMgY29sbGVjdGlvbiB2aWV3XG4gICAgLy8gaXMgaG9sZGluZyBvbiB0bywgaWYgYW55XG4gICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZFZpZXdzID0gdGhpcy5jaGlsZHJlbi5tYXAoXy5pZGVudGl0eSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2godGhpcy5yZW1vdmVDaGlsZFZpZXcsIHRoaXMpO1xuICAgICAgdGhpcy5jaGVja0VtcHR5KCk7XG4gICAgICByZXR1cm4gY2hpbGRWaWV3cztcbiAgICB9LFxuICBcbiAgICAvLyBTZXQgdXAgdGhlIGNoaWxkIHZpZXcgZXZlbnQgZm9yd2FyZGluZy4gVXNlcyBhIFwiY2hpbGR2aWV3OlwiXG4gICAgLy8gcHJlZml4IGluIGZyb250IG9mIGFsbCBmb3J3YXJkZWQgZXZlbnRzLlxuICAgIHByb3h5Q2hpbGRFdmVudHM6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLmdldE9wdGlvbignY2hpbGRWaWV3RXZlbnRQcmVmaXgnKTtcbiAgXG4gICAgICAvLyBGb3J3YXJkIGFsbCBjaGlsZCB2aWV3IGV2ZW50cyB0aHJvdWdoIHRoZSBwYXJlbnQsXG4gICAgICAvLyBwcmVwZW5kaW5nIFwiY2hpbGR2aWV3OlwiIHRvIHRoZSBldmVudCBuYW1lXG4gICAgICB0aGlzLmxpc3RlblRvKHZpZXcsICdhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHJvb3RFdmVudCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjaGlsZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplTWV0aG9kcyhfLnJlc3VsdCh0aGlzLCAnY2hpbGRFdmVudHMnKSk7XG4gIFxuICAgICAgICBhcmdzWzBdID0gcHJlZml4ICsgJzonICsgcm9vdEV2ZW50O1xuICAgICAgICBhcmdzLnNwbGljZSgxLCAwLCB2aWV3KTtcbiAgXG4gICAgICAgIC8vIGNhbGwgY29sbGVjdGlvblZpZXcgY2hpbGRFdmVudCBpZiBkZWZpbmVkXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRFdmVudHMgIT09ICd1bmRlZmluZWQnICYmIF8uaXNGdW5jdGlvbihjaGlsZEV2ZW50c1tyb290RXZlbnRdKSkge1xuICAgICAgICAgIGNoaWxkRXZlbnRzW3Jvb3RFdmVudF0uYXBwbHkodGhpcywgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIF9nZXRJbW1lZGlhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy52YWx1ZXModGhpcy5jaGlsZHJlbi5fdmlld3MpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMTcsIG1heGxlbjogMTE3ICovXG4gIFxuICAvLyBDb21wb3NpdGUgVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gVXNlZCBmb3IgcmVuZGVyaW5nIGEgYnJhbmNoLWxlYWYsIGhpZXJhcmNoaWNhbCBzdHJ1Y3R1cmUuXG4gIC8vIEV4dGVuZHMgZGlyZWN0bHkgZnJvbSBDb2xsZWN0aW9uVmlldyBhbmQgYWxzbyByZW5kZXJzIGFuXG4gIC8vIGEgY2hpbGQgdmlldyBhcyBgbW9kZWxWaWV3YCwgZm9yIHRoZSB0b3AgbGVhZlxuICBNYXJpb25ldHRlLkNvbXBvc2l0ZVZpZXcgPSBNYXJpb25ldHRlLkNvbGxlY3Rpb25WaWV3LmV4dGVuZCh7XG4gIFxuICAgIC8vIFNldHRpbmcgdXAgdGhlIGluaGVyaXRhbmNlIGNoYWluIHdoaWNoIGFsbG93cyBjaGFuZ2VzIHRvXG4gICAgLy8gTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3Igd2hpY2ggYWxsb3dzIG92ZXJyaWRpbmdcbiAgICAvLyBvcHRpb24gdG8gcGFzcyAne3NvcnQ6IGZhbHNlfScgdG8gcHJldmVudCB0aGUgQ29tcG9zaXRlVmlldyBmcm9tXG4gICAgLy8gbWFpbnRhaW5pbmcgdGhlIHNvcnRlZCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAvLyBUaGlzIHdpbGwgZmFsbGJhY2sgb250byBhcHBlbmRpbmcgY2hpbGRWaWV3J3MgdG8gdGhlIGVuZC5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICBNYXJpb25ldHRlLkNvbGxlY3Rpb25WaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29uZmlndXJlZCB0aGUgaW5pdGlhbCBldmVudHMgdGhhdCB0aGUgY29tcG9zaXRlIHZpZXdcbiAgICAvLyBiaW5kcyB0by4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJldmVudCB0aGUgaW5pdGlhbFxuICAgIC8vIGV2ZW50cywgb3IgdG8gYWRkIHlvdXIgb3duIGluaXRpYWwgZXZlbnRzLlxuICAgIF9pbml0aWFsRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgXG4gICAgICAvLyBCaW5kIG9ubHkgYWZ0ZXIgY29tcG9zaXRlIHZpZXcgaXMgcmVuZGVyZWQgdG8gYXZvaWQgYWRkaW5nIGNoaWxkIHZpZXdzXG4gICAgICAvLyB0byBub25leGlzdGVudCBjaGlsZFZpZXdDb250YWluZXJcbiAgXG4gICAgICBpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnYWRkJywgdGhpcy5fb25Db2xsZWN0aW9uQWRkKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdyZW1vdmUnLCB0aGlzLl9vbkNvbGxlY3Rpb25SZW1vdmUpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3Jlc2V0JywgdGhpcy5fcmVuZGVyQ2hpbGRyZW4pO1xuICBcbiAgICAgICAgaWYgKHRoaXMuc29ydCkge1xuICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnc29ydCcsIHRoaXMuX3NvcnRWaWV3cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZXRyaWV2ZSB0aGUgYGNoaWxkVmlld2AgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBlYWNoIG9mXG4gICAgLy8gdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpcyB0byByZXR1cm5cbiAgICAvLyBgdGhpcy5jaGlsZFZpZXdgIG9yIE1hcmlvbmV0dGUuQ29tcG9zaXRlVmlldyBpZiBubyBgY2hpbGRWaWV3YFxuICAgIC8vIGhhcyBiZWVuIGRlZmluZWRcbiAgICBnZXRDaGlsZFZpZXc6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRWaWV3ID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlldycpIHx8IHRoaXMuY29uc3RydWN0b3I7XG4gIFxuICAgICAgcmV0dXJuIGNoaWxkVmlldztcbiAgICB9LFxuICBcbiAgICAvLyBTZXJpYWxpemUgdGhlIG1vZGVsIGZvciB0aGUgdmlldy5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoZSBgc2VyaWFsaXplRGF0YWAgbWV0aG9kIGluIHlvdXIgb3duIHZpZXdcbiAgICAvLyBkZWZpbml0aW9uLCB0byBwcm92aWRlIGN1c3RvbSBzZXJpYWxpemF0aW9uIGZvciB5b3VyIHZpZXcncyBkYXRhLlxuICAgIHNlcmlhbGl6ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgXG4gICAgICBpZiAodGhpcy5tb2RlbCl7XG4gICAgICAgIGRhdGEgPSBfLnBhcnRpYWwodGhpcy5zZXJpYWxpemVNb2RlbCwgdGhpcy5tb2RlbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXJzIHRoZSBtb2RlbCBhbmQgdGhlIGNvbGxlY3Rpb24uXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzZXRDaGlsZFZpZXdDb250YWluZXIoKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW5kZXInLCB0aGlzKTtcbiAgXG4gICAgICB0aGlzLl9yZW5kZXJUZW1wbGF0ZSgpO1xuICAgICAgdGhpcy5fcmVuZGVyQ2hpbGRyZW4oKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcicsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgX3JlbmRlckNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldy5wcm90b3R5cGUuX3JlbmRlckNoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gUmVuZGVyIHRoZSByb290IHRlbXBsYXRlIHRoYXQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdmlld3MgYXJlIGFwcGVuZGVkIHRvXG4gICAgX3JlbmRlclRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0ge307XG4gICAgICBkYXRhID0gdGhpcy5zZXJpYWxpemVEYXRhKCk7XG4gICAgICBkYXRhID0gdGhpcy5taXhpblRlbXBsYXRlSGVscGVycyhkYXRhKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW5kZXI6dGVtcGxhdGUnKTtcbiAgXG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLmdldFRlbXBsYXRlKCk7XG4gICAgICB2YXIgaHRtbCA9IE1hcmlvbmV0dGUuUmVuZGVyZXIucmVuZGVyKHRlbXBsYXRlLCBkYXRhLCB0aGlzKTtcbiAgICAgIHRoaXMuYXR0YWNoRWxDb250ZW50KGh0bWwpO1xuICBcbiAgICAgIC8vIHRoZSB1aSBiaW5kaW5ncyBpcyBkb25lIGhlcmUgYW5kIG5vdCBhdCB0aGUgZW5kIG9mIHJlbmRlciBzaW5jZSB0aGV5XG4gICAgICAvLyB3aWxsIG5vdCBiZSBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIG1vZGVsIGlzIHJlbmRlcmVkLCBidXQgc2hvdWxkIGJlXG4gICAgICAvLyBhdmFpbGFibGUgYmVmb3JlIHRoZSBjb2xsZWN0aW9uIGlzIHJlbmRlcmVkLlxuICAgICAgdGhpcy5iaW5kVUlFbGVtZW50cygpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXI6dGVtcGxhdGUnKTtcbiAgICB9LFxuICBcbiAgICAvLyBBdHRhY2hlcyB0aGUgY29udGVudCBvZiB0aGUgcm9vdC5cbiAgICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBvcHRpbWl6ZSByZW5kZXJpbmcsXG4gICAgLy8gb3IgdG8gcmVuZGVyIGluIGEgbm9uIHN0YW5kYXJkIHdheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB1c2luZyBgaW5uZXJIVE1MYCBpbnN0ZWFkIG9mIGAkZWwuaHRtbGBcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8gYXR0YWNoRWxDb250ZW50OiBmdW5jdGlvbihodG1sKSB7XG4gICAgLy8gICB0aGlzLmVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgLy8gICByZXR1cm4gdGhpcztcbiAgICAvLyB9XG4gICAgLy8gYGBgXG4gICAgYXR0YWNoRWxDb250ZW50OiBmdW5jdGlvbihodG1sKSB7XG4gICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIFlvdSBtaWdodCBuZWVkIHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3ZlIG92ZXJyaWRkZW4gYXR0YWNoSHRtbFxuICAgIGF0dGFjaEJ1ZmZlcjogZnVuY3Rpb24oY29tcG9zaXRlVmlldywgYnVmZmVyKSB7XG4gICAgICB2YXIgJGNvbnRhaW5lciA9IHRoaXMuZ2V0Q2hpbGRWaWV3Q29udGFpbmVyKGNvbXBvc2l0ZVZpZXcpO1xuICAgICAgJGNvbnRhaW5lci5hcHBlbmQoYnVmZmVyKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIEFwcGVuZCBhIHZpZXcgdG8gdGhlIGVuZCBvZiB0aGUgJGVsLlxuICAgIC8vIE92ZXJpZGRlbiBmcm9tIENvbGxlY3Rpb25WaWV3IHRvIGVuc3VyZSB2aWV3IGlzIGFwcGVuZGVkIHRvXG4gICAgLy8gY2hpbGRWaWV3Q29udGFpbmVyXG4gICAgX2luc2VydEFmdGVyOiBmdW5jdGlvbiAoY2hpbGRWaWV3KSB7XG4gICAgICB2YXIgJGNvbnRhaW5lciA9IHRoaXMuZ2V0Q2hpbGRWaWV3Q29udGFpbmVyKHRoaXMsIGNoaWxkVmlldyk7XG4gICAgICAkY29udGFpbmVyLmFwcGVuZChjaGlsZFZpZXcuZWwpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBlbnN1cmUgYW4gYCRjaGlsZFZpZXdDb250YWluZXJgIGV4aXN0cywgZm9yIHRoZVxuICAgIC8vIGBhdHRhY2hIdG1sYCBtZXRob2QgdG8gdXNlLlxuICAgIGdldENoaWxkVmlld0NvbnRhaW5lcjogZnVuY3Rpb24oY29udGFpbmVyVmlldywgY2hpbGRWaWV3KSB7XG4gICAgICBpZiAoJyRjaGlsZFZpZXdDb250YWluZXInIGluIGNvbnRhaW5lclZpZXcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclZpZXcuJGNoaWxkVmlld0NvbnRhaW5lcjtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgY29udGFpbmVyO1xuICAgICAgdmFyIGNoaWxkVmlld0NvbnRhaW5lciA9IE1hcmlvbmV0dGUuZ2V0T3B0aW9uKGNvbnRhaW5lclZpZXcsICdjaGlsZFZpZXdDb250YWluZXInKTtcbiAgICAgIGlmIChjaGlsZFZpZXdDb250YWluZXIpIHtcbiAgXG4gICAgICAgIHZhciBzZWxlY3RvciA9IF8uaXNGdW5jdGlvbihjaGlsZFZpZXdDb250YWluZXIpID8gY2hpbGRWaWV3Q29udGFpbmVyLmNhbGwoY29udGFpbmVyVmlldykgOiBjaGlsZFZpZXdDb250YWluZXI7XG4gIFxuICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckF0KDApID09PSAnQCcgJiYgY29udGFpbmVyVmlldy51aSkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclZpZXcudWlbc2VsZWN0b3Iuc3Vic3RyKDQpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJWaWV3LiQoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgICAgbmFtZTogJ0NoaWxkVmlld0NvbnRhaW5lck1pc3NpbmdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIHNwZWNpZmllZCBcImNoaWxkVmlld0NvbnRhaW5lclwiIHdhcyBub3QgZm91bmQ6ICcgKyBjb250YWluZXJWaWV3LmNoaWxkVmlld0NvbnRhaW5lclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyVmlldy4kZWw7XG4gICAgICB9XG4gIFxuICAgICAgY29udGFpbmVyVmlldy4kY2hpbGRWaWV3Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gcmVzZXQgdGhlIGAkY2hpbGRWaWV3Q29udGFpbmVyYCBvbiByZW5kZXJcbiAgICByZXNldENoaWxkVmlld0NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy4kY2hpbGRWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLiRjaGlsZFZpZXdDb250YWluZXI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIExheW91dCBWaWV3XG4gIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAvLyBVc2VkIGZvciBtYW5hZ2luZyBhcHBsaWNhdGlvbiBsYXlvdXRWaWV3cywgbmVzdGVkIGxheW91dFZpZXdzIGFuZFxuICAvLyBtdWx0aXBsZSByZWdpb25zIHdpdGhpbiBhbiBhcHBsaWNhdGlvbiBvciBzdWItYXBwbGljYXRpb24uXG4gIC8vXG4gIC8vIEEgc3BlY2lhbGl6ZWQgdmlldyBjbGFzcyB0aGF0IHJlbmRlcnMgYW4gYXJlYSBvZiBIVE1MIGFuZCB0aGVuXG4gIC8vIGF0dGFjaGVzIGBSZWdpb25gIGluc3RhbmNlcyB0byB0aGUgc3BlY2lmaWVkIGByZWdpb25zYC5cbiAgLy8gVXNlZCBmb3IgY29tcG9zaXRlIHZpZXcgbWFuYWdlbWVudCBhbmQgc3ViLWFwcGxpY2F0aW9uIGFyZWFzLlxuICBNYXJpb25ldHRlLkxheW91dFZpZXcgPSBNYXJpb25ldHRlLkl0ZW1WaWV3LmV4dGVuZCh7XG4gICAgcmVnaW9uQ2xhc3M6IE1hcmlvbmV0dGUuUmVnaW9uLFxuICBcbiAgICAvLyBFbnN1cmUgdGhlIHJlZ2lvbnMgYXJlIGF2YWlsYWJsZSB3aGVuIHRoZSBgaW5pdGlhbGl6ZWAgbWV0aG9kXG4gICAgLy8gaXMgY2FsbGVkLlxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgICB0aGlzLl9maXJzdFJlbmRlciA9IHRydWU7XG4gICAgICB0aGlzLl9pbml0aWFsaXplUmVnaW9ucyhvcHRpb25zKTtcbiAgXG4gICAgICBNYXJpb25ldHRlLkl0ZW1WaWV3LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gTGF5b3V0VmlldydzIHJlbmRlciB3aWxsIHVzZSB0aGUgZXhpc3RpbmcgcmVnaW9uIG9iamVjdHMgdGhlXG4gICAgLy8gZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuIFN1YnNlcXVlbnQgY2FsbHMgd2lsbCBkZXN0cm95IHRoZVxuICAgIC8vIHZpZXdzIHRoYXQgdGhlIHJlZ2lvbnMgYXJlIHNob3dpbmcgYW5kIHRoZW4gcmVzZXQgdGhlIGBlbGBcbiAgICAvLyBmb3IgdGhlIHJlZ2lvbnMgdG8gdGhlIG5ld2x5IHJlbmRlcmVkIERPTSBlbGVtZW50cy5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZW5zdXJlVmlld0lzSW50YWN0KCk7XG4gIFxuICAgICAgaWYgKHRoaXMuX2ZpcnN0UmVuZGVyKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciwgZG9uJ3QgZG8gYW55dGhpbmcgdG9cbiAgICAgICAgLy8gcmVzZXQgdGhlIHJlZ2lvbnNcbiAgICAgICAgdGhpcy5fZmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCByZW5kZXIgY2FsbCwgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlLWluaXRpYWxpemUgdGhlIGBlbGAgZm9yIGVhY2ggcmVnaW9uXG4gICAgICAgIHRoaXMuX3JlSW5pdGlhbGl6ZVJlZ2lvbnMoKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5JdGVtVmlldy5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gSGFuZGxlIGRlc3Ryb3lpbmcgcmVnaW9ucywgYW5kIHRoZW4gZGVzdHJveSB0aGUgdmlldyBpdHNlbGYuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuICBcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5JdGVtVmlldy5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBhIHNpbmdsZSByZWdpb24sIGJ5IG5hbWUsIHRvIHRoZSBsYXlvdXRWaWV3XG4gICAgYWRkUmVnaW9uOiBmdW5jdGlvbihuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICB2YXIgcmVnaW9ucyA9IHt9O1xuICAgICAgcmVnaW9uc1tuYW1lXSA9IGRlZmluaXRpb247XG4gICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZWdpb25zKHJlZ2lvbnMpW25hbWVdO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBtdWx0aXBsZSByZWdpb25zIGFzIGEge25hbWU6IGRlZmluaXRpb24sIG5hbWUyOiBkZWYyfSBvYmplY3QgbGl0ZXJhbFxuICAgIGFkZFJlZ2lvbnM6IGZ1bmN0aW9uKHJlZ2lvbnMpIHtcbiAgICAgIHRoaXMucmVnaW9ucyA9IF8uZXh0ZW5kKHt9LCB0aGlzLnJlZ2lvbnMsIHJlZ2lvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9ucyhyZWdpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgYSBzaW5nbGUgcmVnaW9uIGZyb20gdGhlIExheW91dFZpZXcsIGJ5IG5hbWVcbiAgICByZW1vdmVSZWdpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lvbnNbbmFtZV07XG4gICAgICByZXR1cm4gdGhpcy5yZWdpb25NYW5hZ2VyLnJlbW92ZVJlZ2lvbihuYW1lKTtcbiAgICB9LFxuICBcbiAgICAvLyBQcm92aWRlcyBhbHRlcm5hdGl2ZSBhY2Nlc3MgdG8gcmVnaW9uc1xuICAgIC8vIEFjY2VwdHMgdGhlIHJlZ2lvbiBuYW1lXG4gICAgLy8gZ2V0UmVnaW9uKCdtYWluJylcbiAgICBnZXRSZWdpb246IGZ1bmN0aW9uKHJlZ2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaW9uTWFuYWdlci5nZXQocmVnaW9uKTtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYWxsIHJlZ2lvbnNcbiAgICBnZXRSZWdpb25zOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMucmVnaW9uTWFuYWdlci5nZXRSZWdpb25zKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGJ1aWxkIHJlZ2lvbnNcbiAgICBfYnVpbGRSZWdpb25zOiBmdW5jdGlvbihyZWdpb25zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIHJlZ2lvbkNsYXNzOiB0aGlzLmdldE9wdGlvbigncmVnaW9uQ2xhc3MnKSxcbiAgICAgICAgcGFyZW50RWw6IF8ucGFydGlhbChfLnJlc3VsdCwgdGhpcywgJyRlbCcpXG4gICAgICB9O1xuICBcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9ucyhyZWdpb25zLCBkZWZhdWx0cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIGJlZW4gZGVmaW5lZCBpbiBhXG4gICAgLy8gYHJlZ2lvbnNgIGF0dHJpYnV0ZSBvbiB0aGlzIGxheW91dFZpZXcuXG4gICAgX2luaXRpYWxpemVSZWdpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVnaW9ucztcbiAgICAgIHRoaXMuX2luaXRSZWdpb25NYW5hZ2VyKCk7XG4gIFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLnJlZ2lvbnMpKSB7XG4gICAgICAgIHJlZ2lvbnMgPSB0aGlzLnJlZ2lvbnMob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpb25zID0gdGhpcy5yZWdpb25zIHx8IHt9O1xuICAgICAgfVxuICBcbiAgICAgIC8vIEVuYWJsZSB1c2VycyB0byBkZWZpbmUgYHJlZ2lvbnNgIGFzIGluc3RhbmNlIG9wdGlvbnMuXG4gICAgICB2YXIgcmVnaW9uT3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9uLmNhbGwob3B0aW9ucywgJ3JlZ2lvbnMnKTtcbiAgXG4gICAgICAvLyBlbmFibGUgcmVnaW9uIG9wdGlvbnMgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihyZWdpb25PcHRpb25zKSkge1xuICAgICAgICByZWdpb25PcHRpb25zID0gcmVnaW9uT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICBcbiAgICAgIF8uZXh0ZW5kKHJlZ2lvbnMsIHJlZ2lvbk9wdGlvbnMpO1xuICBcbiAgICAgIC8vIE5vcm1hbGl6ZSByZWdpb24gc2VsZWN0b3JzIGhhc2ggdG8gYWxsb3dcbiAgICAgIC8vIGEgdXNlciB0byB1c2UgdGhlIEB1aS4gc3ludGF4LlxuICAgICAgcmVnaW9ucyA9IHRoaXMubm9ybWFsaXplVUlWYWx1ZXMocmVnaW9ucyk7XG4gIFxuICAgICAgdGhpcy5hZGRSZWdpb25zKHJlZ2lvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byByZS1pbml0aWFsaXplIGFsbCBvZiB0aGUgcmVnaW9ucyBieSB1cGRhdGluZyB0aGUgYGVsYCB0aGF0XG4gICAgLy8gdGhleSBwb2ludCB0b1xuICAgIF9yZUluaXRpYWxpemVSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5pbnZva2UoJ3Jlc2V0Jyk7XG4gICAgfSxcbiAgXG4gICAgLy8gRW5hYmxlIGVhc3kgb3ZlcnJpZGluZyBvZiB0aGUgZGVmYXVsdCBgUmVnaW9uTWFuYWdlcmBcbiAgICAvLyBmb3IgY3VzdG9taXplZCByZWdpb24gaW50ZXJhY3Rpb25zIGFuZCBidXNpbmVzcyBzcGVjaWZpY1xuICAgIC8vIHZpZXcgbG9naWMgZm9yIGJldHRlciBjb250cm9sIG92ZXIgc2luZ2xlIHJlZ2lvbnMuXG4gICAgZ2V0UmVnaW9uTWFuYWdlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcmlvbmV0dGUuUmVnaW9uTWFuYWdlcigpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBpbml0aWFsaXplIHRoZSByZWdpb24gbWFuYWdlclxuICAgIC8vIGFuZCBhbGwgcmVnaW9ucyBpbiBpdFxuICAgIF9pbml0UmVnaW9uTWFuYWdlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lvbk1hbmFnZXIgPSB0aGlzLmdldFJlZ2lvbk1hbmFnZXIoKTtcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5fcGFyZW50ID0gdGhpcztcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMucmVnaW9uTWFuYWdlciwgJ2JlZm9yZTphZGQ6cmVnaW9uJywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTphZGQ6cmVnaW9uJywgbmFtZSk7XG4gICAgICB9KTtcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMucmVnaW9uTWFuYWdlciwgJ2FkZDpyZWdpb24nLCBmdW5jdGlvbihuYW1lLCByZWdpb24pIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdhZGQ6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBuYW1lKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAncmVtb3ZlOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW1vdmU6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIF9nZXRJbW1lZGlhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jaGFpbih0aGlzLnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9ucygpKVxuICAgICAgICAucGx1Y2soJ2N1cnJlbnRWaWV3JylcbiAgICAgICAgLmNvbXBhY3QoKVxuICAgICAgICAudmFsdWUoKTtcbiAgICB9XG4gIH0pO1xuICBcblxuICAvLyBCZWhhdmlvclxuICAvLyAtLS0tLS0tLVxuICBcbiAgLy8gQSBCZWhhdmlvciBpcyBhbiBpc29sYXRlZCBzZXQgb2YgRE9NIC9cbiAgLy8gdXNlciBpbnRlcmFjdGlvbnMgdGhhdCBjYW4gYmUgbWl4ZWQgaW50byBhbnkgVmlldy5cbiAgLy8gQmVoYXZpb3JzIGFsbG93IHlvdSB0byBibGFja2JveCBWaWV3IHNwZWNpZmljIGludGVyYWN0aW9uc1xuICAvLyBpbnRvIHBvcnRhYmxlIGxvZ2ljYWwgY2h1bmtzLCBrZWVwaW5nIHlvdXIgdmlld3Mgc2ltcGxlIGFuZCB5b3VyIGNvZGUgRFJZLlxuICBcbiAgTWFyaW9uZXR0ZS5CZWhhdmlvciA9IE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMsIHZpZXcpIHtcbiAgICAgIC8vIFNldHVwIHJlZmVyZW5jZSB0byB0aGUgdmlldy5cbiAgICAgIC8vIHRoaXMgY29tZXMgaW4gaGFuZGxlIHdoZW4gYSBiZWhhdmlvclxuICAgICAgLy8gd2FudHMgdG8gZGlyZWN0bHkgdGFsayB1cCB0aGUgY2hhaW5cbiAgICAgIC8vIHRvIHRoZSB2aWV3LlxuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSB8fCB7fTtcbiAgICAgIHRoaXMub3B0aW9ucyAgPSBfLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBwcm94eSBiZWhhdmlvciAkIG1ldGhvZCB0byB0aGUgdmlld1xuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBkb2luZyBqcXVlcnkgRE9NIGxvb2t1cHNcbiAgICAvLyBzY29wZWQgdG8gYmVoYXZpb3JzIHZpZXcuXG4gICAgJDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LiQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFN0b3BzIHRoZSBiZWhhdmlvciBmcm9tIGxpc3RlbmluZyB0byBldmVudHMuXG4gICAgLy8gT3ZlcnJpZGVzIE9iamVjdCNkZXN0cm95IHRvIHByZXZlbnQgYWRkaXRpb25hbCBldmVudHMgZnJvbSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICB9LFxuICBcbiAgICBwcm94eVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbiAodmlldykge1xuICAgICAgdGhpcy4kZWwgPSB2aWV3LiRlbDtcbiAgICAgIHRoaXMuZWwgPSB2aWV3LmVsO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvKiBqc2hpbnQgbWF4bGVuOiAxNDMgKi9cbiAgLy8gQmVoYXZpb3JzXG4gIC8vIC0tLS0tLS0tLVxuICBcbiAgLy8gQmVoYXZpb3JzIGlzIGEgdXRpbGl0eSBjbGFzcyB0aGF0IHRha2VzIGNhcmUgb2ZcbiAgLy8gZ2x1aW5nIHlvdXIgYmVoYXZpb3IgaW5zdGFuY2VzIHRvIHRoZWlyIGdpdmVuIFZpZXcuXG4gIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IG9mIHRoaXMgY2xhc3MgaXMgdGhhdCB5b3VcbiAgLy8gKipNVVNUKiogb3ZlcnJpZGUgdGhlIGNsYXNzIGxldmVsIGJlaGF2aW9yc0xvb2t1cFxuICAvLyBtZXRob2QgZm9yIHRoaW5ncyB0byB3b3JrIHByb3Blcmx5LlxuICBcbiAgTWFyaW9uZXR0ZS5CZWhhdmlvcnMgPSAoZnVuY3Rpb24oTWFyaW9uZXR0ZSwgXykge1xuICBcbiAgICBmdW5jdGlvbiBCZWhhdmlvcnModmlldywgYmVoYXZpb3JzKSB7XG4gIFxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHZpZXcuYmVoYXZpb3JzKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gIFxuICAgICAgLy8gQmVoYXZpb3JzIGRlZmluZWQgb24gYSB2aWV3IGNhbiBiZSBhIGZsYXQgb2JqZWN0IGxpdGVyYWxcbiAgICAgIC8vIG9yIGl0IGNhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QuXG4gICAgICBiZWhhdmlvcnMgPSBCZWhhdmlvcnMucGFyc2VCZWhhdmlvcnModmlldywgYmVoYXZpb3JzIHx8IF8ucmVzdWx0KHZpZXcsICdiZWhhdmlvcnMnKSk7XG4gIFxuICAgICAgLy8gV3JhcHMgc2V2ZXJhbCBvZiB0aGUgdmlldydzIG1ldGhvZHNcbiAgICAgIC8vIGNhbGxpbmcgdGhlIG1ldGhvZHMgZmlyc3Qgb24gZWFjaCBiZWhhdmlvclxuICAgICAgLy8gYW5kIHRoZW4gZXZlbnR1YWxseSBjYWxsaW5nIHRoZSBtZXRob2Qgb24gdGhlIHZpZXcuXG4gICAgICBCZWhhdmlvcnMud3JhcCh2aWV3LCBiZWhhdmlvcnMsIF8ua2V5cyhtZXRob2RzKSk7XG4gICAgICByZXR1cm4gYmVoYXZpb3JzO1xuICAgIH1cbiAgXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICBiZWhhdmlvclRyaWdnZXJzOiBmdW5jdGlvbihiZWhhdmlvclRyaWdnZXJzLCBiZWhhdmlvcnMpIHtcbiAgICAgICAgdmFyIHRyaWdnZXJCdWlsZGVyID0gbmV3IEJlaGF2aW9yVHJpZ2dlcnNCdWlsZGVyKHRoaXMsIGJlaGF2aW9ycyk7XG4gICAgICAgIHJldHVybiB0cmlnZ2VyQnVpbGRlci5idWlsZEJlaGF2aW9yVHJpZ2dlcnMoKTtcbiAgICAgIH0sXG4gIFxuICAgICAgYmVoYXZpb3JFdmVudHM6IGZ1bmN0aW9uKGJlaGF2aW9yRXZlbnRzLCBiZWhhdmlvcnMpIHtcbiAgICAgICAgdmFyIF9iZWhhdmlvcnNFdmVudHMgPSB7fTtcbiAgICAgICAgdmFyIHZpZXdVSSA9IF8ucmVzdWx0KHRoaXMsICd1aScpO1xuICBcbiAgICAgICAgXy5lYWNoKGJlaGF2aW9ycywgZnVuY3Rpb24oYiwgaSkge1xuICAgICAgICAgIHZhciBfZXZlbnRzID0ge307XG4gICAgICAgICAgdmFyIGJlaGF2aW9yRXZlbnRzID0gXy5jbG9uZShfLnJlc3VsdChiLCAnZXZlbnRzJykpIHx8IHt9O1xuICAgICAgICAgIHZhciBiZWhhdmlvclVJID0gXy5yZXN1bHQoYiwgJ3VpJyk7XG4gIFxuICAgICAgICAgIC8vIENvbnN0cnVjdCBhbiBpbnRlcm5hbCBVSSBoYXNoIGZpcnN0IHVzaW5nXG4gICAgICAgICAgLy8gdGhlIHZpZXdzIFVJIGhhc2ggYW5kIHRoZW4gdGhlIGJlaGF2aW9ycyBVSSBoYXNoLlxuICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHVzZSBVSSBoYXNoIGVsZW1lbnRzXG4gICAgICAgICAgLy8gZGVmaW5lZCBpbiB0aGUgcGFyZW50IHZpZXcgYXMgd2VsbCBhcyB0aG9zZVxuICAgICAgICAgIC8vIGRlZmluZWQgaW4gdGhlIGdpdmVuIGJlaGF2aW9yLlxuICAgICAgICAgIHZhciB1aSA9IF8uZXh0ZW5kKHt9LCB2aWV3VUksIGJlaGF2aW9yVUkpO1xuICBcbiAgICAgICAgICAvLyBOb3JtYWxpemUgYmVoYXZpb3IgZXZlbnRzIGhhc2ggdG8gYWxsb3dcbiAgICAgICAgICAvLyBhIHVzZXIgdG8gdXNlIHRoZSBAdWkuIHN5bnRheC5cbiAgICAgICAgICBiZWhhdmlvckV2ZW50cyA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlLZXlzKGJlaGF2aW9yRXZlbnRzLCB1aSk7XG4gIFxuICAgICAgICAgIF8uZWFjaChfLmtleXMoYmVoYXZpb3JFdmVudHMpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB3aGl0ZS1zcGFjZSBhdCB0aGUgZW5kIG9mIGVhY2gga2V5IHRvIHByZXZlbnQgYmVoYXZpb3Iga2V5IGNvbGxpc2lvbnMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJlbHlpbmcgb24gdGhlIGZhY3QgdGhhdCBiYWNrYm9uZSBldmVudHMgY29uc2lkZXJzIFwiY2xpY2sgLmZvb1wiIHRoZSBzYW1lIGFzXG4gICAgICAgICAgICAvLyBcImNsaWNrIC5mb28gXCIuXG4gIFxuICAgICAgICAgICAgLy8gKzIgaXMgdXNlZCBiZWNhdXNlIG5ldyBBcnJheSgxKSBvciAwIGlzIFwiXCIgYW5kIG5vdCBcIiBcIlxuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSAobmV3IEFycmF5KGkgKyAyKSkuam9pbignICcpO1xuICAgICAgICAgICAgdmFyIGV2ZW50S2V5ICAgPSBrZXkgKyB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgICAgPSBfLmlzRnVuY3Rpb24oYmVoYXZpb3JFdmVudHNba2V5XSkgPyBiZWhhdmlvckV2ZW50c1trZXldIDogYltiZWhhdmlvckV2ZW50c1trZXldXTtcbiAgXG4gICAgICAgICAgICBfZXZlbnRzW2V2ZW50S2V5XSA9IF8uYmluZChoYW5kbGVyLCBiKTtcbiAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgX2JlaGF2aW9yc0V2ZW50cyA9IF8uZXh0ZW5kKF9iZWhhdmlvcnNFdmVudHMsIF9ldmVudHMpO1xuICAgICAgICB9KTtcbiAgXG4gICAgICAgIHJldHVybiBfYmVoYXZpb3JzRXZlbnRzO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIF8uZXh0ZW5kKEJlaGF2aW9ycywge1xuICBcbiAgICAgIC8vIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBiZSBleHRlbmRlZCBieSB0aGUgdXNlci5cbiAgICAgIC8vIFRoZSBtZXRob2Qgc2hvdWxkIGRlZmluZSB0aGUgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBiZWhhdmlvcnMuXG4gICAgICAvLyBpLmUuXG4gICAgICAvL1xuICAgICAgLy8gYGBganNcbiAgICAgIC8vIE1hcmlvbmV0dGUuQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIHJldHVybiBBcHAuQmVoYXZpb3JzXG4gICAgICAvLyB9XG4gICAgICAvLyBgYGBcbiAgICAgIGJlaGF2aW9yc0xvb2t1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnWW91IG11c3QgZGVmaW5lIHdoZXJlIHlvdXIgYmVoYXZpb3JzIGFyZSBzdG9yZWQuJyxcbiAgICAgICAgICB1cmw6ICdtYXJpb25ldHRlLmJlaGF2aW9ycy5odG1sI2JlaGF2aW9yc2xvb2t1cCdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFRha2VzIGNhcmUgb2YgZ2V0dGluZyB0aGUgYmVoYXZpb3IgY2xhc3NcbiAgICAgIC8vIGdpdmVuIG9wdGlvbnMgYW5kIGEga2V5LlxuICAgICAgLy8gSWYgYSB1c2VyIHBhc3NlcyBpbiBvcHRpb25zLmJlaGF2aW9yQ2xhc3NcbiAgICAgIC8vIGRlZmF1bHQgdG8gdXNpbmcgdGhhdC4gT3RoZXJ3aXNlIGRlbGVnYXRlXG4gICAgICAvLyB0aGUgbG9va3VwIHRvIHRoZSB1c2VycyBgYmVoYXZpb3JzTG9va3VwYCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIGdldEJlaGF2aW9yQ2xhc3M6IGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWhhdmlvckNsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuYmVoYXZpb3JDbGFzcztcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gR2V0IGJlaGF2aW9yIGNsYXNzIGNhbiBiZSBlaXRoZXIgYSBmbGF0IG9iamVjdCBvciBhIG1ldGhvZFxuICAgICAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKEJlaGF2aW9ycy5iZWhhdmlvcnNMb29rdXApID8gQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpW2tleV0gOiBCZWhhdmlvcnMuYmVoYXZpb3JzTG9va3VwW2tleV07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgYmVoYXZpb3JzIG9iamVjdCwgZm9yIGVhY2ggYmVoYXZpb3JcbiAgICAgIC8vIGluc3RhbnRpYXRlIGl0IGFuZCBnZXQgaXRzIGdyb3VwZWQgYmVoYXZpb3JzLlxuICAgICAgcGFyc2VCZWhhdmlvcnM6IGZ1bmN0aW9uKHZpZXcsIGJlaGF2aW9ycykge1xuICAgICAgICByZXR1cm4gXy5jaGFpbihiZWhhdmlvcnMpLm1hcChmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgICB2YXIgQmVoYXZpb3JDbGFzcyA9IEJlaGF2aW9ycy5nZXRCZWhhdmlvckNsYXNzKG9wdGlvbnMsIGtleSk7XG4gIFxuICAgICAgICAgIHZhciBiZWhhdmlvciA9IG5ldyBCZWhhdmlvckNsYXNzKG9wdGlvbnMsIHZpZXcpO1xuICAgICAgICAgIHZhciBuZXN0ZWRCZWhhdmlvcnMgPSBCZWhhdmlvcnMucGFyc2VCZWhhdmlvcnModmlldywgXy5yZXN1bHQoYmVoYXZpb3IsICdiZWhhdmlvcnMnKSk7XG4gIFxuICAgICAgICAgIHJldHVybiBbYmVoYXZpb3JdLmNvbmNhdChuZXN0ZWRCZWhhdmlvcnMpO1xuICAgICAgICB9KS5mbGF0dGVuKCkudmFsdWUoKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gV3JhcCB2aWV3IGludGVybmFsIG1ldGhvZHMgc28gdGhhdCB0aGV5IGRlbGVnYXRlIHRvIGJlaGF2aW9ycy4gRm9yIGV4YW1wbGUsXG4gICAgICAvLyBgb25EZXN0cm95YCBzaG91bGQgdHJpZ2dlciBkZXN0cm95IG9uIGFsbCBvZiB0aGUgYmVoYXZpb3JzIGFuZCB0aGVuIGRlc3Ryb3kgaXRzZWxmLlxuICAgICAgLy8gaS5lLlxuICAgICAgLy9cbiAgICAgIC8vIGB2aWV3LmRlbGVnYXRlRXZlbnRzID0gXy5wYXJ0aWFsKG1ldGhvZHMuZGVsZWdhdGVFdmVudHMsIHZpZXcuZGVsZWdhdGVFdmVudHMsIGJlaGF2aW9ycyk7YFxuICAgICAgd3JhcDogZnVuY3Rpb24odmlldywgYmVoYXZpb3JzLCBtZXRob2ROYW1lcykge1xuICAgICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB2aWV3W21ldGhvZE5hbWVdID0gXy5wYXJ0aWFsKG1ldGhvZHNbbWV0aG9kTmFtZV0sIHZpZXdbbWV0aG9kTmFtZV0sIGJlaGF2aW9ycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICAvLyBDbGFzcyB0byBidWlsZCBoYW5kbGVycyBmb3IgYHRyaWdnZXJzYCBvbiBiZWhhdmlvcnNcbiAgICAvLyBmb3Igdmlld3NcbiAgICBmdW5jdGlvbiBCZWhhdmlvclRyaWdnZXJzQnVpbGRlcih2aWV3LCBiZWhhdmlvcnMpIHtcbiAgICAgIHRoaXMuX3ZpZXcgICAgICA9IHZpZXc7XG4gICAgICB0aGlzLl92aWV3VUkgICAgPSBfLnJlc3VsdCh2aWV3LCAndWknKTtcbiAgICAgIHRoaXMuX2JlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgICAgIHRoaXMuX3RyaWdnZXJzICA9IHt9O1xuICAgIH1cbiAgXG4gICAgXy5leHRlbmQoQmVoYXZpb3JUcmlnZ2Vyc0J1aWxkZXIucHJvdG90eXBlLCB7XG4gICAgICAvLyBNYWluIG1ldGhvZCB0byBidWlsZCB0aGUgdHJpZ2dlcnMgaGFzaCB3aXRoIGV2ZW50IGtleXMgYW5kIGhhbmRsZXJzXG4gICAgICBidWlsZEJlaGF2aW9yVHJpZ2dlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfLmVhY2godGhpcy5fYmVoYXZpb3JzLCB0aGlzLl9idWlsZFRyaWdnZXJIYW5kbGVyc0ZvckJlaGF2aW9yLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJzO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gYnVpbGQgYWxsIHRyaWdnZXIgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gYmVoYXZpb3JcbiAgICAgIF9idWlsZFRyaWdnZXJIYW5kbGVyc0ZvckJlaGF2aW9yOiBmdW5jdGlvbihiZWhhdmlvciwgaSkge1xuICAgICAgICB2YXIgdWkgPSBfLmV4dGVuZCh7fSwgdGhpcy5fdmlld1VJLCBfLnJlc3VsdChiZWhhdmlvciwgJ3VpJykpO1xuICAgICAgICB2YXIgdHJpZ2dlcnNIYXNoID0gXy5jbG9uZShfLnJlc3VsdChiZWhhdmlvciwgJ3RyaWdnZXJzJykpIHx8IHt9O1xuICBcbiAgICAgICAgdHJpZ2dlcnNIYXNoID0gTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXModHJpZ2dlcnNIYXNoLCB1aSk7XG4gIFxuICAgICAgICBfLmVhY2godHJpZ2dlcnNIYXNoLCBfLnBhcnRpYWwodGhpcy5fc2V0SGFuZGxlckZvckJlaGF2aW9yLCBiZWhhdmlvciwgaSksIHRoaXMpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGFuZCBhc3NpZ24gdGhlIHRyaWdnZXIgaGFuZGxlciBmb3IgYSBnaXZlblxuICAgICAgLy8gYmVoYXZpb3JcbiAgICAgIF9zZXRIYW5kbGVyRm9yQmVoYXZpb3I6IGZ1bmN0aW9uKGJlaGF2aW9yLCBpLCBldmVudE5hbWUsIHRyaWdnZXIpIHtcbiAgICAgICAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBgdGhpcy5fdHJpZ2dlcnNgIGhhc2hcbiAgICAgICAgdmFyIHRyaWdnZXJLZXkgPSB0cmlnZ2VyLnJlcGxhY2UoL15cXFMrLywgZnVuY3Rpb24odHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlck5hbWUgKyAnLicgKyAnYmVoYXZpb3J0cmlnZ2VycycgKyBpO1xuICAgICAgICB9KTtcbiAgXG4gICAgICAgIHRoaXMuX3RyaWdnZXJzW3RyaWdnZXJLZXldID0gdGhpcy5fdmlldy5fYnVpbGRWaWV3VHJpZ2dlcihldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gQmVoYXZpb3JzO1xuICBcbiAgfSkoTWFyaW9uZXR0ZSwgXyk7XG4gIFxuXG4gIC8vIEFwcCBSb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLVxuICBcbiAgLy8gUmVkdWNlIHRoZSBib2lsZXJwbGF0ZSBjb2RlIG9mIGhhbmRsaW5nIHJvdXRlIGV2ZW50c1xuICAvLyBhbmQgdGhlbiBjYWxsaW5nIGEgc2luZ2xlIG1ldGhvZCBvbiBhbm90aGVyIG9iamVjdC5cbiAgLy8gSGF2ZSB5b3VyIHJvdXRlcnMgY29uZmlndXJlZCB0byBjYWxsIHRoZSBtZXRob2Qgb25cbiAgLy8geW91ciBvYmplY3QsIGRpcmVjdGx5LlxuICAvL1xuICAvLyBDb25maWd1cmUgYW4gQXBwUm91dGVyIHdpdGggYGFwcFJvdXRlc2AuXG4gIC8vXG4gIC8vIEFwcCByb3V0ZXJzIGNhbiBvbmx5IHRha2Ugb25lIGBjb250cm9sbGVyYCBvYmplY3QuXG4gIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IGRpdmlkZSB5b3VyIGNvbnRyb2xsZXJcbiAgLy8gb2JqZWN0cyBpbiB0byBzbWFsbGVyIHBpZWNlcyBvZiByZWxhdGVkIGZ1bmN0aW9uYWxpdHlcbiAgLy8gYW5kIGhhdmUgbXVsdGlwbGUgcm91dGVycyAvIGNvbnRyb2xsZXJzLCBpbnN0ZWFkIG9mXG4gIC8vIGp1c3Qgb25lIGdpYW50IHJvdXRlciBhbmQgY29udHJvbGxlci5cbiAgLy9cbiAgLy8gWW91IGNhbiBhbHNvIGFkZCBzdGFuZGFyZCByb3V0ZXMgdG8gYW4gQXBwUm91dGVyLlxuICBcbiAgTWFyaW9uZXR0ZS5BcHBSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIuZXh0ZW5kKHtcbiAgXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgICAgQmFja2JvbmUuUm91dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdmFyIGFwcFJvdXRlcyA9IHRoaXMuZ2V0T3B0aW9uKCdhcHBSb3V0ZXMnKTtcbiAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fZ2V0Q29udHJvbGxlcigpO1xuICAgICAgdGhpcy5wcm9jZXNzQXBwUm91dGVzKGNvbnRyb2xsZXIsIGFwcFJvdXRlcyk7XG4gICAgICB0aGlzLm9uKCdyb3V0ZScsIHRoaXMuX3Byb2Nlc3NPblJvdXRlLCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBTaW1pbGFyIHRvIHJvdXRlIG1ldGhvZCBvbiBhIEJhY2tib25lIFJvdXRlciBidXRcbiAgICAvLyBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBjb250cm9sbGVyXG4gICAgYXBwUm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2dldENvbnRyb2xsZXIoKTtcbiAgICAgIHRoaXMuX2FkZEFwcFJvdXRlKGNvbnRyb2xsZXIsIHJvdXRlLCBtZXRob2ROYW1lKTtcbiAgICB9LFxuICBcbiAgICAvLyBwcm9jZXNzIHRoZSByb3V0ZSBldmVudCBhbmQgdHJpZ2dlciB0aGUgb25Sb3V0ZVxuICAgIC8vIG1ldGhvZCBjYWxsLCBpZiBpdCBleGlzdHNcbiAgICBfcHJvY2Vzc09uUm91dGU6IGZ1bmN0aW9uKHJvdXRlTmFtZSwgcm91dGVBcmdzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYW4gb25Sb3V0ZSBiZWZvcmUgdHJ5aW5nIHRvIGNhbGwgaXRcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5vblJvdXRlKSkge1xuICAgICAgICAvLyBmaW5kIHRoZSBwYXRoIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCByb3V0ZVxuICAgICAgICB2YXIgcm91dGVQYXRoID0gXy5pbnZlcnQodGhpcy5nZXRPcHRpb24oJ2FwcFJvdXRlcycpKVtyb3V0ZU5hbWVdO1xuICAgICAgICB0aGlzLm9uUm91dGUocm91dGVOYW1lLCByb3V0ZVBhdGgsIHJvdXRlQXJncyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHByb2Nlc3MgdGhlIGBhcHBSb3V0ZXNgIGZvciB0aGVcbiAgICAvLyByb3V0ZXIsIGFuZCB0dXJuIHRoZW0gaW4gdG8gcm91dGVzIHRoYXQgdHJpZ2dlciB0aGVcbiAgICAvLyBzcGVjaWZpZWQgbWV0aG9kIG9uIHRoZSBzcGVjaWZpZWQgYGNvbnRyb2xsZXJgLlxuICAgIHByb2Nlc3NBcHBSb3V0ZXM6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIGFwcFJvdXRlcykge1xuICAgICAgaWYgKCFhcHBSb3V0ZXMpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgdmFyIHJvdXRlTmFtZXMgPSBfLmtleXMoYXBwUm91dGVzKS5yZXZlcnNlKCk7IC8vIEJhY2tib25lIHJlcXVpcmVzIHJldmVydGVkIG9yZGVyIG9mIHJvdXRlc1xuICBcbiAgICAgIF8uZWFjaChyb3V0ZU5hbWVzLCBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICB0aGlzLl9hZGRBcHBSb3V0ZShjb250cm9sbGVyLCByb3V0ZSwgYXBwUm91dGVzW3JvdXRlXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICBfZ2V0Q29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oJ2NvbnRyb2xsZXInKTtcbiAgICB9LFxuICBcbiAgICBfYWRkQXBwUm91dGU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHJvdXRlLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbWV0aG9kID0gY29udHJvbGxlclttZXRob2ROYW1lXTtcbiAgXG4gICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcignTWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgd2FzIG5vdCBmb3VuZCBvbiB0aGUgY29udHJvbGxlcicpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMucm91dGUocm91dGUsIG1ldGhvZE5hbWUsIF8uYmluZChtZXRob2QsIGNvbnRyb2xsZXIpKTtcbiAgICB9LFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24sXG4gIFxuICAgIHRyaWdnZXJNZXRob2Q6IE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZCxcbiAgXG4gICAgYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eUJpbmRFbnRpdHlFdmVudHMsXG4gIFxuICAgIHVuYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eVVuYmluZEVudGl0eUV2ZW50c1xuICB9KTtcbiAgXG4gIC8vIEFwcGxpY2F0aW9uXG4gIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAvLyBDb250YWluIGFuZCBtYW5hZ2UgdGhlIGNvbXBvc2l0ZSBhcHBsaWNhdGlvbiBhcyBhIHdob2xlLlxuICAvLyBTdG9yZXMgYW5kIHN0YXJ0cyB1cCBgUmVnaW9uYCBvYmplY3RzLCBpbmNsdWRlcyBhblxuICAvLyBldmVudCBhZ2dyZWdhdG9yIGFzIGBhcHAudmVudGBcbiAgTWFyaW9uZXR0ZS5BcHBsaWNhdGlvbiA9IE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVSZWdpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdENhbGxiYWNrcyA9IG5ldyBNYXJpb25ldHRlLkNhbGxiYWNrcygpO1xuICAgICAgdGhpcy5zdWJtb2R1bGVzID0ge307XG4gICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRDaGFubmVsKCk7XG4gICAgICBNYXJpb25ldHRlLk9iamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIENvbW1hbmQgZXhlY3V0aW9uLCBmYWNpbGl0YXRlZCBieSBCYWNrYm9uZS5XcmVxci5Db21tYW5kc1xuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb21tYW5kcy5leGVjdXRlLmFwcGx5KHRoaXMuY29tbWFuZHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVxdWVzdC9yZXNwb25zZSwgZmFjaWxpdGF0ZWQgYnkgQmFja2JvbmUuV3JlcXIuUmVxdWVzdFJlc3BvbnNlXG4gICAgcmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXFyZXMucmVxdWVzdC5hcHBseSh0aGlzLnJlcXJlcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgYW4gaW5pdGlhbGl6ZXIgdGhhdCBpcyBlaXRoZXIgcnVuIGF0IHdoZW4gdGhlIGBzdGFydGBcbiAgICAvLyBtZXRob2QgaXMgY2FsbGVkLCBvciBydW4gaW1tZWRpYXRlbHkgaWYgYWRkZWQgYWZ0ZXIgYHN0YXJ0YFxuICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLlxuICAgIGFkZEluaXRpYWxpemVyOiBmdW5jdGlvbihpbml0aWFsaXplcikge1xuICAgICAgdGhpcy5faW5pdENhbGxiYWNrcy5hZGQoaW5pdGlhbGl6ZXIpO1xuICAgIH0sXG4gIFxuICAgIC8vIGtpY2sgb2ZmIGFsbCBvZiB0aGUgYXBwbGljYXRpb24ncyBwcm9jZXNzZXMuXG4gICAgLy8gaW5pdGlhbGl6ZXMgYWxsIG9mIHRoZSByZWdpb25zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkXG4gICAgLy8gdG8gdGhlIGFwcCwgYW5kIHJ1bnMgYWxsIG9mIHRoZSBpbml0aWFsaXplciBmdW5jdGlvbnNcbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3RhcnQnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRDYWxsYmFja3MucnVuKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzdGFydCcsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCByZWdpb25zIHRvIHlvdXIgYXBwLlxuICAgIC8vIEFjY2VwdHMgYSBoYXNoIG9mIG5hbWVkIHN0cmluZ3Mgb3IgUmVnaW9uIG9iamVjdHNcbiAgICAvLyBhZGRSZWdpb25zKHtzb21ldGhpbmc6IFwiI3NvbWVSZWdpb25cIn0pXG4gICAgLy8gYWRkUmVnaW9ucyh7c29tZXRoaW5nOiBSZWdpb24uZXh0ZW5kKHtlbDogXCIjc29tZVJlZ2lvblwifSkgfSk7XG4gICAgYWRkUmVnaW9uczogZnVuY3Rpb24ocmVnaW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbk1hbmFnZXIuYWRkUmVnaW9ucyhyZWdpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBFbXB0eSBhbGwgcmVnaW9ucyBpbiB0aGUgYXBwLCB3aXRob3V0IHJlbW92aW5nIHRoZW1cbiAgICBlbXB0eVJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbk1hbmFnZXIuZW1wdHlSZWdpb25zKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVtb3ZlcyBhIHJlZ2lvbiBmcm9tIHlvdXIgYXBwLCBieSBuYW1lXG4gICAgLy8gQWNjZXB0cyB0aGUgcmVnaW9ucyBuYW1lXG4gICAgLy8gcmVtb3ZlUmVnaW9uKCdteVJlZ2lvbicpXG4gICAgcmVtb3ZlUmVnaW9uOiBmdW5jdGlvbihyZWdpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25NYW5hZ2VyLnJlbW92ZVJlZ2lvbihyZWdpb24pO1xuICAgIH0sXG4gIFxuICAgIC8vIFByb3ZpZGVzIGFsdGVybmF0aXZlIGFjY2VzcyB0byByZWdpb25zXG4gICAgLy8gQWNjZXB0cyB0aGUgcmVnaW9uIG5hbWVcbiAgICAvLyBnZXRSZWdpb24oJ21haW4nKVxuICAgIGdldFJlZ2lvbjogZnVuY3Rpb24ocmVnaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVnaW9uTWFuYWdlci5nZXQocmVnaW9uKTtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYWxsIHRoZSByZWdpb25zIGZyb20gdGhlIHJlZ2lvbiBtYW5hZ2VyXG4gICAgZ2V0UmVnaW9uczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbnMoKTtcbiAgICB9LFxuICBcbiAgICAvLyBDcmVhdGUgYSBtb2R1bGUsIGF0dGFjaGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgIG1vZHVsZTogZnVuY3Rpb24obW9kdWxlTmFtZXMsIG1vZHVsZURlZmluaXRpb24pIHtcbiAgXG4gICAgICAvLyBPdmVyd3JpdGUgdGhlIG1vZHVsZSBjbGFzcyBpZiB0aGUgdXNlciBzcGVjaWZpZXMgb25lXG4gICAgICB2YXIgTW9kdWxlQ2xhc3MgPSBNYXJpb25ldHRlLk1vZHVsZS5nZXRDbGFzcyhtb2R1bGVEZWZpbml0aW9uKTtcbiAgXG4gICAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICBcbiAgICAgIC8vIHNlZSB0aGUgTWFyaW9uZXR0ZS5Nb2R1bGUgb2JqZWN0IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICByZXR1cm4gTW9kdWxlQ2xhc3MuY3JlYXRlLmFwcGx5KE1vZHVsZUNsYXNzLCBhcmdzKTtcbiAgICB9LFxuICBcbiAgICAvLyBFbmFibGUgZWFzeSBvdmVycmlkaW5nIG9mIHRoZSBkZWZhdWx0IGBSZWdpb25NYW5hZ2VyYFxuICAgIC8vIGZvciBjdXN0b21pemVkIHJlZ2lvbiBpbnRlcmFjdGlvbnMgYW5kIGJ1c2luZXNzLXNwZWNpZmljXG4gICAgLy8gdmlldyBsb2dpYyBmb3IgYmV0dGVyIGNvbnRyb2wgb3ZlciBzaW5nbGUgcmVnaW9ucy5cbiAgICBnZXRSZWdpb25NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIGJlZW4gZGVmaW5lZCBpbiBhXG4gICAgLy8gYHJlZ2lvbnNgIGF0dHJpYnV0ZSBvbiB0aGUgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICBfaW5pdGlhbGl6ZVJlZ2lvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWdpb25zID0gXy5pc0Z1bmN0aW9uKHRoaXMucmVnaW9ucykgPyB0aGlzLnJlZ2lvbnMob3B0aW9ucykgOiB0aGlzLnJlZ2lvbnMgfHwge307XG4gIFxuICAgICAgdGhpcy5faW5pdFJlZ2lvbk1hbmFnZXIoKTtcbiAgXG4gICAgICAvLyBFbmFibGUgdXNlcnMgdG8gZGVmaW5lIGByZWdpb25zYCBpbiBpbnN0YW5jZSBvcHRpb25zLlxuICAgICAgdmFyIG9wdGlvblJlZ2lvbnMgPSBNYXJpb25ldHRlLmdldE9wdGlvbihvcHRpb25zLCAncmVnaW9ucycpO1xuICBcbiAgICAgIC8vIEVuYWJsZSByZWdpb24gb3B0aW9ucyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvblJlZ2lvbnMpKSB7XG4gICAgICAgIG9wdGlvblJlZ2lvbnMgPSBvcHRpb25SZWdpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gT3ZlcndyaXRlIGN1cnJlbnQgcmVnaW9ucyB3aXRoIHRob3NlIHBhc3NlZCBpbiBvcHRpb25zXG4gICAgICBfLmV4dGVuZChyZWdpb25zLCBvcHRpb25SZWdpb25zKTtcbiAgXG4gICAgICB0aGlzLmFkZFJlZ2lvbnMocmVnaW9ucyk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldCB1cCB0aGUgcmVnaW9uIG1hbmFnZXJcbiAgICBfaW5pdFJlZ2lvbk1hbmFnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVnaW9uTWFuYWdlciA9IHRoaXMuZ2V0UmVnaW9uTWFuYWdlcigpO1xuICAgICAgdGhpcy5fcmVnaW9uTWFuYWdlci5fcGFyZW50ID0gdGhpcztcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3JlZ2lvbk1hbmFnZXIsICdiZWZvcmU6YWRkOnJlZ2lvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdiZWZvcmU6YWRkOnJlZ2lvbicsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3JlZ2lvbk1hbmFnZXIsICdhZGQ6cmVnaW9uJywgZnVuY3Rpb24obmFtZSwgcmVnaW9uKSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSByZWdpb247XG4gICAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ2FkZDpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAncmVtb3ZlOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ3JlbW92ZTpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldHVwIHRoZSBXcmVxci5yYWRpbyBjaGFubmVsXG4gICAgX2luaXRDaGFubmVsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBfLnJlc3VsdCh0aGlzLCAnY2hhbm5lbE5hbWUnKSB8fCAnZ2xvYmFsJztcbiAgICAgIHRoaXMuY2hhbm5lbCA9IF8ucmVzdWx0KHRoaXMsICdjaGFubmVsJykgfHwgQmFja2JvbmUuV3JlcXIucmFkaW8uY2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lKTtcbiAgICAgIHRoaXMudmVudCA9IF8ucmVzdWx0KHRoaXMsICd2ZW50JykgfHwgdGhpcy5jaGFubmVsLnZlbnQ7XG4gICAgICB0aGlzLmNvbW1hbmRzID0gXy5yZXN1bHQodGhpcywgJ2NvbW1hbmRzJykgfHwgdGhpcy5jaGFubmVsLmNvbW1hbmRzO1xuICAgICAgdGhpcy5yZXFyZXMgPSBfLnJlc3VsdCh0aGlzLCAncmVxcmVzJykgfHwgdGhpcy5jaGFubmVsLnJlcXJlcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLyoganNoaW50IG1heHBhcmFtczogOSAqL1xuICBcbiAgLy8gTW9kdWxlXG4gIC8vIC0tLS0tLVxuICBcbiAgLy8gQSBzaW1wbGUgbW9kdWxlIHN5c3RlbSwgdXNlZCB0byBjcmVhdGUgcHJpdmFjeSBhbmQgZW5jYXBzdWxhdGlvbiBpblxuICAvLyBNYXJpb25ldHRlIGFwcGxpY2F0aW9uc1xuICBNYXJpb25ldHRlLk1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGFwcCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgLy8gQWxsb3cgZm9yIGEgdXNlciB0byBvdmVyaWRlIHRoZSBpbml0aWFsaXplXG4gICAgLy8gZm9yIGEgZ2l2ZW4gbW9kdWxlIGluc3RhbmNlLlxuICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG9wdGlvbnMuaW5pdGlhbGl6ZSB8fCB0aGlzLmluaXRpYWxpemU7XG4gIFxuICAgIC8vIFNldCB1cCBhbiBpbnRlcm5hbCBzdG9yZSBmb3Igc3ViLW1vZHVsZXMuXG4gICAgdGhpcy5zdWJtb2R1bGVzID0ge307XG4gIFxuICAgIHRoaXMuX3NldHVwSW5pdGlhbGl6ZXJzQW5kRmluYWxpemVycygpO1xuICBcbiAgICAvLyBTZXQgYW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBhcHBcbiAgICAvLyB3aXRoaW4gYSBtb2R1bGUuXG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gIFxuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5pbml0aWFsaXplKSkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKG1vZHVsZU5hbWUsIGFwcCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLk1vZHVsZS5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIEV4dGVuZCB0aGUgTW9kdWxlIHByb3RvdHlwZSB3aXRoIGV2ZW50cyAvIGxpc3RlblRvLCBzbyB0aGF0IHRoZSBtb2R1bGVcbiAgLy8gY2FuIGJlIHVzZWQgYXMgYW4gZXZlbnQgYWdncmVnYXRvciBvciBwdWIvc3ViLlxuICBfLmV4dGVuZChNYXJpb25ldHRlLk1vZHVsZS5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuICBcbiAgICAvLyBCeSBkZWZhdWx0IG1vZHVsZXMgc3RhcnQgd2l0aCB0aGVpciBwYXJlbnRzLlxuICAgIHN0YXJ0V2l0aFBhcmVudDogdHJ1ZSxcbiAgXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiBleHRlbmRpbmcgTWFyaW9uZXR0ZS5Nb2R1bGUuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcbiAgXG4gICAgLy8gSW5pdGlhbGl6ZXIgZm9yIGEgc3BlY2lmaWMgbW9kdWxlLiBJbml0aWFsaXplcnMgYXJlIHJ1biB3aGVuIHRoZVxuICAgIC8vIG1vZHVsZSdzIGBzdGFydGAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICBhZGRJbml0aWFsaXplcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVyQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgfSxcbiAgXG4gICAgLy8gRmluYWxpemVycyBhcmUgcnVuIHdoZW4gYSBtb2R1bGUgaXMgc3RvcHBlZC4gVGhleSBhcmUgdXNlZCB0byB0ZWFyZG93blxuICAgIC8vIGFuZCBmaW5hbGl6ZSBhbnkgdmFyaWFibGVzLCByZWZlcmVuY2VzLCBldmVudHMgYW5kIG90aGVyIGNvZGUgdGhhdCB0aGVcbiAgICAvLyBtb2R1bGUgaGFkIHNldCB1cC5cbiAgICBhZGRGaW5hbGl6ZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9maW5hbGl6ZXJDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICB9LFxuICBcbiAgICAvLyBTdGFydCB0aGUgbW9kdWxlLCBhbmQgcnVuIGFsbCBvZiBpdHMgaW5pdGlhbGl6ZXJzXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtc3RhcnRpbmcgYSBtb2R1bGUgdGhhdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIHN0YXJ0IHRoZSBzdWItbW9kdWxlcyAoZGVwdGgtZmlyc3QgaGllcmFyY2h5KVxuICAgICAgXy5lYWNoKHRoaXMuc3VibW9kdWxlcywgZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgc3RhcnQgdGhlIHN1Yi1tb2R1bGUgd2l0aCB0aGlzIHBhcmVudFxuICAgICAgICBpZiAobW9kLnN0YXJ0V2l0aFBhcmVudCkge1xuICAgICAgICAgIG1vZC5zdGFydChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIFxuICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja3MgdG8gXCJzdGFydFwiIHRoZSBjdXJyZW50IG1vZHVsZVxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3RhcnQnLCBvcHRpb25zKTtcbiAgXG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcy5ydW4ob3B0aW9ucywgdGhpcyk7XG4gICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N0YXJ0Jywgb3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gU3RvcCB0aGlzIG1vZHVsZSBieSBydW5uaW5nIGl0cyBmaW5hbGl6ZXJzIGFuZCB0aGVuIHN0b3AgYWxsIG9mXG4gICAgLy8gdGhlIHN1Yi1tb2R1bGVzIGZvciB0aGlzIG1vZHVsZVxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgYXJlIG5vdCBpbml0aWFsaXplZCwgZG9uJ3QgYm90aGVyIGZpbmFsaXppbmdcbiAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzdG9wJyk7XG4gIFxuICAgICAgLy8gc3RvcCB0aGUgc3ViLW1vZHVsZXM7IGRlcHRoLWZpcnN0LCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBzdWItbW9kdWxlcyBhcmUgc3RvcHBlZCAvIGZpbmFsaXplZCBiZWZvcmUgcGFyZW50c1xuICAgICAgXy5pbnZva2UodGhpcy5zdWJtb2R1bGVzLCAnc3RvcCcpO1xuICBcbiAgICAgIC8vIHJ1biB0aGUgZmluYWxpemVyc1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzLnJ1bih1bmRlZmluZWQsIHRoaXMpO1xuICBcbiAgICAgIC8vIHJlc2V0IHRoZSBpbml0aWFsaXplcnMgYW5kIGZpbmFsaXplcnNcbiAgICAgIHRoaXMuX2luaXRpYWxpemVyQ2FsbGJhY2tzLnJlc2V0KCk7XG4gICAgICB0aGlzLl9maW5hbGl6ZXJDYWxsYmFja3MucmVzZXQoKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N0b3AnKTtcbiAgICB9LFxuICBcbiAgICAvLyBDb25maWd1cmUgdGhlIG1vZHVsZSB3aXRoIGEgZGVmaW5pdGlvbiBmdW5jdGlvbiBhbmQgYW55IGN1c3RvbSBhcmdzXG4gICAgLy8gdGhhdCBhcmUgdG8gYmUgcGFzc2VkIGluIHRvIHRoZSBkZWZpbml0aW9uIGZ1bmN0aW9uXG4gICAgYWRkRGVmaW5pdGlvbjogZnVuY3Rpb24obW9kdWxlRGVmaW5pdGlvbiwgY3VzdG9tQXJncykge1xuICAgICAgdGhpcy5fcnVuTW9kdWxlRGVmaW5pdGlvbihtb2R1bGVEZWZpbml0aW9uLCBjdXN0b21BcmdzKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2Q6IHJ1biB0aGUgbW9kdWxlIGRlZmluaXRpb24gZnVuY3Rpb24gd2l0aCB0aGUgY29ycmVjdFxuICAgIC8vIGFyZ3VtZW50c1xuICAgIF9ydW5Nb2R1bGVEZWZpbml0aW9uOiBmdW5jdGlvbihkZWZpbml0aW9uLCBjdXN0b21BcmdzKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBkZWZpbml0aW9uIHNob3J0IGNpcmN1dCB0aGUgbWV0aG9kLlxuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIGJ1aWxkIHRoZSBjb3JyZWN0IGxpc3Qgb2YgYXJndW1lbnRzIGZvciB0aGUgbW9kdWxlIGRlZmluaXRpb25cbiAgICAgIHZhciBhcmdzID0gXy5mbGF0dGVuKFtcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgIEJhY2tib25lLFxuICAgICAgICBNYXJpb25ldHRlLFxuICAgICAgICBCYWNrYm9uZS4kLCBfLFxuICAgICAgICBjdXN0b21BcmdzXG4gICAgICBdKTtcbiAgXG4gICAgICBkZWZpbml0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZDogc2V0IHVwIG5ldyBjb3BpZXMgb2YgaW5pdGlhbGl6ZXJzIGFuZCBmaW5hbGl6ZXJzLlxuICAgIC8vIENhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCB3aXBlIG91dCBhbGwgZXhpc3RpbmcgaW5pdGlhbGl6ZXJzIGFuZFxuICAgIC8vIGZpbmFsaXplcnMuXG4gICAgX3NldHVwSW5pdGlhbGl6ZXJzQW5kRmluYWxpemVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcyA9IG5ldyBNYXJpb25ldHRlLkNhbGxiYWNrcygpO1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzID0gbmV3IE1hcmlvbmV0dGUuQ2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gaW1wb3J0IHRoZSBgdHJpZ2dlck1ldGhvZGAgdG8gdHJpZ2dlciBldmVudHMgd2l0aCBjb3JyZXNwb25kaW5nXG4gICAgLy8gbWV0aG9kcyBpZiB0aGUgbWV0aG9kIGV4aXN0c1xuICAgIHRyaWdnZXJNZXRob2Q6IE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZFxuICB9KTtcbiAgXG4gIC8vIENsYXNzIG1ldGhvZHMgdG8gY3JlYXRlIG1vZHVsZXNcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5Nb2R1bGUsIHtcbiAgXG4gICAgLy8gQ3JlYXRlIGEgbW9kdWxlLCBoYW5naW5nIG9mZiB0aGUgYXBwIHBhcmFtZXRlciBhcyB0aGUgcGFyZW50IG9iamVjdC5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGFwcCwgbW9kdWxlTmFtZXMsIG1vZHVsZURlZmluaXRpb24pIHtcbiAgICAgIHZhciBtb2R1bGUgPSBhcHA7XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBjdXN0b20gYXJncyBwYXNzZWQgaW4gYWZ0ZXIgdGhlIG1vZHVsZSBkZWZpbml0aW9uIGFuZFxuICAgICAgLy8gZ2V0IHJpZCBvZiB0aGUgbW9kdWxlIG5hbWUgYW5kIGRlZmluaXRpb24gZnVuY3Rpb25cbiAgICAgIHZhciBjdXN0b21BcmdzID0gXy5yZXN0KGFyZ3VtZW50cywgMyk7XG4gIFxuICAgICAgLy8gU3BsaXQgdGhlIG1vZHVsZSBuYW1lcyBhbmQgZ2V0IHRoZSBudW1iZXIgb2Ygc3VibW9kdWxlcy5cbiAgICAgIC8vIGkuZS4gYW4gZXhhbXBsZSBtb2R1bGUgbmFtZSBvZiBgRG9nZS5Xb3cuQW1hemVgIHdvdWxkXG4gICAgICAvLyB0aGVuIGhhdmUgdGhlIHBvdGVudGlhbCBmb3IgMyBtb2R1bGUgZGVmaW5pdGlvbnMuXG4gICAgICBtb2R1bGVOYW1lcyA9IG1vZHVsZU5hbWVzLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbW9kdWxlTmFtZXMubGVuZ3RoO1xuICBcbiAgICAgIC8vIHN0b3JlIHRoZSBtb2R1bGUgZGVmaW5pdGlvbiBmb3IgdGhlIGxhc3QgbW9kdWxlIGluIHRoZSBjaGFpblxuICAgICAgdmFyIG1vZHVsZURlZmluaXRpb25zID0gW107XG4gICAgICBtb2R1bGVEZWZpbml0aW9uc1tsZW5ndGggLSAxXSA9IG1vZHVsZURlZmluaXRpb247XG4gIFxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgcGFydHMgb2YgdGhlIG1vZHVsZSBkZWZpbml0aW9uXG4gICAgICBfLmVhY2gobW9kdWxlTmFtZXMsIGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGkpIHtcbiAgICAgICAgdmFyIHBhcmVudE1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgbW9kdWxlID0gdGhpcy5fZ2V0TW9kdWxlKHBhcmVudE1vZHVsZSwgbW9kdWxlTmFtZSwgYXBwLCBtb2R1bGVEZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5fYWRkTW9kdWxlRGVmaW5pdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZSwgbW9kdWxlRGVmaW5pdGlvbnNbaV0sIGN1c3RvbUFyZ3MpO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgLy8gUmV0dXJuIHRoZSBsYXN0IG1vZHVsZSBpbiB0aGUgZGVmaW5pdGlvbiBjaGFpblxuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9LFxuICBcbiAgICBfZ2V0TW9kdWxlOiBmdW5jdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZU5hbWUsIGFwcCwgZGVmLCBhcmdzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkZWYpO1xuICAgICAgdmFyIE1vZHVsZUNsYXNzID0gdGhpcy5nZXRDbGFzcyhkZWYpO1xuICBcbiAgICAgIC8vIEdldCBhbiBleGlzdGluZyBtb2R1bGUgb2YgdGhpcyBuYW1lIGlmIHdlIGhhdmUgb25lXG4gICAgICB2YXIgbW9kdWxlID0gcGFyZW50TW9kdWxlW21vZHVsZU5hbWVdO1xuICBcbiAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgaWYgd2UgZG9uJ3QgaGF2ZSBvbmVcbiAgICAgICAgbW9kdWxlID0gbmV3IE1vZHVsZUNsYXNzKG1vZHVsZU5hbWUsIGFwcCwgb3B0aW9ucyk7XG4gICAgICAgIHBhcmVudE1vZHVsZVttb2R1bGVOYW1lXSA9IG1vZHVsZTtcbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vZHVsZSBvbiB0aGUgcGFyZW50XG4gICAgICAgIHBhcmVudE1vZHVsZS5zdWJtb2R1bGVzW21vZHVsZU5hbWVdID0gbW9kdWxlO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfSxcbiAgXG4gICAgLy8gIyMgTW9kdWxlIENsYXNzZXNcbiAgICAvL1xuICAgIC8vIE1vZHVsZSBjbGFzc2VzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZpbmUgcGF0dGVybi5cbiAgICAvLyBUaGUgZXh0ZW5kIGZ1bmN0aW9uIG9mIGEgTW9kdWxlIGlzIGlkZW50aWNhbCB0byB0aGUgZXh0ZW5kIGZ1bmN0aW9uc1xuICAgIC8vIG9uIG90aGVyIEJhY2tib25lIGFuZCBNYXJpb25ldHRlIGNsYXNzZXMuXG4gICAgLy8gVGhpcyBhbGxvd3MgbW9kdWxlIGxpZmVjeWxlIGV2ZW50cyBsaWtlIGBvblN0YXJ0YCBhbmQgYG9uU3RvcGAgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LlxuICAgIGdldENsYXNzOiBmdW5jdGlvbihtb2R1bGVEZWZpbml0aW9uKSB7XG4gICAgICB2YXIgTW9kdWxlQ2xhc3MgPSBNYXJpb25ldHRlLk1vZHVsZTtcbiAgXG4gICAgICBpZiAoIW1vZHVsZURlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE1vZHVsZUNsYXNzO1xuICAgICAgfVxuICBcbiAgICAgIC8vIElmIGFsbCBvZiB0aGUgbW9kdWxlJ3MgZnVuY3Rpb25hbGl0eSBpcyBkZWZpbmVkIGluc2lkZSBpdHMgY2xhc3MsXG4gICAgICAvLyB0aGVuIHRoZSBjbGFzcyBjYW4gYmUgcGFzc2VkIGluIGRpcmVjdGx5LiBgTXlBcHAubW9kdWxlKFwiRm9vXCIsIEZvb01vZHVsZSlgLlxuICAgICAgaWYgKG1vZHVsZURlZmluaXRpb24ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kdWxlQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb247XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb24ubW9kdWxlQ2xhc3MgfHwgTW9kdWxlQ2xhc3M7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIHRoZSBtb2R1bGUgZGVmaW5pdGlvbiBhbmQgYWRkIGEgc3RhcnRXaXRoUGFyZW50IGluaXRpYWxpemVyIGZ1bmN0aW9uLlxuICAgIC8vIFRoaXMgaXMgY29tcGxpY2F0ZWQgYmVjYXVzZSBtb2R1bGUgZGVmaW5pdGlvbnMgYXJlIGhlYXZpbHkgb3ZlcmxvYWRlZFxuICAgIC8vIGFuZCBzdXBwb3J0IGFuIGFub255bW91cyBmdW5jdGlvbiwgbW9kdWxlIGNsYXNzLCBvciBvcHRpb25zIG9iamVjdFxuICAgIF9hZGRNb2R1bGVEZWZpbml0aW9uOiBmdW5jdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZSwgZGVmLCBhcmdzKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLl9nZXREZWZpbmUoZGVmKTtcbiAgICAgIHZhciBzdGFydFdpdGhQYXJlbnQgPSB0aGlzLl9nZXRTdGFydFdpdGhQYXJlbnQoZGVmLCBtb2R1bGUpO1xuICBcbiAgICAgIGlmIChmbikge1xuICAgICAgICBtb2R1bGUuYWRkRGVmaW5pdGlvbihmbiwgYXJncyk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fYWRkU3RhcnRXaXRoUGFyZW50KHBhcmVudE1vZHVsZSwgbW9kdWxlLCBzdGFydFdpdGhQYXJlbnQpO1xuICAgIH0sXG4gIFxuICAgIF9nZXRTdGFydFdpdGhQYXJlbnQ6IGZ1bmN0aW9uKGRlZiwgbW9kdWxlKSB7XG4gICAgICB2YXIgc3dwO1xuICBcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmKSAmJiAoZGVmLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1hcmlvbmV0dGUuTW9kdWxlKSkge1xuICAgICAgICBzd3AgPSBtb2R1bGUuY29uc3RydWN0b3IucHJvdG90eXBlLnN0YXJ0V2l0aFBhcmVudDtcbiAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQoc3dwKSA/IHRydWUgOiBzd3A7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF8uaXNPYmplY3QoZGVmKSkge1xuICAgICAgICBzd3AgPSBkZWYuc3RhcnRXaXRoUGFyZW50O1xuICAgICAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChzd3ApID8gdHJ1ZSA6IHN3cDtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICBcbiAgICBfZ2V0RGVmaW5lOiBmdW5jdGlvbihkZWYpIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmKSAmJiAhKGRlZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNYXJpb25ldHRlLk1vZHVsZSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoXy5pc09iamVjdChkZWYpKSB7XG4gICAgICAgIHJldHVybiBkZWYuZGVmaW5lO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gIFxuICAgIF9hZGRTdGFydFdpdGhQYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudE1vZHVsZSwgbW9kdWxlLCBzdGFydFdpdGhQYXJlbnQpIHtcbiAgICAgIG1vZHVsZS5zdGFydFdpdGhQYXJlbnQgPSBtb2R1bGUuc3RhcnRXaXRoUGFyZW50ICYmIHN0YXJ0V2l0aFBhcmVudDtcbiAgXG4gICAgICBpZiAoIW1vZHVsZS5zdGFydFdpdGhQYXJlbnQgfHwgISFtb2R1bGUuc3RhcnRXaXRoUGFyZW50SXNDb25maWd1cmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgXG4gICAgICBtb2R1bGUuc3RhcnRXaXRoUGFyZW50SXNDb25maWd1cmVkID0gdHJ1ZTtcbiAgXG4gICAgICBwYXJlbnRNb2R1bGUuYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAobW9kdWxlLnN0YXJ0V2l0aFBhcmVudCkge1xuICAgICAgICAgIG1vZHVsZS5zdGFydChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgXG5cbiAgcmV0dXJuIE1hcmlvbmV0dGU7XG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWNrYm9uZS5tYXJpb25ldHRlL2xpYi9jb3JlL2JhY2tib25lLm1hcmlvbmV0dGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIiLCJmaWxlIjoiMjMuanMifQ==");

/***/ },
/* 24 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = jQuery;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj8wY2I4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImpRdWVyeVwiXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */
/*!****************************************************************!*\
  !*** ./~/bootstrap-sass/assets/javascripts/bootstrap/modal.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* ========================================================================\n * Bootstrap: modal.js v3.3.1\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options        = options\n    this.$body          = $(document.body)\n    this.$element       = $(element)\n    this.$backdrop      =\n    this.isShown        = null\n    this.scrollbarWidth = 0\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.1'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      if (that.options.backdrop) that.adjustBackdrop()\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element\n        .addClass('in')\n        .attr('aria-hidden', false)\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$element.find('.modal-dialog') // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .attr('aria-hidden', true)\n      .off('click.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n        .prependTo(this.$element)\n        .on('click.dismiss.bs.modal', $.proxy(function (e) {\n          if (e.target !== e.currentTarget) return\n          this.options.backdrop == 'static'\n            ? this.$element[0].focus.call(this.$element[0])\n            : this.hide.call(this)\n        }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    if (this.options.backdrop) this.adjustBackdrop()\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustBackdrop = function () {\n    this.$backdrop\n      .css('height', 0)\n      .css('height', this.$element[0].scrollHeight)\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', '')\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvbW9kYWwuanM/MDg3YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0NBQWdDOztBQUV6RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxnQ0FBZ0M7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQ0FBa0M7O0FBRXBHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBtb2RhbC5qcyB2My4zLjFcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI21vZGFsc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIE1PREFMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLiRib2R5ICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICA9XG4gICAgdGhpcy5pc1Nob3duICAgICAgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gMFxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBNb2RhbC5WRVJTSU9OICA9ICczLjMuMSdcblxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBNb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgaWYgKHRoYXQub3B0aW9ucy5iYWNrZHJvcCkgdGhhdC5hZGp1c3RCYWNrZHJvcCgpXG4gICAgICB0aGF0LmFkanVzdERpYWxvZygpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdpbicpXG4gICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKSAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKCdmb2N1c2luLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnaW4nKVxuICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVNb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldCAmJiAhdGhpcy4kZWxlbWVudC5oYXMoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS53aGljaCA9PSAyNyAmJiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbigncmVzaXplLmJzLm1vZGFsJywgJC5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSwgdGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJCgnPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlICsgJ1wiIC8+JylcbiAgICAgICAgLnByZXBlbmRUbyh0aGlzLiRlbGVtZW50KVxuICAgICAgICAub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzLmNhbGwodGhpcy4kZWxlbWVudFswXSlcbiAgICAgICAgICAgIDogdGhpcy5oaWRlLmNhbGwodGhpcylcbiAgICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBNb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHRoaXMuYWRqdXN0QmFja2Ryb3AoKVxuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5hZGp1c3RCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgLmNzcygnaGVpZ2h0JywgMClcbiAgICAgIC5jc3MoJ2hlaWdodCcsIHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kYWxJc092ZXJmbG93aW5nID0gdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogICF0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmIG1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgaWYgKHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCAnJylcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xuICAgIHRoaXMuJGJvZHkuYXBwZW5kKHNjcm9sbERpdilcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG5cbiAgLy8gTU9EQUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uLCBfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLm1vZGFsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLm1vZGFsJywgKGRhdGEgPSBuZXcgTW9kYWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5tb2RhbFxuXG4gICQuZm4ubW9kYWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuICAvLyBNT0RBTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ubW9kYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLm1vZGFsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMubW9kYWwuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciBocmVmICAgID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYm9vdHN0cmFwLXNhc3MvYXNzZXRzL2phdmFzY3JpcHRzL2Jvb3RzdHJhcC9tb2RhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIzMC5qcyJ9");

/***/ },
/* 31 */
/*!******************************************************************!*\
  !*** ./~/bootstrap-sass/assets/javascripts/bootstrap/tooltip.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* ========================================================================\n * Bootstrap: tooltip.js v3.3.1\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       =\n    this.options    =\n    this.enabled    =\n    this.timeout    =\n    this.hoverState =\n    this.$element   = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.1'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (self && self.$tip && self.$tip.is(':visible')) {\n      self.hoverState = 'in'\n      return\n    }\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()\n        var containerDim = this.getPosition($container)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  = offset.top  + marginTop\n    offset.left = offset.left + marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {\n    this.arrow()\n      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isHorizontal ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = this.tip()\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      that.$element\n        .removeAttr('aria-describedby')\n        .trigger('hidden.bs.' + that.type)\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && this.$tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    return (this.$tip = this.$tip || $(this.options.template))\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this    = $(this)\n      var data     = $this.data('bs.tooltip')\n      var options  = typeof option == 'object' && option\n      var selector = options && options.selector\n\n      if (!data && option == 'destroy') return\n      if (selector) {\n        if (!data) $this.data('bs.tooltip', (data = {}))\n        if (!data[selector]) data[selector] = new Tooltip(this, options)\n      } else {\n        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      }\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvdG9vbHRpcC5qcz85Y2Y5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLEtBQUs7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLGlCQUFpQixrQ0FBa0M7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSwwQkFBMEIsV0FBVyx3RUFBd0U7QUFDN0c7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hELHFCQUFxQjtBQUNyQiw4QkFBOEIsdURBQXVEOztBQUVyRixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxvQ0FBb0MsaUZBQWlGO0FBQ3JILG9DQUFvQyxpRkFBaUY7QUFDckgsb0NBQW9DLGlGQUFpRjtBQUNySCxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsT0FBTyxrRkFBa0Y7QUFDekY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsT0FBTyx1REFBdUQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdG9vbHRpcC5qcyB2My4zLjFcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Rvb2x0aXBcbiAqIEluc3BpcmVkIGJ5IHRoZSBvcmlnaW5hbCBqUXVlcnkudGlwc3kgYnkgSmFzb24gRnJhbWVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUT09MVElQIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlICAgICAgID1cbiAgICB0aGlzLm9wdGlvbnMgICAgPVxuICAgIHRoaXMuZW5hYmxlZCAgICA9XG4gICAgdGhpcy50aW1lb3V0ICAgID1cbiAgICB0aGlzLmhvdmVyU3RhdGUgPVxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy4xJ1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpXG5cbiAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICBmb3IgKHZhciBpID0gdHJpZ2dlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgdHJpZ2dlciA9IHRyaWdnZXJzW2ldXG5cbiAgICAgIGlmICh0cmlnZ2VyID09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMudG9nZ2xlLCB0aGlzKSlcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPSAnbWFudWFsJykge1xuICAgICAgICB2YXIgZXZlbnRJbiAgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VlbnRlcicgOiAnZm9jdXNpbidcbiAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlbGVhdmUnIDogJ2ZvY3Vzb3V0J1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRJbiAgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmVudGVyLCB0aGlzKSlcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudE91dCArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMubGVhdmUsIHRoaXMpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA/XG4gICAgICAodGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHsgdHJpZ2dlcjogJ21hbnVhbCcsIHNlbGVjdG9yOiAnJyB9KSkgOlxuICAgICAgdGhpcy5maXhUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVG9vbHRpcC5ERUZBVUxUU1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmdldERlZmF1bHRzKCksIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgPT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGhpZGU6IG9wdGlvbnMuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVsZWdhdGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zICA9IHt9XG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5nZXREZWZhdWx0cygpXG5cbiAgICB0aGlzLl9vcHRpb25zICYmICQuZWFjaCh0aGlzLl9vcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGRlZmF1bHRzW2tleV0gIT0gdmFsdWUpIG9wdGlvbnNba2V5XSA9IHZhbHVlXG4gICAgfSlcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmIChzZWxmICYmIHNlbGYuJHRpcCAmJiBzZWxmLiR0aXAuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcblxuICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdvdXQnXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpIHJldHVybiBzZWxmLmhpZGUoKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdvdXQnKSBzZWxmLmhpZGUoKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5oaWRlKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3cuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICh0aGlzLmhhc0NvbnRlbnQoKSAmJiB0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICB2YXIgaW5Eb20gPSAkLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuJGVsZW1lbnRbMF0pXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaW5Eb20pIHJldHVyblxuICAgICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuXG4gICAgICB2YXIgdGlwSWQgPSB0aGlzLmdldFVJRCh0aGlzLnR5cGUpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG4gICAgICAkdGlwLmF0dHIoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pICR0aXAuYWRkQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnRcblxuICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2lcbiAgICAgIHZhciBhdXRvUGxhY2UgPSBhdXRvVG9rZW4udGVzdChwbGFjZW1lbnQpXG4gICAgICBpZiAoYXV0b1BsYWNlKSBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJ1xuXG4gICAgICAkdGlwXG4gICAgICAgIC5kZXRhY2goKVxuICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pXG4gICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICAgIC5kYXRhKCdicy4nICsgdGhpcy50eXBlLCB0aGlzKVxuXG4gICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gJHRpcC5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSA6ICR0aXAuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudClcblxuICAgICAgdmFyIHBvcyAgICAgICAgICA9IHRoaXMuZ2V0UG9zaXRpb24oKVxuICAgICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRcbiAgICAgICAgdmFyICRjb250YWluZXIgICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogdGhpcy4kZWxlbWVudC5wYXJlbnQoKVxuICAgICAgICB2YXIgY29udGFpbmVyRGltID0gdGhpcy5nZXRQb3NpdGlvbigkY29udGFpbmVyKVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gY29udGFpbmVyRGltLmJvdHRvbSA/ICd0b3AnICAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgICYmIHBvcy50b3AgICAgLSBhY3R1YWxIZWlnaHQgPCBjb250YWluZXJEaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IGNvbnRhaW5lckRpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgY29udGFpbmVyRGltLmxlZnQgICA/ICdyaWdodCcgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50XG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpXG5cbiAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KVxuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IHRoYXQuaG92ZXJTdGF0ZVxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICAgIHRoYXQuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT0gJ291dCcpIHRoYXQubGVhdmUodGhhdClcbiAgICAgIH1cblxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kdGlwLmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICAkdGlwXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwbGFjZW1lbnQpIHtcbiAgICB2YXIgJHRpcCAgID0gdGhpcy50aXAoKVxuICAgIHZhciB3aWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgdmFyIGhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAvLyBtYW51YWxseSByZWFkIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaW5jbHVkZXMgZGlmZmVyZW5jZVxuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLXRvcCcpLCAxMClcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMClcblxuICAgIC8vIHdlIG11c3QgY2hlY2sgZm9yIE5hTiBmb3IgaWUgOC85XG4gICAgaWYgKGlzTmFOKG1hcmdpblRvcCkpICBtYXJnaW5Ub3AgID0gMFxuICAgIGlmIChpc05hTihtYXJnaW5MZWZ0KSkgbWFyZ2luTGVmdCA9IDBcblxuICAgIG9mZnNldC50b3AgID0gb2Zmc2V0LnRvcCAgKyBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCA9IG9mZnNldC5sZWZ0ICsgbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNIb3Jpem9udGFsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnLCA1MCAqICgxIC0gZGVsdGEgLyBkaW1lbnNpb24pICsgJyUnKVxuICAgICAgLmNzcyhpc0hvcml6b250YWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgIHZhciBlICAgID0gJC5FdmVudCgnaGlkZS5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhhdC5ob3ZlclN0YXRlICE9ICdpbicpICR0aXAuZGV0YWNoKClcbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAudHJpZ2dlcignaGlkZGVuLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAoJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiAgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgIH0gOlxuICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgPyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgLSBhY3R1YWxXaWR0aCB9IDpcbiAgICAgICAgLyogcGxhY2VtZW50ID09ICdyaWdodCcgKi8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoICAgfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJHRpcCA9IHRoaXMuJHRpcCB8fCAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgPyBzZWxmLmxlYXZlKHNlbGYpIDogc2VsZi5lbnRlcihzZWxmKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gVE9PTFRJUCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyAgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuICAgICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlbGVjdG9yXG5cbiAgICAgIGlmICghZGF0YSAmJiBvcHRpb24gPT0gJ2Rlc3Ryb3knKSByZXR1cm5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IHt9KSlcbiAgICAgICAgaWYgKCFkYXRhW3NlbGVjdG9yXSkgZGF0YVtzZWxlY3Rvcl0gPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvdG9vbHRpcC5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIzMS5qcyJ9");

/***/ },
/* 32 */
/*!******************************************************************!*\
  !*** ./~/bootstrap-sass/assets/javascripts/bootstrap/popover.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* ========================================================================\n * Bootstrap: popover.js v3.3.1\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.1'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n  Popover.prototype.tip = function () {\n    if (!this.$tip) this.$tip = $(this.options.template)\n    return this.$tip\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this    = $(this)\n      var data     = $this.data('bs.popover')\n      var options  = typeof option == 'object' && option\n      var selector = options && options.selector\n\n      if (!data && option == 'destroy') return\n      if (selector) {\n        if (!data) $this.data('bs.popover', (data = {}))\n        if (!data[selector]) data[selector] = new Popover(this, options)\n      } else {\n        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      }\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvcG9wb3Zlci5qcz81OWRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy4xXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy4xJ1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cblxuICAvLyBQT1BPVkVSIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zICA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG4gICAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3JcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbiA9PSAnZGVzdHJveScpIHJldHVyblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0ge30pKVxuICAgICAgICBpZiAoIWRhdGFbc2VsZWN0b3JdKSBkYXRhW3NlbGVjdG9yXSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYm9vdHN0cmFwLXNhc3MvYXNzZXRzL2phdmFzY3JpcHRzL2Jvb3RzdHJhcC9wb3BvdmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjMyLmpzIn0=");

/***/ },
/* 33 */
/*!*********************************************************************!*\
  !*** ./~/bootstrap-sass/assets/javascripts/bootstrap/transition.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* ========================================================================\n * Bootstrap: transition.js v3.3.1\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvdHJhbnNpdGlvbi5qcz82MzBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuMVxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvdHJhbnNpdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiIzMy5qcyJ9");

/***/ },
/* 34 */
/*!*******************************************************************!*\
  !*** ./~/bootstrap-sass/assets/javascripts/bootstrap/dropdown.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* ========================================================================\n * Bootstrap: dropdown.js v3.3.1\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.1'\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $('<div class=\"dropdown-backdrop\"/>').insertAfter($(this)).on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger('shown.bs.dropdown', relatedTarget)\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.divider):visible a'\n    var $items = $parent.find('[role=\"menu\"]' + desc + ', [role=\"listbox\"]' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--                        // up\n    if (e.which == 40 && index < $items.length - 1) index++                        // down\n    if (!~index)                                      index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)\n    })\n  }\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"menu\"]', Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"listbox\"]', Dropdown.prototype.keydown)\n\n}(jQuery);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jvb3RzdHJhcC1zYXNzL2Fzc2V0cy9qYXZhc2NyaXB0cy9ib290c3RyYXAvZHJvcGRvd24uanM/ODE4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxzQkFBc0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjFcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuMSdcblxuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgY2xlYXJNZW51cygpXG5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIG1vYmlsZSB3ZSB1c2UgYSBiYWNrZHJvcCBiZWNhdXNlIGNsaWNrIGV2ZW50cyBkb24ndCBkZWxlZ2F0ZVxuICAgICAgICAkKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tYmFja2Ryb3BcIi8+JykuaW5zZXJ0QWZ0ZXIoJCh0aGlzKSkub24oJ2NsaWNrJywgY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdzaG93LmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXNcbiAgICAgICAgLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpXG5cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRvZ2dsZUNsYXNzKCdvcGVuJylcbiAgICAgICAgLnRyaWdnZXIoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGUud2hpY2gpIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuXG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGlmICgoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcpIHx8IChpc0FjdGl2ZSAmJiBlLndoaWNoID09IDI3KSkge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGl2aWRlcik6dmlzaWJsZSBhJ1xuICAgIHZhciAkaXRlbXMgPSAkcGFyZW50LmZpbmQoJ1tyb2xlPVwibWVudVwiXScgKyBkZXNjICsgJywgW3JvbGU9XCJsaXN0Ym94XCJdJyArIGRlc2MpXG5cbiAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGluZGV4ID0gJGl0ZW1zLmluZGV4KGUudGFyZ2V0KVxuXG4gICAgaWYgKGUud2hpY2ggPT0gMzggJiYgaW5kZXggPiAwKSAgICAgICAgICAgICAgICAgaW5kZXgtLSAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwXG4gICAgaWYgKGUud2hpY2ggPT0gNDAgJiYgaW5kZXggPCAkaXRlbXMubGVuZ3RoIC0gMSkgaW5kZXgrKyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd25cbiAgICBpZiAoIX5pbmRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuXG4gICAgJGl0ZW1zLmVxKGluZGV4KS50cmlnZ2VyKCdmb2N1cycpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdoaWRlLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdvcGVuJykudHJpZ2dlcignaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KCR0aGlzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgLyNbQS1aYS16XS8udGVzdChzZWxlY3RvcikgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICB2YXIgJHBhcmVudCA9IHNlbGVjdG9yICYmICQoc2VsZWN0b3IpXG5cbiAgICByZXR1cm4gJHBhcmVudCAmJiAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkdGhpcy5wYXJlbnQoKVxuICB9XG5cblxuICAvLyBEUk9QRE9XTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicsIChkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uZHJvcGRvd25cblxuICAkLmZuLmRyb3Bkb3duICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuXG5cbiAgLy8gRFJPUERPV04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5kcm9wZG93biA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFQUExZIFRPIFNUQU5EQVJEIERST1BET1dOIEVMRU1FTlRTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgY2xlYXJNZW51cylcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93biBmb3JtJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUpXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnW3JvbGU9XCJtZW51XCJdJywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJ1tyb2xlPVwibGlzdGJveFwiXScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuXG59KGpRdWVyeSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ib290c3RyYXAtc2Fzcy9hc3NldHMvamF2YXNjcmlwdHMvYm9vdHN0cmFwL2Ryb3Bkb3duLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIiwiZmlsZSI6IjM0LmpzIn0=");

/***/ },
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */
/*!**************************************************!*\
  !*** ./~/backbone.radio/build/backbone.radio.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Backbone.Radio v0.8.4\n(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ 1), __webpack_require__(/*! underscore */ 2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {\n      return factory(Backbone, _);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  else if (typeof exports !== 'undefined') {\n    var Backbone = require('backbone');\n    var _ = require('underscore');\n    module.exports = factory(Backbone, _);\n  }\n  else {\n    factory(root.Backbone, root._);\n  }\n}(this, function(Backbone, _) {\n  'use strict';\n\n  var previousRadio = Backbone.Radio;\n  \n  var Radio = Backbone.Radio = {};\n  \n  Radio.VERSION = '0.8.4';\n  \n  // This allows you to run multiple instances of Radio on the same\n  // webapp. After loading the new version, call `noConflict()` to\n  // get a reference to it. At the same time the old version will be\n  // returned to Backbone.Radio.\n  Radio.noConflict = function () {\n    Backbone.Radio = previousRadio;\n    return this;\n  };\n  \n  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you\n  // get around the issues of lack of warnings when events are mis-typed.\n  Radio.DEBUG = false;\n  \n  // This is the method that's called when an unregistered event was called.\n  // By default, it logs warning to the console. By overriding this you could\n  // make it throw an Error, for instance. This would make firing a nonexistent event\n  // have the same consequence as firing a nonexistent method on an Object.\n  function debugLog(warning, eventName, channelName) {\n    if (!Radio.DEBUG) { return; }\n    var channelText = channelName ? ' on the ' + channelName + ' channel' : '';\n    if (console && console.warn) {\n      console.warn(warning + channelText + ': \"' + eventName + '\"');\n    }\n  }\n  \n  var eventSplitter = /\\s+/;\n  \n  // An internal method used to handle Radio's method overloading for Requests and\n  // Commands. It's borrowed from Backbone.Events. It differs from Backbone's overload\n  // API (which is used in Backbone.Events) in that it doesn't support space-separated\n  // event names.\n  function eventsApi(obj, action, name, rest) {\n    if (!name) {\n      return false;\n    }\n  \n    var results = [];\n  \n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        results.push(obj[action].apply(obj, [key, name[key]].concat(rest)));\n      }\n      return results;\n    }\n  \n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        results.push(obj[action].apply(obj, [names[i]].concat(rest)));\n      }\n      return results;\n    }\n  \n    return false;\n  }\n  \n  // An optimized way to execute callbacks.\n  function callHandler(callback, context, args) {\n    var a1 = args[0], a2 = args[1], a3 = args[2];\n    switch(args.length) {\n      case 0: return callback.call(context);\n      case 1: return callback.call(context, a1);\n      case 2: return callback.call(context, a1, a2);\n      case 3: return callback.call(context, a1, a2, a3);\n      default: return callback.apply(context, args);\n    }\n  }\n  \n  // A helper used by `off` methods to the handler from the store\n  function removeHandler(store, name, callback, context) {\n    var event = store[name];\n    if (\n       (!callback || (callback === event.callback || callback === event.callback._callback)) &&\n       (!context || (context === event.context))\n    ) {\n      delete store[name];\n      return true;\n    }\n  }\n  \n  function removeHandlers(store, name, callback, context) {\n    store || (store = {});\n    var names = name ? [name] : _.keys(store);\n    var matched = false;\n  \n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n  \n      // If there's no event by this name, log it and continue\n      // with the loop\n      if (!store[name]) {\n        continue;\n      }\n  \n      if (removeHandler(store, name, callback, context)) {\n        matched = true;\n      }\n    }\n  \n    return matched;\n  }\n  \n  /*\n   * tune-in\n   * -------\n   * Get console logs of a channel's activity\n   *\n   */\n  \n  var _logs = {};\n  \n  // This is to produce an identical function in both tuneIn and tuneOut,\n  // so that Backbone.Events unregisters it.\n  function _partial(channelName) {\n    return _logs[channelName] || (_logs[channelName] = _.partial(Radio.log, channelName));\n  }\n  \n  _.extend(Radio, {\n  \n    // Log information about the channel and event\n    log: function(channelName, eventName) {\n      var args = _.rest(arguments, 2);\n      console.log('[' + channelName + '] \"' + eventName + '\"', args);\n    },\n  \n    // Logs all events on this channel to the console. It sets an\n    // internal value on the channel telling it we're listening,\n    // then sets a listener on the Backbone.Events\n    tuneIn: function(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = true;\n      channel.on('all', _partial(channelName));\n      return this;\n    },\n  \n    // Stop logging all of the activities on this channel to the console\n    tuneOut: function(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = false;\n      channel.off('all', _partial(channelName));\n      delete _logs[channelName];\n      return this;\n    }\n  });\n  \n  /*\n   * Backbone.Radio.Commands\n   * -----------------------\n   * A messaging system for sending orders.\n   *\n   */\n  \n  Radio.Commands = {\n  \n    // Issue a command\n    command: function(name) {\n      var args = _.rest(arguments);\n      if (eventsApi(this, 'command', name, args)) {\n        return this;\n      }\n      var channelName = this.channelName;\n      var commands = this._commands;\n  \n      // Check if we should log the command, and if so, do it\n      if (channelName && this._tunedIn) {\n        Radio.log.apply(this, [channelName, name].concat(args));\n      }\n  \n      // If the command isn't handled, log it in DEBUG mode and exit\n      if (commands && (commands[name] || commands['default'])) {\n        var handler = commands[name] || commands['default'];\n        args = commands[name] ? args : arguments;\n        callHandler(handler.callback, handler.context, args);\n      } else {\n        debugLog('An unhandled command was fired', name, channelName);\n      }\n  \n      return this;\n    },\n  \n    // Register a handler for a command.\n    comply: function(name, callback, context) {\n      if (eventsApi(this, 'comply', name, [callback, context])) {\n        return this;\n      }\n      this._commands || (this._commands = {});\n  \n      if (this._commands[name]) {\n        debugLog('A command was overwritten', name, this.channelName);\n      }\n  \n      this._commands[name] = {\n        callback: callback,\n        context: context || this\n      };\n  \n      return this;\n    },\n  \n    // Register a handler for a command that happens just once.\n    complyOnce: function(name, callback, context) {\n      if (eventsApi(this, 'complyOnce', name, [callback, context])) {\n        return this;\n      }\n      var self = this;\n  \n      var once = _.once(function() {\n        self.stopComplying(name);\n        return callback.apply(this, arguments);\n      });\n  \n      return this.comply(name, once, context);\n    },\n  \n    // Remove handler(s)\n    stopComplying: function(name, callback, context) {\n      if (eventsApi(this, 'stopComplying', name)) {\n        return this;\n      }\n  \n      // Remove everything if there are no arguments passed\n      if (!name && !callback && !context) {\n        delete this._commands;\n      } else if (!removeHandlers(this._commands, name, callback, context)) {\n        debugLog('Attempted to remove the unregistered command', name, this.channelName);\n      }\n  \n      return this;\n    }\n  };\n  \n  /*\n   * Backbone.Radio.Requests\n   * -----------------------\n   * A messaging system for requesting data.\n   *\n   */\n  \n  function makeCallback(callback) {\n    return _.isFunction(callback) ? callback : function () { return callback; };\n  }\n  \n  Radio.Requests = {\n  \n    // Make a request\n    request: function(name) {\n      var args = _.rest(arguments);\n      var results = eventsApi(this, 'request', name, args);\n      if (results) {\n        return results;\n      }\n      var channelName = this.channelName;\n      var requests = this._requests;\n  \n      // Check if we should log the request, and if so, do it\n      if (channelName && this._tunedIn) {\n        Radio.log.apply(this, [channelName, name].concat(args));\n      }\n  \n      // If the request isn't handled, log it in DEBUG mode and exit\n      if (requests && (requests[name] || requests['default'])) {\n        var handler = requests[name] || requests['default'];\n        args = requests[name] ? args : arguments;\n        return callHandler(handler.callback, handler.context, args);\n      } else {\n        debugLog('An unhandled request was fired', name, channelName);\n      }\n    },\n  \n    // Set up a handler for a request\n    reply: function(name, callback, context) {\n      if (eventsApi(this, 'reply', name, [callback, context])) {\n        return this;\n      }\n  \n      this._requests || (this._requests = {});\n  \n      if (this._requests[name]) {\n        debugLog('A request was overwritten', name, this.channelName);\n      }\n  \n      this._requests[name] = {\n        callback: makeCallback(callback),\n        context: context || this\n      };\n  \n      return this;\n    },\n  \n    // Set up a handler that can only be requested once\n    replyOnce: function(name, callback, context) {\n      if (eventsApi(this, 'replyOnce', name, [callback, context])) {\n        return this;\n      }\n  \n      var self = this;\n  \n      var once = _.once(function() {\n        self.stopReplying(name);\n        return makeCallback(callback).apply(this, arguments);\n      });\n  \n      return this.reply(name, once, context);\n    },\n  \n    // Remove handler(s)\n    stopReplying: function(name, callback, context) {\n      if (eventsApi(this, 'stopReplying', name)) {\n        return this;\n      }\n  \n      // Remove everything if there are no arguments passed\n      if (!name && !callback && !context) {\n        delete this._requests;\n      } else if (!removeHandlers(this._requests, name, callback, context)) {\n        debugLog('Attempted to remove the unregistered request', name, this.channelName);\n      }\n  \n      return this;\n    }\n  };\n  \n  /*\n   * Backbone.Radio.channel\n   * ----------------------\n   * Get a reference to a channel by name.\n   *\n   */\n  \n  Radio._channels = {};\n  \n  Radio.channel = function(channelName) {\n    if (!channelName) {\n      throw new Error('You must provide a name for the channel.');\n    }\n  \n    if (Radio._channels[channelName]) {\n      return Radio._channels[channelName];\n    } else {\n      return (Radio._channels[channelName] = new Radio.Channel(channelName));\n    }\n  };\n  \n  /*\n   * Backbone.Radio.Channel\n   * ----------------------\n   * A Channel is an object that extends from Backbone.Events,\n   * Radio.Commands, and Radio.Requests.\n   *\n   */\n  \n  Radio.Channel = function(channelName) {\n    this.channelName = channelName;\n  };\n  \n  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Commands, Radio.Requests, {\n  \n    // Remove all handlers from the messaging systems of this channel\n    reset: function() {\n      this.off();\n      this.stopListening();\n      this.stopComplying();\n      this.stopReplying();\n      return this;\n    }\n  });\n  \n  /*\n   * Top-level API\n   * -------------\n   * Supplies the 'top-level API' for working with Channels directly\n   * from Backbone.Radio.\n   *\n   */\n  \n  var channel, args, systems = [Backbone.Events, Radio.Commands, Radio.Requests];\n  \n  _.each(systems, function(system) {\n    _.each(system, function(method, methodName) {\n      Radio[methodName] = function(channelName) {\n        args = _.rest(arguments);\n        channel = this.channel(channelName);\n        return channel[methodName].apply(channel, args);\n      };\n    });\n  });\n  \n\n  return Radio;\n}));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLnJhZGlvL2J1aWxkL2JhY2tib25lLnJhZGlvLmpzPzdkNWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBLDBDQUEwQyxZQUFZO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCYWNrYm9uZS5SYWRpbyB2MC44LjRcbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydiYWNrYm9uZScsICd1bmRlcnNjb3JlJ10sIGZ1bmN0aW9uKEJhY2tib25lLCBfKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShCYWNrYm9uZSwgXyk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoQmFja2JvbmUsIF8pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZhY3Rvcnkocm9vdC5CYWNrYm9uZSwgcm9vdC5fKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHByZXZpb3VzUmFkaW8gPSBCYWNrYm9uZS5SYWRpbztcbiAgXG4gIHZhciBSYWRpbyA9IEJhY2tib25lLlJhZGlvID0ge307XG4gIFxuICBSYWRpby5WRVJTSU9OID0gJzAuOC40JztcbiAgXG4gIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBydW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mIFJhZGlvIG9uIHRoZSBzYW1lXG4gIC8vIHdlYmFwcC4gQWZ0ZXIgbG9hZGluZyB0aGUgbmV3IHZlcnNpb24sIGNhbGwgYG5vQ29uZmxpY3QoKWAgdG9cbiAgLy8gZ2V0IGEgcmVmZXJlbmNlIHRvIGl0LiBBdCB0aGUgc2FtZSB0aW1lIHRoZSBvbGQgdmVyc2lvbiB3aWxsIGJlXG4gIC8vIHJldHVybmVkIHRvIEJhY2tib25lLlJhZGlvLlxuICBSYWRpby5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIEJhY2tib25lLlJhZGlvID0gcHJldmlvdXNSYWRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXG4gIC8vIFdoZXRoZXIgb3Igbm90IHdlJ3JlIGluIERFQlVHIG1vZGUgb3Igbm90LiBERUJVRyBtb2RlIGhlbHBzIHlvdVxuICAvLyBnZXQgYXJvdW5kIHRoZSBpc3N1ZXMgb2YgbGFjayBvZiB3YXJuaW5ncyB3aGVuIGV2ZW50cyBhcmUgbWlzLXR5cGVkLlxuICBSYWRpby5ERUJVRyA9IGZhbHNlO1xuICBcbiAgLy8gVGhpcyBpcyB0aGUgbWV0aG9kIHRoYXQncyBjYWxsZWQgd2hlbiBhbiB1bnJlZ2lzdGVyZWQgZXZlbnQgd2FzIGNhbGxlZC5cbiAgLy8gQnkgZGVmYXVsdCwgaXQgbG9ncyB3YXJuaW5nIHRvIHRoZSBjb25zb2xlLiBCeSBvdmVycmlkaW5nIHRoaXMgeW91IGNvdWxkXG4gIC8vIG1ha2UgaXQgdGhyb3cgYW4gRXJyb3IsIGZvciBpbnN0YW5jZS4gVGhpcyB3b3VsZCBtYWtlIGZpcmluZyBhIG5vbmV4aXN0ZW50IGV2ZW50XG4gIC8vIGhhdmUgdGhlIHNhbWUgY29uc2VxdWVuY2UgYXMgZmlyaW5nIGEgbm9uZXhpc3RlbnQgbWV0aG9kIG9uIGFuIE9iamVjdC5cbiAgZnVuY3Rpb24gZGVidWdMb2cod2FybmluZywgZXZlbnROYW1lLCBjaGFubmVsTmFtZSkge1xuICAgIGlmICghUmFkaW8uREVCVUcpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGNoYW5uZWxUZXh0ID0gY2hhbm5lbE5hbWUgPyAnIG9uIHRoZSAnICsgY2hhbm5lbE5hbWUgKyAnIGNoYW5uZWwnIDogJyc7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICBjb25zb2xlLndhcm4od2FybmluZyArIGNoYW5uZWxUZXh0ICsgJzogXCInICsgZXZlbnROYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIFxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcbiAgXG4gIC8vIEFuIGludGVybmFsIG1ldGhvZCB1c2VkIHRvIGhhbmRsZSBSYWRpbydzIG1ldGhvZCBvdmVybG9hZGluZyBmb3IgUmVxdWVzdHMgYW5kXG4gIC8vIENvbW1hbmRzLiBJdCdzIGJvcnJvd2VkIGZyb20gQmFja2JvbmUuRXZlbnRzLiBJdCBkaWZmZXJzIGZyb20gQmFja2JvbmUncyBvdmVybG9hZFxuICAvLyBBUEkgKHdoaWNoIGlzIHVzZWQgaW4gQmFja2JvbmUuRXZlbnRzKSBpbiB0aGF0IGl0IGRvZXNuJ3Qgc3VwcG9ydCBzcGFjZS1zZXBhcmF0ZWRcbiAgLy8gZXZlbnQgbmFtZXMuXG4gIGZ1bmN0aW9uIGV2ZW50c0FwaShvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgXG4gICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgXG4gICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcy5cbiAgICBpZiAoZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICAvLyBBbiBvcHRpbWl6ZWQgd2F5IHRvIGV4ZWN1dGUgY2FsbGJhY2tzLlxuICBmdW5jdGlvbiBjYWxsSGFuZGxlcihjYWxsYmFjaywgY29udGV4dCwgYXJncykge1xuICAgIHZhciBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgYTEpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0LCBhMSwgYTIpO1xuICAgICAgY2FzZSAzOiByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0LCBhMSwgYTIsIGEzKTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEEgaGVscGVyIHVzZWQgYnkgYG9mZmAgbWV0aG9kcyB0byB0aGUgaGFuZGxlciBmcm9tIHRoZSBzdG9yZVxuICBmdW5jdGlvbiByZW1vdmVIYW5kbGVyKHN0b3JlLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBldmVudCA9IHN0b3JlW25hbWVdO1xuICAgIGlmIChcbiAgICAgICAoIWNhbGxiYWNrIHx8IChjYWxsYmFjayA9PT0gZXZlbnQuY2FsbGJhY2sgfHwgY2FsbGJhY2sgPT09IGV2ZW50LmNhbGxiYWNrLl9jYWxsYmFjaykpICYmXG4gICAgICAgKCFjb250ZXh0IHx8IChjb250ZXh0ID09PSBldmVudC5jb250ZXh0KSlcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBzdG9yZVtuYW1lXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcnMoc3RvcmUsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgc3RvcmUgfHwgKHN0b3JlID0ge30pO1xuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoc3RvcmUpO1xuICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gIFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICBcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZXZlbnQgYnkgdGhpcyBuYW1lLCBsb2cgaXQgYW5kIGNvbnRpbnVlXG4gICAgICAvLyB3aXRoIHRoZSBsb29wXG4gICAgICBpZiAoIXN0b3JlW25hbWVdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChyZW1vdmVIYW5kbGVyKHN0b3JlLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfVxuICBcbiAgLypcbiAgICogdHVuZS1pblxuICAgKiAtLS0tLS0tXG4gICAqIEdldCBjb25zb2xlIGxvZ3Mgb2YgYSBjaGFubmVsJ3MgYWN0aXZpdHlcbiAgICpcbiAgICovXG4gIFxuICB2YXIgX2xvZ3MgPSB7fTtcbiAgXG4gIC8vIFRoaXMgaXMgdG8gcHJvZHVjZSBhbiBpZGVudGljYWwgZnVuY3Rpb24gaW4gYm90aCB0dW5lSW4gYW5kIHR1bmVPdXQsXG4gIC8vIHNvIHRoYXQgQmFja2JvbmUuRXZlbnRzIHVucmVnaXN0ZXJzIGl0LlxuICBmdW5jdGlvbiBfcGFydGlhbChjaGFubmVsTmFtZSkge1xuICAgIHJldHVybiBfbG9nc1tjaGFubmVsTmFtZV0gfHwgKF9sb2dzW2NoYW5uZWxOYW1lXSA9IF8ucGFydGlhbChSYWRpby5sb2csIGNoYW5uZWxOYW1lKSk7XG4gIH1cbiAgXG4gIF8uZXh0ZW5kKFJhZGlvLCB7XG4gIFxuICAgIC8vIExvZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbm5lbCBhbmQgZXZlbnRcbiAgICBsb2c6IGZ1bmN0aW9uKGNoYW5uZWxOYW1lLCBldmVudE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gXy5yZXN0KGFyZ3VtZW50cywgMik7XG4gICAgICBjb25zb2xlLmxvZygnWycgKyBjaGFubmVsTmFtZSArICddIFwiJyArIGV2ZW50TmFtZSArICdcIicsIGFyZ3MpO1xuICAgIH0sXG4gIFxuICAgIC8vIExvZ3MgYWxsIGV2ZW50cyBvbiB0aGlzIGNoYW5uZWwgdG8gdGhlIGNvbnNvbGUuIEl0IHNldHMgYW5cbiAgICAvLyBpbnRlcm5hbCB2YWx1ZSBvbiB0aGUgY2hhbm5lbCB0ZWxsaW5nIGl0IHdlJ3JlIGxpc3RlbmluZyxcbiAgICAvLyB0aGVuIHNldHMgYSBsaXN0ZW5lciBvbiB0aGUgQmFja2JvbmUuRXZlbnRzXG4gICAgdHVuZUluOiBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBSYWRpby5jaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICAgIGNoYW5uZWwuX3R1bmVkSW4gPSB0cnVlO1xuICAgICAgY2hhbm5lbC5vbignYWxsJywgX3BhcnRpYWwoY2hhbm5lbE5hbWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIFN0b3AgbG9nZ2luZyBhbGwgb2YgdGhlIGFjdGl2aXRpZXMgb24gdGhpcyBjaGFubmVsIHRvIHRoZSBjb25zb2xlXG4gICAgdHVuZU91dDogZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgICAgIHZhciBjaGFubmVsID0gUmFkaW8uY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsLl90dW5lZEluID0gZmFsc2U7XG4gICAgICBjaGFubmVsLm9mZignYWxsJywgX3BhcnRpYWwoY2hhbm5lbE5hbWUpKTtcbiAgICAgIGRlbGV0ZSBfbG9nc1tjaGFubmVsTmFtZV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLypcbiAgICogQmFja2JvbmUuUmFkaW8uQ29tbWFuZHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQSBtZXNzYWdpbmcgc3lzdGVtIGZvciBzZW5kaW5nIG9yZGVycy5cbiAgICpcbiAgICovXG4gIFxuICBSYWRpby5Db21tYW5kcyA9IHtcbiAgXG4gICAgLy8gSXNzdWUgYSBjb21tYW5kXG4gICAgY29tbWFuZDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBfLnJlc3QoYXJndW1lbnRzKTtcbiAgICAgIGlmIChldmVudHNBcGkodGhpcywgJ2NvbW1hbmQnLCBuYW1lLCBhcmdzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsTmFtZSA9IHRoaXMuY2hhbm5lbE5hbWU7XG4gICAgICB2YXIgY29tbWFuZHMgPSB0aGlzLl9jb21tYW5kcztcbiAgXG4gICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgbG9nIHRoZSBjb21tYW5kLCBhbmQgaWYgc28sIGRvIGl0XG4gICAgICBpZiAoY2hhbm5lbE5hbWUgJiYgdGhpcy5fdHVuZWRJbikge1xuICAgICAgICBSYWRpby5sb2cuYXBwbHkodGhpcywgW2NoYW5uZWxOYW1lLCBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIElmIHRoZSBjb21tYW5kIGlzbid0IGhhbmRsZWQsIGxvZyBpdCBpbiBERUJVRyBtb2RlIGFuZCBleGl0XG4gICAgICBpZiAoY29tbWFuZHMgJiYgKGNvbW1hbmRzW25hbWVdIHx8IGNvbW1hbmRzWydkZWZhdWx0J10pKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gY29tbWFuZHNbbmFtZV0gfHwgY29tbWFuZHNbJ2RlZmF1bHQnXTtcbiAgICAgICAgYXJncyA9IGNvbW1hbmRzW25hbWVdID8gYXJncyA6IGFyZ3VtZW50cztcbiAgICAgICAgY2FsbEhhbmRsZXIoaGFuZGxlci5jYWxsYmFjaywgaGFuZGxlci5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnTG9nKCdBbiB1bmhhbmRsZWQgY29tbWFuZCB3YXMgZmlyZWQnLCBuYW1lLCBjaGFubmVsTmFtZSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBhIGNvbW1hbmQuXG4gICAgY29tcGx5OiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKGV2ZW50c0FwaSh0aGlzLCAnY29tcGx5JywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21tYW5kcyB8fCAodGhpcy5fY29tbWFuZHMgPSB7fSk7XG4gIFxuICAgICAgaWYgKHRoaXMuX2NvbW1hbmRzW25hbWVdKSB7XG4gICAgICAgIGRlYnVnTG9nKCdBIGNvbW1hbmQgd2FzIG92ZXJ3cml0dGVuJywgbmFtZSwgdGhpcy5jaGFubmVsTmFtZSk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fY29tbWFuZHNbbmFtZV0gPSB7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgY29udGV4dDogY29udGV4dCB8fCB0aGlzXG4gICAgICB9O1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgYSBjb21tYW5kIHRoYXQgaGFwcGVucyBqdXN0IG9uY2UuXG4gICAgY29tcGx5T25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChldmVudHNBcGkodGhpcywgJ2NvbXBseU9uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgXG4gICAgICB2YXIgb25jZSA9IF8ub25jZShmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdG9wQ29tcGx5aW5nKG5hbWUpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHJldHVybiB0aGlzLmNvbXBseShuYW1lLCBvbmNlLCBjb250ZXh0KTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgaGFuZGxlcihzKVxuICAgIHN0b3BDb21wbHlpbmc6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoZXZlbnRzQXBpKHRoaXMsICdzdG9wQ29tcGx5aW5nJywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgaWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cyBwYXNzZWRcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1hbmRzO1xuICAgICAgfSBlbHNlIGlmICghcmVtb3ZlSGFuZGxlcnModGhpcy5fY29tbWFuZHMsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSkge1xuICAgICAgICBkZWJ1Z0xvZygnQXR0ZW1wdGVkIHRvIHJlbW92ZSB0aGUgdW5yZWdpc3RlcmVkIGNvbW1hbmQnLCBuYW1lLCB0aGlzLmNoYW5uZWxOYW1lKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIFxuICAvKlxuICAgKiBCYWNrYm9uZS5SYWRpby5SZXF1ZXN0c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBBIG1lc3NhZ2luZyBzeXN0ZW0gZm9yIHJlcXVlc3RpbmcgZGF0YS5cbiAgICpcbiAgICovXG4gIFxuICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2s7IH07XG4gIH1cbiAgXG4gIFJhZGlvLlJlcXVlc3RzID0ge1xuICBcbiAgICAvLyBNYWtlIGEgcmVxdWVzdFxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gXy5yZXN0KGFyZ3VtZW50cyk7XG4gICAgICB2YXIgcmVzdWx0cyA9IGV2ZW50c0FwaSh0aGlzLCAncmVxdWVzdCcsIG5hbWUsIGFyZ3MpO1xuICAgICAgaWYgKHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbE5hbWUgPSB0aGlzLmNoYW5uZWxOYW1lO1xuICAgICAgdmFyIHJlcXVlc3RzID0gdGhpcy5fcmVxdWVzdHM7XG4gIFxuICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGxvZyB0aGUgcmVxdWVzdCwgYW5kIGlmIHNvLCBkbyBpdFxuICAgICAgaWYgKGNoYW5uZWxOYW1lICYmIHRoaXMuX3R1bmVkSW4pIHtcbiAgICAgICAgUmFkaW8ubG9nLmFwcGx5KHRoaXMsIFtjaGFubmVsTmFtZSwgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBoYW5kbGVkLCBsb2cgaXQgaW4gREVCVUcgbW9kZSBhbmQgZXhpdFxuICAgICAgaWYgKHJlcXVlc3RzICYmIChyZXF1ZXN0c1tuYW1lXSB8fCByZXF1ZXN0c1snZGVmYXVsdCddKSkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHJlcXVlc3RzW25hbWVdIHx8IHJlcXVlc3RzWydkZWZhdWx0J107XG4gICAgICAgIGFyZ3MgPSByZXF1ZXN0c1tuYW1lXSA/IGFyZ3MgOiBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBjYWxsSGFuZGxlcihoYW5kbGVyLmNhbGxiYWNrLCBoYW5kbGVyLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWdMb2coJ0FuIHVuaGFuZGxlZCByZXF1ZXN0IHdhcyBmaXJlZCcsIG5hbWUsIGNoYW5uZWxOYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBTZXQgdXAgYSBoYW5kbGVyIGZvciBhIHJlcXVlc3RcbiAgICByZXBseTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChldmVudHNBcGkodGhpcywgJ3JlcGx5JywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fcmVxdWVzdHMgfHwgKHRoaXMuX3JlcXVlc3RzID0ge30pO1xuICBcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0c1tuYW1lXSkge1xuICAgICAgICBkZWJ1Z0xvZygnQSByZXF1ZXN0IHdhcyBvdmVyd3JpdHRlbicsIG5hbWUsIHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX3JlcXVlc3RzW25hbWVdID0ge1xuICAgICAgICBjYWxsYmFjazogbWFrZUNhbGxiYWNrKGNhbGxiYWNrKSxcbiAgICAgICAgY29udGV4dDogY29udGV4dCB8fCB0aGlzXG4gICAgICB9O1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIFNldCB1cCBhIGhhbmRsZXIgdGhhdCBjYW4gb25seSBiZSByZXF1ZXN0ZWQgb25jZVxuICAgIHJlcGx5T25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChldmVudHNBcGkodGhpcywgJ3JlcGx5T25jZScsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgXG4gICAgICB2YXIgb25jZSA9IF8ub25jZShmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdG9wUmVwbHlpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soY2FsbGJhY2spLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgXG4gICAgICByZXR1cm4gdGhpcy5yZXBseShuYW1lLCBvbmNlLCBjb250ZXh0KTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgaGFuZGxlcihzKVxuICAgIHN0b3BSZXBseWluZzogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChldmVudHNBcGkodGhpcywgJ3N0b3BSZXBseWluZycsIG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICBcbiAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHMgcGFzc2VkXG4gICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0cztcbiAgICAgIH0gZWxzZSBpZiAoIXJlbW92ZUhhbmRsZXJzKHRoaXMuX3JlcXVlc3RzLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkpIHtcbiAgICAgICAgZGVidWdMb2coJ0F0dGVtcHRlZCB0byByZW1vdmUgdGhlIHVucmVnaXN0ZXJlZCByZXF1ZXN0JywgbmFtZSwgdGhpcy5jaGFubmVsTmFtZSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBcbiAgLypcbiAgICogQmFja2JvbmUuUmFkaW8uY2hhbm5lbFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEdldCBhIHJlZmVyZW5jZSB0byBhIGNoYW5uZWwgYnkgbmFtZS5cbiAgICpcbiAgICovXG4gIFxuICBSYWRpby5fY2hhbm5lbHMgPSB7fTtcbiAgXG4gIFJhZGlvLmNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgIGlmICghY2hhbm5lbE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIG5hbWUgZm9yIHRoZSBjaGFubmVsLicpO1xuICAgIH1cbiAgXG4gICAgaWYgKFJhZGlvLl9jaGFubmVsc1tjaGFubmVsTmFtZV0pIHtcbiAgICAgIHJldHVybiBSYWRpby5fY2hhbm5lbHNbY2hhbm5lbE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFJhZGlvLl9jaGFubmVsc1tjaGFubmVsTmFtZV0gPSBuZXcgUmFkaW8uQ2hhbm5lbChjaGFubmVsTmFtZSkpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8qXG4gICAqIEJhY2tib25lLlJhZGlvLkNoYW5uZWxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBBIENoYW5uZWwgaXMgYW4gb2JqZWN0IHRoYXQgZXh0ZW5kcyBmcm9tIEJhY2tib25lLkV2ZW50cyxcbiAgICogUmFkaW8uQ29tbWFuZHMsIGFuZCBSYWRpby5SZXF1ZXN0cy5cbiAgICpcbiAgICovXG4gIFxuICBSYWRpby5DaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgICB0aGlzLmNoYW5uZWxOYW1lID0gY2hhbm5lbE5hbWU7XG4gIH07XG4gIFxuICBfLmV4dGVuZChSYWRpby5DaGFubmVsLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCBSYWRpby5Db21tYW5kcywgUmFkaW8uUmVxdWVzdHMsIHtcbiAgXG4gICAgLy8gUmVtb3ZlIGFsbCBoYW5kbGVycyBmcm9tIHRoZSBtZXNzYWdpbmcgc3lzdGVtcyBvZiB0aGlzIGNoYW5uZWxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9mZigpO1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICB0aGlzLnN0b3BDb21wbHlpbmcoKTtcbiAgICAgIHRoaXMuc3RvcFJlcGx5aW5nKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLypcbiAgICogVG9wLWxldmVsIEFQSVxuICAgKiAtLS0tLS0tLS0tLS0tXG4gICAqIFN1cHBsaWVzIHRoZSAndG9wLWxldmVsIEFQSScgZm9yIHdvcmtpbmcgd2l0aCBDaGFubmVscyBkaXJlY3RseVxuICAgKiBmcm9tIEJhY2tib25lLlJhZGlvLlxuICAgKlxuICAgKi9cbiAgXG4gIHZhciBjaGFubmVsLCBhcmdzLCBzeXN0ZW1zID0gW0JhY2tib25lLkV2ZW50cywgUmFkaW8uQ29tbWFuZHMsIFJhZGlvLlJlcXVlc3RzXTtcbiAgXG4gIF8uZWFjaChzeXN0ZW1zLCBmdW5jdGlvbihzeXN0ZW0pIHtcbiAgICBfLmVhY2goc3lzdGVtLCBmdW5jdGlvbihtZXRob2QsIG1ldGhvZE5hbWUpIHtcbiAgICAgIFJhZGlvW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgYXJncyA9IF8ucmVzdChhcmd1bWVudHMpO1xuICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxbbWV0aG9kTmFtZV0uYXBwbHkoY2hhbm5lbCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbiAgXG5cbiAgcmV0dXJuIFJhZGlvO1xufSkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFja2JvbmUucmFkaW8vYnVpbGQvYmFja2JvbmUucmFkaW8uanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIiLCJmaWxlIjoiNjUuanMifQ==");

/***/ },
/* 66 */,
/* 67 */,
/* 68 */
/*!********************************************************************************!*\
  !*** ./~/backbone.marionette/~/backbone.babysitter/lib/backbone.babysitter.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Backbone.BabySitter\n// -------------------\n// v0.1.5\n//\n// Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.\n// Distributed under MIT license\n//\n// http://github.com/marionettejs/backbone.babysitter\n\n(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! backbone */ 1), __webpack_require__(/*! underscore */ 2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {\n      return factory(Backbone, _);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== 'undefined') {\n    var Backbone = require('backbone');\n    var _ = require('underscore');\n    module.exports = factory(Backbone, _);\n  } else {\n    factory(root.Backbone, root._);\n  }\n\n}(this, function(Backbone, _) {\n  'use strict';\n\n  var previousChildViewContainer = Backbone.ChildViewContainer;\n\n  // BabySitter.ChildViewContainer\n  // -----------------------------\n  //\n  // Provide a container to store, retrieve and\n  // shut down child views.\n  \n  Backbone.ChildViewContainer = (function (Backbone, _) {\n  \n    // Container Constructor\n    // ---------------------\n  \n    var Container = function(views){\n      this._views = {};\n      this._indexByModel = {};\n      this._indexByCustom = {};\n      this._updateLength();\n  \n      _.each(views, this.add, this);\n    };\n  \n    // Container Methods\n    // -----------------\n  \n    _.extend(Container.prototype, {\n  \n      // Add a view to this container. Stores the view\n      // by `cid` and makes it searchable by the model\n      // cid (and model itself). Optionally specify\n      // a custom key to store an retrieve the view.\n      add: function(view, customIndex){\n        var viewCid = view.cid;\n  \n        // store the view\n        this._views[viewCid] = view;\n  \n        // index it by model\n        if (view.model){\n          this._indexByModel[view.model.cid] = viewCid;\n        }\n  \n        // index by custom\n        if (customIndex){\n          this._indexByCustom[customIndex] = viewCid;\n        }\n  \n        this._updateLength();\n        return this;\n      },\n  \n      // Find a view by the model that was attached to\n      // it. Uses the model's `cid` to find it.\n      findByModel: function(model){\n        return this.findByModelCid(model.cid);\n      },\n  \n      // Find a view by the `cid` of the model that was attached to\n      // it. Uses the model's `cid` to find the view `cid` and\n      // retrieve the view using it.\n      findByModelCid: function(modelCid){\n        var viewCid = this._indexByModel[modelCid];\n        return this.findByCid(viewCid);\n      },\n  \n      // Find a view by a custom indexer.\n      findByCustom: function(index){\n        var viewCid = this._indexByCustom[index];\n        return this.findByCid(viewCid);\n      },\n  \n      // Find by index. This is not guaranteed to be a\n      // stable index.\n      findByIndex: function(index){\n        return _.values(this._views)[index];\n      },\n  \n      // retrieve a view by its `cid` directly\n      findByCid: function(cid){\n        return this._views[cid];\n      },\n  \n      // Remove a view\n      remove: function(view){\n        var viewCid = view.cid;\n  \n        // delete model index\n        if (view.model){\n          delete this._indexByModel[view.model.cid];\n        }\n  \n        // delete custom index\n        _.any(this._indexByCustom, function(cid, key) {\n          if (cid === viewCid) {\n            delete this._indexByCustom[key];\n            return true;\n          }\n        }, this);\n  \n        // remove the view from the container\n        delete this._views[viewCid];\n  \n        // update the length\n        this._updateLength();\n        return this;\n      },\n  \n      // Call a method on every view in the container,\n      // passing parameters to the call method one at a\n      // time, like `function.call`.\n      call: function(method){\n        this.apply(method, _.tail(arguments));\n      },\n  \n      // Apply a method on every view in the container,\n      // passing parameters to the call method one at a\n      // time, like `function.apply`.\n      apply: function(method, args){\n        _.each(this._views, function(view){\n          if (_.isFunction(view[method])){\n            view[method].apply(view, args || []);\n          }\n        });\n      },\n  \n      // Update the `.length` attribute on this container\n      _updateLength: function(){\n        this.length = _.size(this._views);\n      }\n    });\n  \n    // Borrowing this code from Backbone.Collection:\n    // http://backbonejs.org/docs/backbone.html#section-106\n    //\n    // Mix in methods from Underscore, for iteration, and other\n    // collection related features.\n    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',\n      'select', 'reject', 'every', 'all', 'some', 'any', 'include',\n      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',\n      'last', 'without', 'isEmpty', 'pluck'];\n  \n    _.each(methods, function(method) {\n      Container.prototype[method] = function() {\n        var views = _.values(this._views);\n        var args = [views].concat(_.toArray(arguments));\n        return _[method].apply(_, args);\n      };\n    });\n  \n    // return the public API\n    return Container;\n  })(Backbone, _);\n  \n\n  Backbone.ChildViewContainer.VERSION = '0.1.5';\n\n  Backbone.ChildViewContainer.noConflict = function () {\n    Backbone.ChildViewContainer = previousChildViewContainer;\n    return this;\n  };\n\n  return Backbone.ChildViewContainer;\n\n}));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2JhY2tib25lLm1hcmlvbmV0dGUvfi9iYWNrYm9uZS5iYWJ5c2l0dGVyL2xpYi9iYWNrYm9uZS5iYWJ5c2l0dGVyLmpzP2JiOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFja2JvbmUuQmFieVNpdHRlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdjAuMS41XG4vL1xuLy8gQ29weXJpZ2h0IChjKTIwMTQgRGVyaWNrIEJhaWxleSwgTXV0ZWQgU29sdXRpb25zLCBMTEMuXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZVxuLy9cbi8vIGh0dHA6Ly9naXRodWIuY29tL21hcmlvbmV0dGVqcy9iYWNrYm9uZS5iYWJ5c2l0dGVyXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2JhY2tib25lJywgJ3VuZGVyc2NvcmUnXSwgZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KEJhY2tib25lLCBfKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShCYWNrYm9uZSwgXyk7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeShyb290LkJhY2tib25lLCByb290Ll8pO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwcmV2aW91c0NoaWxkVmlld0NvbnRhaW5lciA9IEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lcjtcblxuICAvLyBCYWJ5U2l0dGVyLkNoaWxkVmlld0NvbnRhaW5lclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBQcm92aWRlIGEgY29udGFpbmVyIHRvIHN0b3JlLCByZXRyaWV2ZSBhbmRcbiAgLy8gc2h1dCBkb3duIGNoaWxkIHZpZXdzLlxuICBcbiAgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyID0gKGZ1bmN0aW9uIChCYWNrYm9uZSwgXykge1xuICBcbiAgICAvLyBDb250YWluZXIgQ29uc3RydWN0b3JcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgdmFyIENvbnRhaW5lciA9IGZ1bmN0aW9uKHZpZXdzKXtcbiAgICAgIHRoaXMuX3ZpZXdzID0ge307XG4gICAgICB0aGlzLl9pbmRleEJ5TW9kZWwgPSB7fTtcbiAgICAgIHRoaXMuX2luZGV4QnlDdXN0b20gPSB7fTtcbiAgICAgIHRoaXMuX3VwZGF0ZUxlbmd0aCgpO1xuICBcbiAgICAgIF8uZWFjaCh2aWV3cywgdGhpcy5hZGQsIHRoaXMpO1xuICAgIH07XG4gIFxuICAgIC8vIENvbnRhaW5lciBNZXRob2RzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgXy5leHRlbmQoQ29udGFpbmVyLnByb3RvdHlwZSwge1xuICBcbiAgICAgIC8vIEFkZCBhIHZpZXcgdG8gdGhpcyBjb250YWluZXIuIFN0b3JlcyB0aGUgdmlld1xuICAgICAgLy8gYnkgYGNpZGAgYW5kIG1ha2VzIGl0IHNlYXJjaGFibGUgYnkgdGhlIG1vZGVsXG4gICAgICAvLyBjaWQgKGFuZCBtb2RlbCBpdHNlbGYpLiBPcHRpb25hbGx5IHNwZWNpZnlcbiAgICAgIC8vIGEgY3VzdG9tIGtleSB0byBzdG9yZSBhbiByZXRyaWV2ZSB0aGUgdmlldy5cbiAgICAgIGFkZDogZnVuY3Rpb24odmlldywgY3VzdG9tSW5kZXgpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHZpZXcuY2lkO1xuICBcbiAgICAgICAgLy8gc3RvcmUgdGhlIHZpZXdcbiAgICAgICAgdGhpcy5fdmlld3Nbdmlld0NpZF0gPSB2aWV3O1xuICBcbiAgICAgICAgLy8gaW5kZXggaXQgYnkgbW9kZWxcbiAgICAgICAgaWYgKHZpZXcubW9kZWwpe1xuICAgICAgICAgIHRoaXMuX2luZGV4QnlNb2RlbFt2aWV3Lm1vZGVsLmNpZF0gPSB2aWV3Q2lkO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBpbmRleCBieSBjdXN0b21cbiAgICAgICAgaWYgKGN1c3RvbUluZGV4KXtcbiAgICAgICAgICB0aGlzLl9pbmRleEJ5Q3VzdG9tW2N1c3RvbUluZGV4XSA9IHZpZXdDaWQ7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gRmluZCBhIHZpZXcgYnkgdGhlIG1vZGVsIHRoYXQgd2FzIGF0dGFjaGVkIHRvXG4gICAgICAvLyBpdC4gVXNlcyB0aGUgbW9kZWwncyBgY2lkYCB0byBmaW5kIGl0LlxuICAgICAgZmluZEJ5TW9kZWw6IGZ1bmN0aW9uKG1vZGVsKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJ5TW9kZWxDaWQobW9kZWwuY2lkKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gRmluZCBhIHZpZXcgYnkgdGhlIGBjaWRgIG9mIHRoZSBtb2RlbCB0aGF0IHdhcyBhdHRhY2hlZCB0b1xuICAgICAgLy8gaXQuIFVzZXMgdGhlIG1vZGVsJ3MgYGNpZGAgdG8gZmluZCB0aGUgdmlldyBgY2lkYCBhbmRcbiAgICAgIC8vIHJldHJpZXZlIHRoZSB2aWV3IHVzaW5nIGl0LlxuICAgICAgZmluZEJ5TW9kZWxDaWQ6IGZ1bmN0aW9uKG1vZGVsQ2lkKXtcbiAgICAgICAgdmFyIHZpZXdDaWQgPSB0aGlzLl9pbmRleEJ5TW9kZWxbbW9kZWxDaWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlDaWQodmlld0NpZCk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEZpbmQgYSB2aWV3IGJ5IGEgY3VzdG9tIGluZGV4ZXIuXG4gICAgICBmaW5kQnlDdXN0b206IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgdmFyIHZpZXdDaWQgPSB0aGlzLl9pbmRleEJ5Q3VzdG9tW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJ5Q2lkKHZpZXdDaWQpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBGaW5kIGJ5IGluZGV4LiBUaGlzIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGFcbiAgICAgIC8vIHN0YWJsZSBpbmRleC5cbiAgICAgIGZpbmRCeUluZGV4OiBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHJldHVybiBfLnZhbHVlcyh0aGlzLl92aWV3cylbaW5kZXhdO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyByZXRyaWV2ZSBhIHZpZXcgYnkgaXRzIGBjaWRgIGRpcmVjdGx5XG4gICAgICBmaW5kQnlDaWQ6IGZ1bmN0aW9uKGNpZCl7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3c1tjaWRdO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBSZW1vdmUgYSB2aWV3XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHZpZXcuY2lkO1xuICBcbiAgICAgICAgLy8gZGVsZXRlIG1vZGVsIGluZGV4XG4gICAgICAgIGlmICh2aWV3Lm1vZGVsKXtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faW5kZXhCeU1vZGVsW3ZpZXcubW9kZWwuY2lkXTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gZGVsZXRlIGN1c3RvbSBpbmRleFxuICAgICAgICBfLmFueSh0aGlzLl9pbmRleEJ5Q3VzdG9tLCBmdW5jdGlvbihjaWQsIGtleSkge1xuICAgICAgICAgIGlmIChjaWQgPT09IHZpZXdDaWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRleEJ5Q3VzdG9tW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB2aWV3IGZyb20gdGhlIGNvbnRhaW5lclxuICAgICAgICBkZWxldGUgdGhpcy5fdmlld3Nbdmlld0NpZF07XG4gIFxuICAgICAgICAvLyB1cGRhdGUgdGhlIGxlbmd0aFxuICAgICAgICB0aGlzLl91cGRhdGVMZW5ndGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIENhbGwgYSBtZXRob2Qgb24gZXZlcnkgdmlldyBpbiB0aGUgY29udGFpbmVyLFxuICAgICAgLy8gcGFzc2luZyBwYXJhbWV0ZXJzIHRvIHRoZSBjYWxsIG1ldGhvZCBvbmUgYXQgYVxuICAgICAgLy8gdGltZSwgbGlrZSBgZnVuY3Rpb24uY2FsbGAuXG4gICAgICBjYWxsOiBmdW5jdGlvbihtZXRob2Qpe1xuICAgICAgICB0aGlzLmFwcGx5KG1ldGhvZCwgXy50YWlsKGFyZ3VtZW50cykpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBBcHBseSBhIG1ldGhvZCBvbiBldmVyeSB2aWV3IGluIHRoZSBjb250YWluZXIsXG4gICAgICAvLyBwYXNzaW5nIHBhcmFtZXRlcnMgdG8gdGhlIGNhbGwgbWV0aG9kIG9uZSBhdCBhXG4gICAgICAvLyB0aW1lLCBsaWtlIGBmdW5jdGlvbi5hcHBseWAuXG4gICAgICBhcHBseTogZnVuY3Rpb24obWV0aG9kLCBhcmdzKXtcbiAgICAgICAgXy5lYWNoKHRoaXMuX3ZpZXdzLCBmdW5jdGlvbih2aWV3KXtcbiAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpZXdbbWV0aG9kXSkpe1xuICAgICAgICAgICAgdmlld1ttZXRob2RdLmFwcGx5KHZpZXcsIGFyZ3MgfHwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgYC5sZW5ndGhgIGF0dHJpYnV0ZSBvbiB0aGlzIGNvbnRhaW5lclxuICAgICAgX3VwZGF0ZUxlbmd0aDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBfLnNpemUodGhpcy5fdmlld3MpO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICAvLyBCb3Jyb3dpbmcgdGhpcyBjb2RlIGZyb20gQmFja2JvbmUuQ29sbGVjdGlvbjpcbiAgICAvLyBodHRwOi8vYmFja2JvbmVqcy5vcmcvZG9jcy9iYWNrYm9uZS5odG1sI3NlY3Rpb24tMTA2XG4gICAgLy9cbiAgICAvLyBNaXggaW4gbWV0aG9kcyBmcm9tIFVuZGVyc2NvcmUsIGZvciBpdGVyYXRpb24sIGFuZCBvdGhlclxuICAgIC8vIGNvbGxlY3Rpb24gcmVsYXRlZCBmZWF0dXJlcy5cbiAgICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLFxuICAgICAgJ3NlbGVjdCcsICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLFxuICAgICAgJ2NvbnRhaW5zJywgJ2ludm9rZScsICd0b0FycmF5JywgJ2ZpcnN0JywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgICAnbGFzdCcsICd3aXRob3V0JywgJ2lzRW1wdHknLCAncGx1Y2snXTtcbiAgXG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgQ29udGFpbmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3cyA9IF8udmFsdWVzKHRoaXMuX3ZpZXdzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdmlld3NdLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICBcbiAgICAvLyByZXR1cm4gdGhlIHB1YmxpYyBBUElcbiAgICByZXR1cm4gQ29udGFpbmVyO1xuICB9KShCYWNrYm9uZSwgXyk7XG4gIFxuXG4gIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lci5WRVJTSU9OID0gJzAuMS41JztcblxuICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIgPSBwcmV2aW91c0NoaWxkVmlld0NvbnRhaW5lcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyO1xuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWNrYm9uZS5tYXJpb25ldHRlL34vYmFja2JvbmUuYmFieXNpdHRlci9saWIvYmFja2JvbmUuYmFieXNpdHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiIsImZpbGUiOiI2OC5qcyJ9");

/***/ }
/******/ ])